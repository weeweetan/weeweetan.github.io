<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>weeweetan&#39;s blog</title>
  
  <subtitle>GitHub个人站点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weeweetan.github.io/"/>
  <updated>2019-08-06T08:28:20.806Z</updated>
  <id>https://weeweetan.github.io/</id>
  
  <author>
    <name>weeweetan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx的upstream模块</title>
    <link href="https://weeweetan.github.io/2019/07/16/Nginx%E7%9A%84upstream%E6%A8%A1%E5%9D%97/"/>
    <id>https://weeweetan.github.io/2019/07/16/Nginx的upstream模块/</id>
    <published>2019-07-16T14:58:54.000Z</published>
    <updated>2019-08-06T08:28:20.806Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="1-相关配置"><a href="#1-相关配置" class="headerlink" title="1.相关配置"></a>1.相关配置</h2><blockquote><p>upstream模块的典型应用是反向代理，这里就以ngx_http_proxy_module模块为例。假定我们有如下这样的实例环境，客户端对服务器80端口的请求都被Nginx Proxy Server转发到另外两个真实的Nginx Web Server实例上进行处理（下图是实验环境，Web Server和Proxy Server都只是Nginx进程，并且运行在同一台服务器）：<br><img src="/images/2019-07-16_nginx_upstream_1.png" alt><br>那么，Nginx Proxy Server的核心配置多半是这样：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">Filename : nginx.conf</span><br><span class="line">…</span><br><span class="line">http &#123;</span><br><span class="line">    …</span><br><span class="line">upstream load_balance &#123;</span><br><span class="line">server localhost:8001;</span><br><span class="line">server localhost:8002;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_buffering off;</span><br><span class="line">proxy_pass http://load_balance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的<em>proxy_buffering off;</em>配置是为了禁用nginx反向代理的缓存功能，保证客户端的每次请求都被转发到后端真实服务器，以便我们每次跟踪分析的nginx执行流程更加简单且完整。而另外两个配置指令upstream和proxy_pass在此处显得更为重要，其中upstream配置指令的回调处理函数为ngx_http_upstream()，该函数除了申请内存、设置初始值等之外，最主要的动作就是切换配置上下文并调用ngx_conf_parse()函数继续进行配置解析：</p></blockquote><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2.源码解析"></a>2.源码解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filename : ngx_http_upstream.c</span><br><span class="line">    pcf = *cf;</span><br><span class="line">    cf-&gt;ctx = ctx;</span><br><span class="line">    cf-&gt;cmd_type = NGX_HTTP_UPS_CONF;</span><br><span class="line"></span><br><span class="line">    rv = ngx_conf_parse(cf, <span class="literal">NULL</span>);</span><br><span class="line">…</span><br><span class="line">    <span class="keyword">if</span> (uscf-&gt;servers == <span class="literal">NULL</span>) &#123;</span><br></pre></td></tr></table></figure><blockquote><p>进入到upstream配置块内，最主要的配置指令也就是server，其对应的处理函数为ngx_http_upstream_server()，对于每一个后端真实服务器，除了其uri地址外，还有诸如down、weight、max_fails、fail_timeout、backup这样的可选参数，所有这些都需要ngx_http_upstream_server()函数来处理。<br>在ngx_http_upstream.c的第4173行下个断点，我们可以看到这里给出示例的解析结果：<br><img src="/images/2019-07-16_nginx_upstream_2.png" alt></p></blockquote><blockquote><p>另外一个重要配置指令proxy_pass主要出现在location配置上下文中，而其对应的处理函数为ngx_http_proxy_pass()，抹去该函数内的众多细节，我们重点关注两个赋值语句：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filename : ngx_http_proxy_module.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *</span><br><span class="line">ngx_http_proxy_pass(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">    clcf-&gt;handler = ngx_http_proxy_handler;</span><br><span class="line">…</span><br><span class="line">    plcf-&gt;upstream.upstream = ngx_http_upstream_add(cf, &amp;u, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面片段代码里的第一个赋值语句给当前location的http处理设置回调函数，而第二个赋值语句则是查找（没有找到则会创建，比如如果配置文件中upstream指令出现在proxy_pass指令的后面）其对应的upstream配置，我们这里就一个名为load_balance的upstream，所以找到的配置就是它了：<br><img src="/images/2019-07-16_nginx_upstream_3.png" alt></p></blockquote><blockquote><p>前面曾提到，Nginx将对客户端的http请求处理分为多个阶段，而其中有个NGX_HTTP_FIND_CONFIG_PHASE阶段主要就是做配置查找处理，如果当前请求location设置了upstream，即回调函数指针clcf-&gt;handler不为空，则表示对该location的请求需要后端真实服务器来处理：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Filename : ngx_http_core_module.c</span><br><span class="line"><span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_core_find_config_phase(<span class="keyword">ngx_http_request_t</span> *r,</span><br><span class="line">    <span class="keyword">ngx_http_phase_handler_t</span> *ph)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">    ngx_http_update_location_config(r);</span><br><span class="line">…</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_http_update_location_config(<span class="keyword">ngx_http_request_t</span> *r)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">    <span class="keyword">if</span> (clcf-&gt;handler) &#123;</span><br><span class="line">        r-&gt;content_handler = clcf-&gt;handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在其它有location更新的情况下，比如redirect重定向location或named命名location或if条件location等，此时也会调用ngx_http_update_location_config()函数进行location配置更新。我们知道upstream模块的主要功能是产生响应数据，虽然这些响应数据来自后端真实服务器，所以在NGX_HTTP_CONTENT_PHASE 阶段的checker函数ngx_http_core_content_phase()内，我们可以看到在r-&gt;content_handler不为空的情况下会优先对r-&gt;content_handler函数指针进行回调：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Filename : ngx_http_core_module.c</span><br><span class="line"><span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_core_content_phase(<span class="keyword">ngx_http_request_t</span> *r,</span><br><span class="line">    <span class="keyword">ngx_http_phase_handler_t</span> *ph)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;content_handler) &#123;</span><br><span class="line">        r-&gt;write_event_handler = ngx_http_request_empty_handler;</span><br><span class="line">        ngx_http_finalize_request(r, r-&gt;content_handler(r));</span><br><span class="line">        <span class="keyword">return</span> NGX_OK;</span><br><span class="line">    &#125;</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>如果r-&gt;content_handler不为空，即存在upstream，那么进入处理，注意第1397行直接返回NGX_OK，也即不再调用挂在该阶段的其它模块回调函数，所以说upstream模块的优先级是最高的。根据前面的回调赋值，调用r-&gt;content_handler()指针函数，实质上就是执行函数ngx_http_proxy_handler()，直到这里，我们才真正走进upstream代理模块的处理逻辑里。</p><h2 id="3-回调函数"><a href="#3-回调函数" class="headerlink" title="3.回调函数"></a>3.回调函数</h2><blockquote><p>对于任何一个Upstream模块而言，最核心的实现主要是7个回调函数，upstream代理模块自然也不例外，它实现并注册了这7个回调函数：</p></blockquote><table><thead><tr><th style="text-align:center">回调指针</th><th style="text-align:center">函数功能</th><th style="text-align:center">upstream代理模块</th></tr></thead><tbody><tr><td style="text-align:center">create_request</td><td style="text-align:center">根据nginx与后端服务器通信协议（比如HTTP、Memcache），将客户端的HTTP请求信息转换为对应的发送到后端服务器的真实请求</td><td style="text-align:center">ngx_http_proxy_create_request 由于nginx与后端服务器通信协议也为HTTP，所以直接拷贝客户端的请求头、请求体（如果有）到变量r-&gt;upstream-&gt;request_bufs内。</td></tr><tr><td style="text-align:center">process_header</td><td style="text-align:center">根据nginx与后端服务器通信协议，将后端服务器返回的头部信息转换为对客户端响应的HTTP响应头。</td><td style="text-align:center">ngx_http_proxy_process_status_line 此时后端服务器返回的头部信息已经保存在变量r-&gt;upstream-&gt;buffer内，将这串字符串解析为HTTP响应头存储到变量r-&gt;upstream-&gt;headers_in内。</td></tr><tr><td style="text-align:center">input_filter_init</td><td style="text-align:center">根据前面获得的后端服务器返回的头部信息，为进一步处理后端服务器将返回的响应体做初始准备工作。</td><td style="text-align:center">ngx_http_proxy_input_filter_init 根据已解析的后端服务器返回的头部信息，设置需进一步处理的后端服务器将返回的响应体的长度，该值保存在变量r-&gt;upstream-&gt;length内。</td></tr><tr><td style="text-align:center">input_filter</td><td style="text-align:center">正式处理后端服务器返回的响应体</td><td style="text-align:center">ngx_http_proxy_non_buffered_copy_filter 本次收到的响应体数据长度为bytes，数据长度存储在r-&gt;upstream-&gt;buffer内，把它加入到r-&gt;upstream-&gt;out_bufs响应数据链等待发送给客户端。</td></tr><tr><td style="text-align:center">finalize_request</td><td style="text-align:center">正常结束与后端服务器的交互，比如剩余待取数据长度为0或读到EOF等，之后就会调用该函数。由于nginx会自动完成与后端服务器交互的清理工作，所以该函数一般仅做下日志，标识响应正常结束。</td><td style="text-align:center">ngx_http_proxy_finalize_request 记录一条日志，标识正常结束与后端服务器的交互，然后函数返回。</td></tr><tr><td style="text-align:center">reinit_request</td><td style="text-align:center">对交互重新初始化，比如当nginx发现一台后端服务器出错无法正常完成处理，需要尝试请求另一台后端服务器时就会调用该函数。</td><td style="text-align:center">ngx_http_proxy_reinit_request设置初始值，设置回调指针，处理比较简单。</td></tr><tr><td style="text-align:center">abort_request</td><td style="text-align:center">异常结束与后端服务器的交互后就会调用该函数。大部分情况下，该函数仅做下日志，标识响应异常结束。</td><td style="text-align:center">ngx_http_proxy_abort_request记录一条日志，标识异常结束与后端服务器的交互，然后函数返回。</td></tr></tbody></table><p>上表格中前面5个函数执行的先后次序如下图所示，由于在Client/Proxy/Server之间，一次请求/响应数据可以发送多次（下图中只画出一次就发送完毕的情况），所以下图中对应的函数也可能被执行多次，不过一般情况下，这5个函数执行的先后次序就是这样了。<br><img src="/images/2019-07-16_nginx_upstream_4.png" alt></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><blockquote><p>这些回调函数如何夹杂到nginx中被调用并不需要完全搞清楚，要写一个Upstream模块，我们只要实现上面提到的这7个函数即可，当然，可以看到最主要的也就是create_request、process_header和input_filter这三个回调，它们实现从HTTP协议到Nginx与后端服务器之间交互协议的来回转换，使得在用户看来，他访问的就是一台功能完整的Web服务器，而也许事实上，显示在他面前的数据来自Memcache或别的什么服务器。</p></blockquote><p>参考文献：</p><p><a href="http://www.lenky.info/ngx_book" target="_blank" rel="noopener">nginx核心讲解</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;1-相关配置&quot;&gt;&lt;a href=&quot;#1-相关配置&quot; class=&quot;headerlink&quot; title=&quot;1.相关配置&quot;&gt;&lt;/a&gt;1.相
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx缓存详解</title>
    <link href="https://weeweetan.github.io/2019/06/27/Nginx%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
    <id>https://weeweetan.github.io/2019/06/27/Nginx缓存详解/</id>
    <published>2019-06-27T12:56:57.000Z</published>
    <updated>2019-08-08T13:02:52.621Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="1-相关配置"><a href="#1-相关配置" class="headerlink" title="1. 相关配置"></a>1. 相关配置</h2><h3 id="1-1-配置指令"><a href="#1-1-配置指令" class="headerlink" title="1.1 配置指令"></a>1.1 配置指令</h3><blockquote><p>Nginx缓存由<strong>proxy_cache_path</strong>指令开启</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path D:\output levels=1:2 keys_zone=my_cache:10m max_size=2g inactive=60m use_temp_path=off;</span><br></pre></td></tr></table></figure><blockquote><p>对于每个参数的具体含义可以参考<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path" target="_blank" rel="noopener">nginx官方文档</a>，对于缓存文件名则需要proxy_cache_key指令指定</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_key $scheme$proxy_host$request_uri;</span><br></pre></td></tr></table></figure><blockquote><p>对于该指令的具体用法可以参考<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_key" target="_blank" rel="noopener">nginx官方文档</a></p></blockquote><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h2><blockquote><p>Nginx与文件缓存相关的代码在<strong>src/http/ngx_http_file_cache.c</strong></p></blockquote><h3 id="2-3-关键结构体"><a href="#2-3-关键结构体" class="headerlink" title="2.3 关键结构体"></a>2.3 关键结构体</h3><blockquote><p>与缓存相关的结构体有<em>ngx_path_t</em>、<em>ngx_http_file_cache_sh_t</em>、<em>ngx_http_file_cache_s</em> 、<em>ngx_http_file_cache_node_t</em>、 <em>ngx_http_file_cache_header_t</em>，来看看这几个结构体的定义</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_str_t</span>                  name;</span><br><span class="line">    <span class="keyword">size_t</span>                     len;</span><br><span class="line">    <span class="keyword">size_t</span>                     level[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    ngx_path_manager_pt        manager;  <span class="comment">//决定是否启用cache manager进程 </span></span><br><span class="line">    ngx_path_loader_pt         loader;  <span class="comment">//决定是否启用cache loader进程 </span></span><br><span class="line">    <span class="keyword">void</span>                      *data;</span><br><span class="line"></span><br><span class="line">    u_char                    *conf_file;   <span class="comment">//nginx配置文件路径</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                 line;</span><br><span class="line">&#125; <span class="keyword">ngx_path_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_rbtree_t</span>                     rbtree;  </span><br><span class="line">    <span class="keyword">ngx_rbtree_node_t</span>                sentinel;</span><br><span class="line">    <span class="keyword">ngx_queue_t</span>                      <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">ngx_atomic_t</span>                     cold;</span><br><span class="line">    <span class="keyword">ngx_atomic_t</span>                     loading;</span><br><span class="line">    <span class="keyword">off_t</span>                            size;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       count;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       watermark;</span><br><span class="line">&#125; <span class="keyword">ngx_http_file_cache_sh_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_http_file_cache_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_http_file_cache_sh_t</span>        *sh;</span><br><span class="line">    <span class="keyword">ngx_slab_pool_t</span>                 *shpool;      <span class="comment">/* shpool是用于管理共享内存的 slab allocator ，所有缓存节点占用空间都由它进行分配 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_path_t</span>                      *path;             <span class="comment">/* ngx_http_file_cache_set_slot中创建ngx_path_t空间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">off_t</span>                            max_size;</span><br><span class="line">    <span class="keyword">size_t</span>                           bsize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span>                           inactive;     <span class="comment">/* 触发LRU算法阈值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span>                           fail_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       files;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       loader_files;  <span class="comment">/* 阈值，当load的文件个数大于这个值之后，load进程会短暂的休眠(时间位loader_sleep) */</span></span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       last;</span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       loader_sleep;  <span class="comment">/* 阈值，执行一次缓存文件到共享内存后 , 进程的休眠时间 , 默认200 */</span></span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       loader_threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       manager_files;</span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       manager_sleep;</span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       manager_threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_shm_zone_t</span>                  *shm_zone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       use_temp_path;</span><br><span class="line">                                     <span class="comment">/* unsigned use_temp_path:1 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_rbtree_node_t</span>                node;     <span class="comment">/* 缓存查询树的节点 */</span></span><br><span class="line">    <span class="keyword">ngx_queue_t</span>                      <span class="built_in">queue</span>;     <span class="comment">/* LRU页面置换算法 队列中的节点 */</span></span><br><span class="line"></span><br><span class="line">    u_char                           key[NGX_HTTP_CACHE_KEY_LEN</span><br><span class="line">                                         - <span class="keyword">sizeof</span>(<span class="keyword">ngx_rbtree_key_t</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span>                         count:<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         uses:<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         valid_msec:<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         error:<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         exists:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         updating:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         deleting:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         purged:<span class="number">1</span>;</span><br><span class="line">                                     <span class="comment">/* 10 unused bits */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_file_uniq_t</span>                  uniq;</span><br><span class="line">    <span class="keyword">time_t</span>                           expire;</span><br><span class="line">    <span class="keyword">time_t</span>                           valid_sec;</span><br><span class="line">    <span class="keyword">size_t</span>                           body_start;</span><br><span class="line">    <span class="keyword">off_t</span>                            fs_size;</span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       lock_time;</span><br><span class="line">&#125; <span class="keyword">ngx_http_file_cache_node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在写缓存文件时会将这个结构体写入</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       version;</span><br><span class="line">    <span class="keyword">time_t</span>                           valid_sec;</span><br><span class="line">    <span class="keyword">time_t</span>                           updating_sec;</span><br><span class="line">    <span class="keyword">time_t</span>                           error_sec;</span><br><span class="line">    <span class="keyword">time_t</span>                           last_modified;</span><br><span class="line">    <span class="keyword">time_t</span>                           date;</span><br><span class="line">    <span class="keyword">uint32_t</span>                         crc32;</span><br><span class="line">    u_short                          valid_msec;</span><br><span class="line">    u_short                          header_start;         <span class="comment">/* 缓存文件中http头开始的偏移 */</span></span><br><span class="line">    u_short                          body_start;</span><br><span class="line">    u_char                           etag_len;</span><br><span class="line">    u_char                           etag[NGX_HTTP_CACHE_ETAG_LEN];</span><br><span class="line">    u_char                           vary_len;</span><br><span class="line">    u_char                           vary[NGX_HTTP_CACHE_VARY_LEN];</span><br><span class="line">    u_char                           variant[NGX_HTTP_CACHE_KEY_LEN];</span><br><span class="line">&#125; <span class="keyword">ngx_http_file_cache_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_http_cache_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_file_t</span>                       file;    <span class="comment">/* 缓存文件描述结构体 */</span></span><br><span class="line">    <span class="keyword">ngx_array_t</span>                      keys;    <span class="comment">/* 存放proxy_cache_key指令的值 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>                         crc32;</span><br><span class="line">    u_char                           key[NGX_HTTP_CACHE_KEY_LEN];     <span class="comment">/* 存放计算md5后的值 */</span></span><br><span class="line">    u_char                           main[NGX_HTTP_CACHE_KEY_LEN];    <span class="comment">/* 跟key相同 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_file_uniq_t</span>                  uniq;</span><br><span class="line">    <span class="keyword">time_t</span>                           valid_sec;</span><br><span class="line">    <span class="keyword">time_t</span>                           updating_sec;</span><br><span class="line">    <span class="keyword">time_t</span>                           error_sec;</span><br><span class="line">    <span class="keyword">time_t</span>                           last_modified;</span><br><span class="line">    <span class="keyword">time_t</span>                           date;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_str_t</span>                        etag;</span><br><span class="line">    <span class="keyword">ngx_str_t</span>                        vary;</span><br><span class="line">    u_char                           variant[NGX_HTTP_CACHE_KEY_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span>                           header_start;     <span class="comment">/* http头在缓存中的偏移位置 */</span></span><br><span class="line">    <span class="keyword">size_t</span>                           body_start;       <span class="comment">/* http响应体在缓存中的偏移位置 */</span></span><br><span class="line">    <span class="keyword">off_t</span>                            length;           <span class="comment">/* 缓存文件的大小，见ngx_http_file_cache_open */</span></span><br><span class="line">    <span class="keyword">off_t</span>                            fs_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       min_uses;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       error;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       valid_msec;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>                       vary_tag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_buf_t</span>                       *buf;      <span class="comment">/* 存储缓存文件头 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_http_file_cache_t</span>           *file_cache;</span><br><span class="line">    <span class="keyword">ngx_http_file_cache_node_t</span>      *node;      <span class="comment">//ngx_http_file_cache_exists中创建空间和赋值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_THREADS || NGX_COMPAT)</span></span><br><span class="line">    <span class="keyword">ngx_thread_task_t</span>               *thread_task;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       lock_timeout;</span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       lock_age;</span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       lock_time;</span><br><span class="line">    <span class="keyword">ngx_msec_t</span>                       wait_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ngx_event_t</span>                      wait_event;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span>                         lock:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         waiting:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span>                         updated:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         updating:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         exists:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         temp_file:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         purged:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         reading:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         secondary:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         background:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span>                         stale_updating:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>                         stale_error:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>部分字段含义见注释</p></blockquote><h3 id="2-1-缓存文件名生成"><a href="#2-1-缓存文件名生成" class="headerlink" title="2.1 缓存文件名生成"></a>2.1 缓存文件名生成</h3><blockquote><p>生成缓存文件名主要由<em>ngx_http_file_cache_name</em>实现，现在来看看源码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_file_cache_name(<span class="keyword">ngx_http_request_t</span> *r, <span class="keyword">ngx_path_t</span> *path)</span><br><span class="line">&#123;</span><br><span class="line">    u_char            *p;</span><br><span class="line">    <span class="keyword">ngx_http_cache_t</span>  *c;</span><br><span class="line"></span><br><span class="line">    c = r-&gt;cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;file.name.len) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;file.name.len = path-&gt;name.len + <span class="number">1</span> + path-&gt;len</span><br><span class="line">                       + <span class="number">2</span> * NGX_HTTP_CACHE_KEY_LEN;</span><br><span class="line"></span><br><span class="line">    c-&gt;file.name.data = ngx_pnalloc(r-&gt;pool, c-&gt;file.name.len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;file.name.data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_memcpy(c-&gt;file.name.data, path-&gt;name.data, path-&gt;name.len);</span><br><span class="line"></span><br><span class="line">    p = c-&gt;file.name.data + path-&gt;name.len + <span class="number">1</span> + path-&gt;len;</span><br><span class="line">    p = ngx_hex_dump(p, c-&gt;key, NGX_HTTP_CACHE_KEY_LEN);</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    ngx_create_hashed_filename(path, c-&gt;file.name.data, c-&gt;file.name.len);</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">"cache file: \"%s\""</span>, c-&gt;file.name.data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li>该函数首先判断当前缓存文件名是否已经生成成功，若已生成，则直接返回，代码如下：</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c-&gt;file.name.len) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>接下来计算缓存文件名长度，其中<em>path-&gt;name.len</em>为<em>proxy_cache_path</em>指令第一个参数，path-&gt;len为levels长度，比如level=1:2则path-&gt;len为5，包含两个/，代码如下：</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;file.name.len = path-&gt;name.len + <span class="number">1</span> + path-&gt;len</span><br><span class="line">                   + <span class="number">2</span> * NGX_HTTP_CACHE_KEY_LEN;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>接着为缓存文件名申请内存，代码如下：</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;file.name.data = ngx_pnalloc(r-&gt;pool, c-&gt;file.name.len + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>接着将<em>proxy_cache_path</em>指令设置的路径复制到<em>c-&gt;file.name.data</em>最前端，完成后<em>c-&gt;file.name.data</em>的值为:D:\output,代码如下：</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_memcpy(c-&gt;file.name.data, path-&gt;name.data, path-&gt;name.len);</span><br></pre></td></tr></table></figure><blockquote><ol start="5"><li>接着将p指向<em>c-&gt;file.name.data</em>偏移 <em>path-&gt;name.len + 1 + path-&gt;len</em>的位置处，这样做的目的是准备生成32位长的md5文件名，并预留level设置的目录</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = c-&gt;file.name.data + path-&gt;name.len + <span class="number">1</span> + path-&gt;len;</span><br><span class="line">p = ngx_hex_dump(p, c-&gt;key, NGX_HTTP_CACHE_KEY_LEN);</span><br><span class="line">*p = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这一步完成之后<em>c-&gt;file.name.data</em>的值为D:\output屯屯屯md5(proxy_cache_key)</p></blockquote><blockquote><ol start="6"><li>调用<em>ngx_create_hashed_filename</em>函数补全第5步预留的level目录</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_create_hashed_filename(path, c-&gt;file.name.data, c-&gt;file.name.len);</span><br></pre></td></tr></table></figure><h3 id="2-2-生成由levels参数指定的目录层级"><a href="#2-2-生成由levels参数指定的目录层级" class="headerlink" title="2.2 生成由levels参数指定的目录层级"></a>2.2 生成由levels参数指定的目录层级</h3><blockquote><p>生成由levels参数指定的目录层级由<em>ngx_create_hashed_filename</em>实现，现在来看看源码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_create_hashed_filename(<span class="keyword">ngx_path_t</span> *path, u_char *file, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span>      i, level;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>  n;</span><br><span class="line"></span><br><span class="line">    i = path-&gt;name.len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    file[path-&gt;name.len + path-&gt;len]  = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; NGX_MAX_PATH_LEVEL; n++) &#123;</span><br><span class="line">        level = path-&gt;level[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len -= level;</span><br><span class="line">        file[i - <span class="number">1</span>] = <span class="string">'/'</span>;</span><br><span class="line">        ngx_memcpy(&amp;file[i], &amp;file[len], level);</span><br><span class="line">        i += level + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>从上一节中我们知道参数file的值为D:\output屯屯屯md5(proxy_cache_key)，该函数首先用一个变量i保存path长度加1，这个设计非常巧妙，在后续中会使用到，代码如下：</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = path-&gt;name.len + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>接着修改file的值，在层级目录后添加一个反斜杠，修改后为D:\output屯屯屯/md5(proxy_cache_key)</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file[path-&gt;name.len + path-&gt;len]  = <span class="string">'/'</span>;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>接下来进入一个for循环，填充file中的屯屯屯，在第一次循环中首先获取levels=1：2中的1，接着用变量len减去变量level，接着在output后添加一个’/‘，然后将file中从len位置复制1个字符到<em>output/</em>后，修改i的值；第二次循环，首先获取levels=1：2中的2，接着用len减去2，接着在第一次缓存复制的字符后添加一个’/‘，然后把file从len处复制2个字符到上一步的’/‘后，修改i的值；第三次跳出循环，至此填充完成，代码如下：</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; NGX_MAX_PATH_LEVEL; n++) &#123;</span><br><span class="line">    level = path-&gt;level[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len -= level;</span><br><span class="line">    file[i - <span class="number">1</span>] = <span class="string">'/'</span>;</span><br><span class="line">    ngx_memcpy(&amp;file[i], &amp;file[len], level);</span><br><span class="line">    i += level + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;1-相关配置&quot;&gt;&lt;a href=&quot;#1-相关配置&quot; class=&quot;headerlink&quot; title=&quot;1. 相关配置&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反向代理详解</title>
    <link href="https://weeweetan.github.io/2019/06/17/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://weeweetan.github.io/2019/06/17/Nginx反向代理详解/</id>
    <published>2019-06-17T12:59:19.000Z</published>
    <updated>2019-07-28T13:50:36.966Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="1-相关配置"><a href="#1-相关配置" class="headerlink" title="1. 相关配置"></a>1. 相关配置</h2><blockquote><p>Nginx实现反向代理功能主要由proxy_pass、upstream指令实现，配置指令如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    upstream proxy &#123;</span><br><span class="line">        server 127.0.0.1:8080</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://proxy</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>具体配置可以参考<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a></p></blockquote><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h2><blockquote><p>Nginx实现反向代理功能的源码在src/http/modules/ngx_http_proxy_module.c，因为反向代理模块是一种upstream模块，所以还有一些基础代码在src/http/ngx_http_upstream.c中</p></blockquote><h3 id="2-1-入口函数"><a href="#2-1-入口函数" class="headerlink" title="2.1 入口函数"></a>2.1 入口函数</h3><blockquote><p>反向代理模块的入口函数是<strong>ngx_http_proxy_handler</strong>，我们看一下源码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_http_proxy_handler(<span class="keyword">ngx_http_request_t</span> *r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ngx_int_t</span>                    rc;</span><br><span class="line">    <span class="keyword">ngx_http_upstream_t</span>         *u;</span><br><span class="line">    <span class="keyword">ngx_http_proxy_ctx_t</span>        *ctx;</span><br><span class="line">    <span class="keyword">ngx_http_proxy_loc_conf_t</span>   *plcf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HTTP_CACHE)</span></span><br><span class="line">    <span class="keyword">ngx_http_proxy_main_conf_t</span>  *pmcf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_http_upstream_create(r) != NGX_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx = ngx_pcalloc(r-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_http_proxy_ctx_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_http_set_ctx(r, ctx, ngx_http_proxy_module);</span><br><span class="line"></span><br><span class="line">    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);</span><br><span class="line"></span><br><span class="line">    u = r-&gt;upstream;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (plcf-&gt;proxy_lengths == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ctx-&gt;vars = plcf-&gt;vars;</span><br><span class="line">        u-&gt;schema = plcf-&gt;vars.schema;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HTTP_SSL)</span></span><br><span class="line">        u-&gt;ssl = (plcf-&gt;upstream.ssl != <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_http_proxy_eval(r, ctx, plcf) != NGX_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u-&gt;output.tag = (<span class="keyword">ngx_buf_tag_t</span>) &amp;ngx_http_proxy_module;</span><br><span class="line"></span><br><span class="line">    u-&gt;conf = &amp;plcf-&gt;upstream;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HTTP_CACHE)</span></span><br><span class="line">    pmcf = ngx_http_get_module_main_conf(r, ngx_http_proxy_module);</span><br><span class="line"></span><br><span class="line">    u-&gt;caches = &amp;pmcf-&gt;caches;</span><br><span class="line">    u-&gt;create_key = ngx_http_proxy_create_key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    u-&gt;create_request = ngx_http_proxy_create_request;</span><br><span class="line">    u-&gt;reinit_request = ngx_http_proxy_reinit_request;</span><br><span class="line">    u-&gt;process_header = ngx_http_proxy_process_status_line;</span><br><span class="line">    u-&gt;abort_request = ngx_http_proxy_abort_request;</span><br><span class="line">    u-&gt;finalize_request = ngx_http_proxy_finalize_request;</span><br><span class="line">    r-&gt;state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (plcf-&gt;redirects) &#123;</span><br><span class="line">        u-&gt;rewrite_redirect = ngx_http_proxy_rewrite_redirect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (plcf-&gt;cookie_domains || plcf-&gt;cookie_paths) &#123;</span><br><span class="line">        u-&gt;rewrite_cookie = ngx_http_proxy_rewrite_cookie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u-&gt;buffering = plcf-&gt;upstream.buffering;</span><br><span class="line"></span><br><span class="line">    u-&gt;pipe = ngx_pcalloc(r-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_event_pipe_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;pipe == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u-&gt;pipe-&gt;input_filter = ngx_http_proxy_copy_filter;</span><br><span class="line">    u-&gt;pipe-&gt;input_ctx = r;</span><br><span class="line"></span><br><span class="line">    u-&gt;input_filter_init = ngx_http_proxy_input_filter_init;</span><br><span class="line">    u-&gt;input_filter = ngx_http_proxy_non_buffered_copy_filter;</span><br><span class="line">    u-&gt;input_filter_ctx = r;</span><br><span class="line"></span><br><span class="line">    u-&gt;accel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!plcf-&gt;upstream.request_buffering</span><br><span class="line">        &amp;&amp; plcf-&gt;body_values == <span class="literal">NULL</span> &amp;&amp; plcf-&gt;upstream.pass_request_body</span><br><span class="line">        &amp;&amp; (!r-&gt;headers_in.chunked</span><br><span class="line">            || plcf-&gt;http_version == NGX_HTTP_VERSION_11))</span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;request_body_no_buffering = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = ngx_http_read_client_request_body(r, ngx_http_upstream_init);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_DONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>该函数首先调用<em>ngx_http_upstream_create</em>函数从内存池中创建<em>ngx_http_upstream_s</em>结构体；</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ngx_http_upstream_create(r) != NGX_OK) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>接下来初始化<em>ngx_http_upstream_s</em>各成员，应当注意<em>ngx_http_upstream_s</em>结构体的几个回调函数，这个是实现反向代理的重要功能</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">u-&gt;create_request = ngx_http_proxy_create_request;</span><br><span class="line">u-&gt;reinit_request = ngx_http_proxy_reinit_request;</span><br><span class="line">u-&gt;process_header = ngx_http_proxy_process_status_line;</span><br><span class="line">u-&gt;abort_request = ngx_http_proxy_abort_request;</span><br><span class="line">u-&gt;finalize_request = ngx_http_proxy_finalize_request;</span><br><span class="line">r-&gt;state = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (plcf-&gt;redirects) &#123;</span><br><span class="line">    u-&gt;rewrite_redirect = ngx_http_proxy_rewrite_redirect;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (plcf-&gt;cookie_domains || plcf-&gt;cookie_paths) &#123;</span><br><span class="line">    u-&gt;rewrite_cookie = ngx_http_proxy_rewrite_cookie;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">u-&gt;buffering = plcf-&gt;upstream.buffering;</span><br><span class="line">    </span><br><span class="line">u-&gt;pipe = ngx_pcalloc(r-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_event_pipe_t</span>));</span><br><span class="line"><span class="keyword">if</span> (u-&gt;pipe == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">u-&gt;pipe-&gt;input_filter = ngx_http_proxy_copy_filter;</span><br><span class="line">u-&gt;pipe-&gt;input_ctx = r;</span><br><span class="line">    </span><br><span class="line">u-&gt;input_filter_init = ngx_http_proxy_input_filter_init;</span><br><span class="line">u-&gt;input_filter = ngx_http_proxy_non_buffered_copy_filter;</span><br><span class="line">u-&gt;input_filter_ctx = r;</span><br><span class="line">    </span><br><span class="line">u-&gt;accel = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;1-相关配置&quot;&gt;&lt;a href=&quot;#1-相关配置&quot; class=&quot;headerlink&quot; title=&quot;1. 相关配置&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx日志详解</title>
    <link href="https://weeweetan.github.io/2019/06/15/Nginx%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3/"/>
    <id>https://weeweetan.github.io/2019/06/15/Nginx日志详解/</id>
    <published>2019-06-15T12:59:00.000Z</published>
    <updated>2019-08-07T03:10:04.761Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="1-相关配置"><a href="#1-相关配置" class="headerlink" title="1. 相关配置"></a>1. 相关配置</h2><blockquote><p>Nginx日志系统由两条指令开启error_log、access_log</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error_log  logs/error.log debug;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>具体配置可以参考<a href="http://nginx.org/en/docs/ngx_core_module.html#error_log" target="_blank" rel="noopener">error_log</a>跟<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html#access_log" target="_blank" rel="noopener">access_log</a></p></blockquote><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h2><blockquote><p>首先来看一下关于日志的几个宏定义</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">filename:<span class="built_in">log</span>.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_C99_VARIADIC_MACROS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HAVE_VARIADIC_MACROS  1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_log_error(level, log, ...)                                        \</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">log</span>)-&gt;log_level &gt;= level) ngx_log_error_core(level, <span class="built_in">log</span>, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span><span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_log_debug(level, log, ...)                                        \</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">log</span>)-&gt;log_level &amp; level)                                             \</span><br><span class="line">        ngx_log_error_core(NGX_LOG_DEBUG, <span class="built_in">log</span>, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (NGX_HAVE_GCC_VARIADIC_MACROS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HAVE_VARIADIC_MACROS  1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_log_error(level, log, args...)                                    \</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">log</span>)-&gt;log_level &gt;= level) ngx_log_error_core(level, <span class="built_in">log</span>, args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span><span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_log_debug(level, log, args...)                                    \</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">log</span>)-&gt;log_level &amp; level)                                             \</span><br><span class="line">        ngx_log_error_core(NGX_LOG_DEBUG, <span class="built_in">log</span>, args)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* no variadic macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_HAVE_VARIADIC_MACROS  0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> ngx_cdecl <span class="title">ngx_log_error</span><span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span><span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> ngx_cdecl <span class="title">ngx_log_debug_core</span><span class="params">(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* variadic macros */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>从上面的定义可以看出，实现日志功能的核心在于<em>ngx_log_error_core</em>函数，接下来我们就来看看这个函数的实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_VARIADIC_MACROS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_log_error_core(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_log_error_core(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>, <span class="keyword">ngx_err_t</span> err,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list args)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_VARIADIC_MACROS)</span></span><br><span class="line">    va_list      args;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    u_char      *p, *last, *msg;</span><br><span class="line">    <span class="keyword">ssize_t</span>      n;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>   wrote_stderr, debug_connection;</span><br><span class="line">    u_char       errstr[NGX_MAX_ERROR_STR];</span><br><span class="line"></span><br><span class="line">    last = errstr + NGX_MAX_ERROR_STR;</span><br><span class="line"></span><br><span class="line">    p = ngx_cpymem(errstr, ngx_cached_err_log_time.data,</span><br><span class="line">                   ngx_cached_err_log_time.len);</span><br><span class="line"></span><br><span class="line">    p = ngx_slprintf(p, last, <span class="string">" [%V] "</span>, &amp;err_levels[level]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pid#tid */</span></span><br><span class="line">    p = ngx_slprintf(p, last, <span class="string">"%P#"</span> NGX_TID_T_FMT <span class="string">": "</span>,</span><br><span class="line">                    ngx_log_pid, ngx_log_tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;connection) &#123;</span><br><span class="line">        p = ngx_slprintf(p, last, <span class="string">"*%uA "</span>, <span class="built_in">log</span>-&gt;connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_VARIADIC_MACROS)</span></span><br><span class="line"></span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    p = ngx_vslprintf(p, last, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    p = ngx_vslprintf(p, last, fmt, args);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        p = ngx_log_errno(p, last, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (level != NGX_LOG_DEBUG &amp;&amp; <span class="built_in">log</span>-&gt;handler) &#123;</span><br><span class="line">        p = <span class="built_in">log</span>-&gt;handler(<span class="built_in">log</span>, p, last - p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p &gt; last - NGX_LINEFEED_SIZE) &#123;</span><br><span class="line">        p = last - NGX_LINEFEED_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_linefeed(p);</span><br><span class="line"></span><br><span class="line">    wrote_stderr = <span class="number">0</span>;</span><br><span class="line">    debug_connection = (<span class="built_in">log</span>-&gt;log_level &amp; NGX_LOG_DEBUG_CONNECTION) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">log</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;log_level &lt; level &amp;&amp; !debug_connection) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;writer) &#123;</span><br><span class="line">            <span class="built_in">log</span>-&gt;writer(<span class="built_in">log</span>, level, errstr, p - errstr);</span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ngx_time() == <span class="built_in">log</span>-&gt;disk_full_time) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * on FreeBSD writing to a full filesystem with enabled softupdates</span></span><br><span class="line"><span class="comment">             * may block process for much longer time than writing to non-full</span></span><br><span class="line"><span class="comment">             * filesystem, so we skip writing to a log for one second</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = ngx_write_fd(<span class="built_in">log</span>-&gt;file-&gt;fd, errstr, p - errstr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span> &amp;&amp; ngx_errno == NGX_ENOSPC) &#123;</span><br><span class="line">            <span class="built_in">log</span>-&gt;disk_full_time = ngx_time();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">log</span>-&gt;file-&gt;fd == ngx_stderr) &#123;</span><br><span class="line">            wrote_stderr = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    next:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log</span> = <span class="built_in">log</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ngx_use_stderr</span><br><span class="line">        || level &gt; NGX_LOG_WARN</span><br><span class="line">        || wrote_stderr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg -= (<span class="number">7</span> + err_levels[level].len + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>) ngx_sprintf(msg, <span class="string">"nginx: [%V] "</span>, &amp;err_levels[level]);</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>) ngx_write_console(ngx_stderr, msg, p - msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>从代码中可以看出，nginx的作者对于变参处理还是很细心的，把各种情况都考虑到了，在处理好变参定义之后，就开始初始化字符串格式：</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p = ngx_cpymem(errstr, ngx_cached_err_log_time.data,</span><br><span class="line">               ngx_cached_err_log_time.len);</span><br><span class="line"></span><br><span class="line">p = ngx_slprintf(p, last, &quot; [%V] &quot;, &amp;err_levels[level]);</span><br><span class="line"></span><br><span class="line">/* pid#tid */</span><br><span class="line">p = ngx_slprintf(p, last, &quot;%P#&quot; NGX_TID_T_FMT &quot;: &quot;,</span><br><span class="line">                ngx_log_pid, ngx_log_tid);</span><br><span class="line"></span><br><span class="line">if (log-&gt;connection) &#123;</span><br><span class="line">    p = ngx_slprintf(p, last, &quot;*%uA &quot;, log-&gt;connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>处理变参参数，将变参的值复制到日志串中：</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#if (NGX_HAVE_VARIADIC_MACROS)</span><br><span class="line"></span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    p = ngx_vslprintf(p, last, fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">    p = ngx_vslprintf(p, last, fmt, args);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>处理错误号跟换行：</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (err) &#123;</span><br><span class="line">    p = ngx_log_errno(p, last, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (level != NGX_LOG_DEBUG &amp;&amp; log-&gt;handler) &#123;</span><br><span class="line">    p = log-&gt;handler(log, p, last - p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (p &gt; last - NGX_LINEFEED_SIZE) &#123;</span><br><span class="line">    p = last - NGX_LINEFEED_SIZE;</span><br><span class="line">&#125;</span><br><span class="line">ngx_linefeed(p);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>最后就是将日志串输出到文件或者标准错误流</li></ol></blockquote><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;1-相关配置&quot;&gt;&lt;a href=&quot;#1-相关配置&quot; class=&quot;headerlink&quot; title=&quot;1. 相关配置&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx模块详解</title>
    <link href="https://weeweetan.github.io/2019/06/05/Nginx%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/"/>
    <id>https://weeweetan.github.io/2019/06/05/Nginx模块详解/</id>
    <published>2019-06-05T12:58:43.000Z</published>
    <updated>2019-07-20T03:15:19.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="1-Nginx模块综述"><a href="#1-Nginx模块综述" class="headerlink" title="1. Nginx模块综述"></a>1. Nginx模块综述</h2><blockquote><p>nginx的模块非常之多，可以认为所有代码都是以模块的形式组织，这包括核心模块和功能模块，针对不同的应用场合，并非所有的功能模块都要被用到，附录A给出的是默认configure（即简单的http服务器应用）下被连接的模块，这里虽说是模块连接，但nginx不会像apache或lighttpd那样在编译时生成so动态库而在程序执行时再进行动态加载，nginx模块源文件会在生成nginx时就直接被编译到其二进制执行文件中，所以如果要选用不同的功能模块，必须对nginx做重新配置和编译。对于功能模块的选择，如果要修改默认值，需要在进行configure时进行指定，比如新增http_flv功能模块（默认是没有这个功能的，各个选项的默认值可以在文件auto/options内看到）：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.2.0]# ./configure --with-http_flv_module</span><br></pre></td></tr></table></figure><blockquote><p>执行后，生成的objs/ngx_modules.c文件内就包含有对ngx_http_flv_module模块的引用了，要再去掉http_flv功能模块，则需要重新configure，即不带–with-http_flv_module配置后再编译生成新的nginx执行程序。通过执行./configure –help，我们可以看到更多的配置选项。<br>虽然Nginx模块有很多，并且每个模块实现的功能各不相同，但是根据模块的功能性质，可以将它们分为四个类别：<br>1， handlers：处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。<br>2， filters：对handlers产生的响应内容做各种过滤处理（即是增删改），比如模块ngx_http_not_modified_filter_module，对待响应内容进行过滤检测，如果通过时间戳判断出前后两次请求的响应内容没有发生任何改变，那么可以直接响应 “304 Not Modified”状态标识，让客户端使用缓存即可，而原本待发送的响应内容将被清除掉。<br>3， upstream：如果存在后端真实服务器，nginx可利用upstream模块充当反向代理（Proxy）的角色，对客户端发起的请求只负责进行转发（当然也包括后端真实服务器响应的回转），比如ngx_http_proxy_module就为标准的代理模块。<br>4， load-balance：在nginx充当中间代理时，由于后端真实服务器往往多于一个，对于某一次客户端的请求，如何选择对应的后端真实服务器来进行处理，这就有类似于ngx_http_upstream_ip_hash_module这样的模块来实现不同的负载均衡算法（Load Balance）。<br>对于这几类模块，我们马上会分别进行详细介绍并分析各自典型代表模块，不过在此之前先从nginx模块源码上来进行直观认识。前面讲过nginx的所有代码都是以模块形式进行组织，而封装nginx模块的结构体为ngx_module_s，定义如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Filename : ngx_conf_file.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            ctx_index; <span class="comment">//当前模块在同类模块中的序号</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            index;<span class="comment">//当前模块在所有模块中的序号</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            version;<span class="comment">//当前模块版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                 *ctx;<span class="comment">//指向当前模块特有的数据</span></span><br><span class="line">    <span class="keyword">ngx_command_t</span>        *commands; <span class="comment">//指向当前模块配置项解析数组</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            type;<span class="comment">//模块类型</span></span><br><span class="line"><span class="comment">//以下为模块回调函数，回调时机可根据函数名看出</span></span><br><span class="line">    <span class="keyword">ngx_int_t</span>           (*init_master)(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>);</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line">Filename : ngx_core.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span>      <span class="title">ngx_module_t</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>结构体ngx_module_s值得关注的几个字段分别为ctx、commands、type，其中commands字段表示当前模块可以解析的配置项目，这在配置文件解析一章做过详细描述；表示模块类型的type值只有5种可能的值，而同一类型模块的ctx指向的数据类型也相同：</p></blockquote><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">type值</th><th style="text-align:center">ctx指向数据类型</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NGX_CORE_MODULE</td><td style="text-align:center">ngx_core_module_t</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">NGX_EVENT_MODULE</td><td style="text-align:center">ngx_event_module_t</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">NGX_CONF_MODULE</td><td style="text-align:center">NULL</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">NGX_HTTP_MODULE</td><td style="text-align:center">ngx_http_module_t</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">NGX_MAIL_MODULE</td><td style="text-align:center">ngx_mail_module_t</td></tr></tbody></table><blockquote><p>上表中第三列里的数据类型非常重要，它们的字段基本都是一些回调函数，这些回调函数会在其模块对应的配置文件解析过程前/中/后会适时的被调用，做一些内存准备、初始化、配置值检查、初始值填充与合并、回调函数挂载等初始工作，以ngx_http_core_module模块为例，该模块type类型为NGX_HTTP_MODULE，ctx指向的ngx_http_module_t结构体变量ngx_http_core_module_ctx：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Filename : ngx_http_core_module.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span>  ngx_http_core_module_ctx = &#123;</span><br><span class="line">    ngx_http_core_preconfiguration,        <span class="comment">/* preconfiguration */</span></span><br><span class="line">    <span class="literal">NULL</span>,                                  <span class="comment">/* postconfiguration */</span></span><br><span class="line"></span><br><span class="line">    ngx_http_core_create_main_conf,        <span class="comment">/* create main configuration */</span></span><br><span class="line">    ngx_http_core_init_main_conf,          <span class="comment">/* init main configuration */</span></span><br><span class="line"></span><br><span class="line">    ngx_http_core_create_srv_conf,         <span class="comment">/* create server configuration */</span></span><br><span class="line">    ngx_http_core_merge_srv_conf,          <span class="comment">/* merge server configuration */</span></span><br><span class="line"></span><br><span class="line">    ngx_http_core_create_loc_conf,         <span class="comment">/* create location configuration */</span></span><br><span class="line">    ngx_http_core_merge_loc_conf           <span class="comment">/* merge location configuration */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>根据上面代码注释，可以很明显的看出各个回调函数的回调时机，比如函数<em>ngx_http_core_preconfiguration()</em>将在进行http块配置解析前被调用，所以在<em>ngx_http_block()</em>函数里可以看到这样的代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Filename : ngx_http.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *</span><br><span class="line">ngx_http_block(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span><br><span class="line">…</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;preconfiguration) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;preconfiguration(cf) != NGX_OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">…</span><br><span class="line">    rv = ngx_conf_parse(cf, <span class="literal">NULL</span>);</span><br><span class="line">…</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;postconfiguration) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;postconfiguration(cf) != NGX_OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">…</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>至于这些回调函数内的具体逻辑，如前所述一般是一些初始或默认值填充工作，但也有回调函数挂载的设置，比如ngx_http_static_module模块的postconfiguration字段回调函数ngx_http_static_init()就是将自己的处理函数ngx_http_static_handler()挂载在http处理状态机上，但总体来看这毕竟都只是一些简单的初始准备工作，值得一提的还有ngx_http_core_create_main_conf、ngx_http_core_create_srv_conf、ngx_http_core_create_loc_conf这三个回调函数用来创建存储位于http块、server块、location块配置项的内存。</p></blockquote><p>参考文献：</p><p><a href="http://www.lenky.info/ngx_book" target="_blank" rel="noopener">nginx核心讲解</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;1-Nginx模块综述&quot;&gt;&lt;a href=&quot;#1-Nginx模块综述&quot; class=&quot;headerlink&quot; title=&quot;1. Ng
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Dos常用命令</title>
    <link href="https://weeweetan.github.io/2019/05/26/Dos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://weeweetan.github.io/2019/05/26/Dos常用命令/</id>
    <published>2019-05-26T05:56:27.000Z</published>
    <updated>2019-05-26T06:04:11.118Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h2><blockquote><p>sc命令可用于卸载windows服务，如下所示：</p></blockquote><pre><code>sc delete serv</code></pre><blockquote><p>其中serv为服务名，可在服务中查看</p></blockquote><h2 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h2><blockquote><p>xcopy命令用于Dos下复制文件夹及子文件夹，如下所示：</p></blockquote><pre><code>xcopy d:\abc\aaa\*.* c:\windows\system /s</code></pre><blockquote><p>其中第一个参数是源位置，第二个参数是目标位置<br>/s：复制目录和子目录，除了空的。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;sc&quot;&gt;&lt;a href=&quot;#sc&quot; class=&quot;headerlink&quot; title=&quot;sc&quot;&gt;&lt;/a&gt;sc&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Dos" scheme="https://weeweetan.github.io/tags/Dos/"/>
    
  </entry>
  
  <entry>
    <title>中国菜翻译方法</title>
    <link href="https://weeweetan.github.io/2019/05/18/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E7%BF%BB%E8%AF%91%E6%96%B9%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2019/05/18/中国菜翻译方法/</id>
    <published>2019-05-18T02:27:42.000Z</published>
    <updated>2019-05-18T02:32:50.166Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="以主料为主"><a href="#以主料为主" class="headerlink" title="以主料为主"></a>以主料为主</h2><blockquote><p>配料或配汁为辅的翻译原则<br>菜肴的主料和配料</p><p>主料（名称/形状）+ with + 配料</p><p>如：松仁香菇 Chinese Mushrooms with Pine Nuts</p><p>菜肴的主料和配汁</p><p>主料 + with / in + 汤汁（Sauce）</p><p>如：冰梅凉瓜 Bitter Melon in Plum Sauc</p></blockquote><h2 id="以烹制方法为主"><a href="#以烹制方法为主" class="headerlink" title="以烹制方法为主"></a>以烹制方法为主</h2><blockquote><p>原料为辅的翻译原则<br>菜肴的做法和主料</p><p>做法（动词过去分词）+ 主料（名称/形状）</p><p>如：拌双耳 Tossed Black and White Fungus</p><p>菜肴的做法、主料和汤汁</p><p>做法(动词过去分词) + 主料（名称/形状）+ with / in + 汤汁</p><p>如：京酱肉丝 Sautéed Shredded Pork in Sweet Bean Sauce</p></blockquote><h2 id="以形状、口感为主"><a href="#以形状、口感为主" class="headerlink" title="以形状、口感为主"></a>以形状、口感为主</h2><blockquote><p>原料为辅的翻译原则<br>菜肴形状或口感以及主配料</p><p>形状/口感 + 主料</p><p>如：玉兔馒头 Rabbit-Shaped Mantou<br>菜肴的做法、形状或口感、做法以及主配料</p><p>做法（动词过去分词）+ 形状/口感 + 主料 + 配料</p><p>如： 小炒黑山羊 Sautéed Sliced Lamb with Pepper and Parsley</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;以主料为主&quot;&gt;&lt;a href=&quot;#以主料为主&quot; class=&quot;headerlink&quot; title=&quot;以主料为主&quot;&gt;&lt;/a&gt;以主料为主&lt;
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="翻译" scheme="https://weeweetan.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>C语言编程常见错误</title>
    <link href="https://weeweetan.github.io/2019/05/17/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <id>https://weeweetan.github.io/2019/05/17/C语言编程常见错误/</id>
    <published>2019-05-17T15:21:03.000Z</published>
    <updated>2019-08-07T08:41:59.486Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="1-使用close函数出现bad-file-descriptor错误"><a href="#1-使用close函数出现bad-file-descriptor错误" class="headerlink" title="1. 使用close函数出现bad file descriptor错误"></a>1. 使用close函数出现bad file descriptor错误</h2><blockquote><p>出现这种错误一般是两次close导致，仔细检查代码，调用close关闭文件描述符后，应该将文件描述符置为0，避免重复调用close，切记切记。</p></blockquote><h2 id="2-守护程序闪退问题"><a href="#2-守护程序闪退问题" class="headerlink" title="2. 守护程序闪退问题"></a>2. 守护程序闪退问题</h2><blockquote><p>出现这个问题一般是两次释放同一块内存，仔细检查释放内存与指针赋值相关代码，释放内存后，应将指针置为NULL，避免重复调用close，切记切记。</p></blockquote><h2 id="3-四字节对齐"><a href="#3-四字节对齐" class="headerlink" title="3. 四字节对齐"></a>3. 四字节对齐</h2><h3 id="4-什么是四字节对齐"><a href="#4-什么是四字节对齐" class="headerlink" title="4. 什么是四字节对齐"></a>4. 什么是四字节对齐</h3><blockquote><p>现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。</p></blockquote><h3 id="4-1-四字节对齐作用"><a href="#4-1-四字节对齐作用" class="headerlink" title="4.1 四字节对齐作用"></a>4.1 四字节对齐作用</h3><blockquote><p>定义结构体成员时应当注意四字节对齐，保证内存利用最大化。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。</p></blockquote><h2 id="5-柔性数组"><a href="#5-柔性数组" class="headerlink" title="5. 柔性数组"></a>5. 柔性数组</h2><blockquote><p>定义结构体时，最后一个成员定义为</p></blockquote><pre><code>struct test {    int a;    char b[0];}  </code></pre><blockquote><p>b[0]就称为柔性数组，使用</p></blockquote><pre><code>sizeof(struct test);</code></pre><blockquote><p>返回值为4，即b[0]不占用内存空间。</p></blockquote><h2 id="6-数字转字符"><a href="#6-数字转字符" class="headerlink" title="6. 数字转字符"></a>6. 数字转字符</h2><blockquote><p>C语言书籍上可能出现过如下代码将数字转为字符</p></blockquote><pre><code>int a = 0;char b = a + &apos;0&apos;;</code></pre><blockquote><p>这个操作有局限性，当a的值超过9的时候就会得到你意向不到的结果，</p></blockquote><pre><code>int a = 10;char b = a + &apos;0&apos;;     </code></pre><blockquote><p>这个时候字符b的值为’:’</p></blockquote><h2 id="7-fork函数注意事项"><a href="#7-fork函数注意事项" class="headerlink" title="7. fork函数注意事项"></a>7. fork函数注意事项</h2><blockquote><p>fork函数用来产生一个子进程，而且会复制父进程的资源（包括打开的文件描述符，变量等），无论是在子进程还是父进程对打开的文件描述符都需要谨慎对待，调用close函数关闭文件描述符可能不会报错，但是删除文件的时候就会出问题。</p></blockquote><h2 id="8-变参宏定义"><a href="#8-变参宏定义" class="headerlink" title="8. 变参宏定义"></a>8. 变参宏定义</h2><blockquote><p>C99定义了一种变参宏定义</p></blockquote><pre><code>#define LOG(format, ...) fprintf(stdout, format, __VA_ARGS__) </code></pre><blockquote><p>…表示可变参数列表，<strong>VA_ARGS</strong>在预处理中，会被实际的参数集（实参列表）所替换。<br>同时gcc还支持带可以变参数名的方式（<strong>注意：VC不支持,即在vs环境下无法使用</strong>）：</p></blockquote><pre><code>#define LOG(format, args...) fprintf(stdout, format, args)  </code></pre><blockquote><p>同样，args在预处理过程中，会被实际的参数集所替换。其用法和上面的方式一样，只是参数的符号有变。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;1-使用close函数出现bad-file-descriptor错误&quot;&gt;&lt;a href=&quot;#1-使用close函数出现bad-file
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://weeweetan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记</title>
    <link href="https://weeweetan.github.io/2019/05/08/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://weeweetan.github.io/2019/05/08/Nginx学习笔记/</id>
    <published>2019-05-08T02:49:55.000Z</published>
    <updated>2019-07-11T03:06:28.483Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="1-编译步骤"><a href="#1-编译步骤" class="headerlink" title="1. 编译步骤"></a>1. 编译步骤</h2><h3 id="1-1-configure原理"><a href="#1-1-configure原理" class="headerlink" title="1.1 configure原理"></a>1.1 configure原理</h3><blockquote><p>configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。</p></blockquote><h3 id="1-2-auto脚本"><a href="#1-2-auto脚本" class="headerlink" title="1.2 auto脚本"></a>1.2 auto脚本</h3><blockquote><p>auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：<br><img src="/images/2019-05-13_nginx.png" alt><br>上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。</p></blockquote><h4 id="1-2-1-auto-options脚本"><a href="#1-2-1-auto-options脚本" class="headerlink" title="1.2.1 auto/options脚本"></a>1.2.1 auto/options脚本</h4><blockquote><p>auto/options主是处理用户输入的configure选项，以及输出帮助信息等。auto/options的目的主要是处理用户选项，并由选项生成一些全局变量的值，这些值在其它文件中会用到。该文件也会输出configure的帮助信息。<br>应当注意如下代码</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for option</span><br><span class="line">do</span><br><span class="line">    opt="$opt `echo $option | sed -e \"s/\(--[^=]*=\)\(.* .*\)/\1'\2'/\"`"</span><br></pre></td></tr></table></figure><blockquote><p>for后面可以省略要遍历的变量,这时,表示在遍历$@,即用户传入的所有变量组合</p></blockquote><h4 id="1-2-2-auto-init脚本"><a href="#1-2-2-auto-init脚本" class="headerlink" title="1.2.2 auto/init脚本"></a>1.2.2 auto/init脚本</h4><blockquote><blockquote><p>该文件的目录在于初始化一些临时文件的路径，检查echo的兼容性，并创建最原始的Makefile文件。</p><footer><strong>淘宝</strong><cite><a href="http://tengine.taobao.org/book/chapter_09.html#auto" target="_blank" rel="noopener">Nginx开发从入门到精通</a></cite></footer></blockquote><p>注意：这里生成的Makefile文件与configure文件在同一目录，真正执行编译指令的Makefile在objs目录下</p></blockquote><h4 id="1-2-3-auto-sources脚本"><a href="#1-2-3-auto-sources脚本" class="headerlink" title="1.2.3 auto/sources脚本"></a>1.2.3 auto/sources脚本</h4><blockquote><blockquote><p>该文件从文件名中就可以看出，它的主要功能是跟源文件相关的。它的主要作用是定义不同功能或系统所需要的文件的变量。根据功能，分为CORE/REGEX/EVENT/UNIX/FREEBSD/HTTP等。每一个功能将会由四个变量组成，”_MODULES”表示此功能相关的模块，最终会输出到ngx_modules.c文件中，即动态生成需要编译到nginx中的模块；”INCS”表示此功能依赖的源码目录，查找头文件的时候会用到，在编译选项中，会出现在”-I”中；”DEPS”显示指明在Makefile中需要依赖的文件名，即编译时，需要检查这些文件的更新时间；”SRCS”表示需要此功能编译需要的源文件。</p><footer><strong>淘宝</strong><cite><a href="http://tengine.taobao.org/book/chapter_09.html#auto" target="_blank" rel="noopener">Nginx开发从入门到精通</a></cite></footer></blockquote><p>根据上面的描述，所以如果需要对nginx进行功能扩展，添加相应的C文件后，修改这个脚本就可以将自己的功能编译进nginx。</p></blockquote><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h2><h3 id="2-1-模块相关"><a href="#2-1-模块相关" class="headerlink" title="2.1 模块相关"></a>2.1 模块相关</h3><blockquote><p>在<em>ngx_module.h</em>中引用了两个至关重要的外部变量</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">ngx_module_t</span>  *ngx_modules[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>          *ngx_module_names[];</span><br></pre></td></tr></table></figure><blockquote><p><em>ngx_modules</em>跟<em>ngx_module_names</em>定义在<em>ngx_modules.c</em>中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用<em>ngx_cycle_modules</em>函数，原型如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ngx_int_t</span> ngx_cycle_modules(<span class="keyword">ngx_cycle_t</span> *cycle)</span><br></pre></td></tr></table></figure><blockquote><p>此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下：</p></blockquote><pre><code>main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules</code></pre><h3 id="2-2-数据结构"><a href="#2-2-数据结构" class="headerlink" title="2.2 数据结构"></a>2.2 数据结构</h3><h4 id="2-2-1-ngx-str-t"><a href="#2-2-1-ngx-str-t" class="headerlink" title="2.2.1 ngx_str_t"></a>2.2.1 ngx_str_t</h4><blockquote><p>Nginx开发从入门到精通已经对<a href="http://tengine.taobao.org/book/chapter_02.html#ngx-str-t-100" target="_blank" rel="noopener">ngx_str_t</a>的定义以及相关api进行了非常详细的讲解，以下为定义：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span>      len;</span><br><span class="line">    u_char     *data;</span><br><span class="line">&#125; <span class="keyword">ngx_str_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ol><li>不要试图复制char *到data所指向的内存，可能导致coredump</li><li>初始化相关api都是基于常量字符串，char *类型慎用</li><li>如果非要复制char *到data所指向的内存，一定先分配内存</li></ol></blockquote><h4 id="2-2-2-ngx-array-t"><a href="#2-2-2-ngx-array-t" class="headerlink" title="2.2.2 ngx_array_t"></a>2.2.2 ngx_array_t</h4><blockquote><p>Nginx开发从入门到精通已经对<a href="http://tengine.taobao.org/book/chapter_02.html#ngx-array-t-100" target="_blank" rel="noopener">ngx_array_t</a>的定义以及相关api进行了非常详细的讲解，以下为定义：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_array_s</span>       <span class="title">ngx_array_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_array_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *elts;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>   nelts;</span><br><span class="line">    <span class="keyword">size_t</span>       size;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>   nalloc;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项</p><ol><li>如果使用ngx_array_t作为字符串容器，在调用ngx_array_create时，使用字符串长度最后一个参数</li><li>ngx_array_push返回第n个元素首地址，要注意指针运算</li></ol></blockquote><h2 id="3-handler模块的编写步骤"><a href="#3-handler模块的编写步骤" class="headerlink" title="3. handler模块的编写步骤"></a>3. handler模块的编写步骤</h2><blockquote><ol><li>编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量：</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_command_t</span> ngx_http_module_name_commands[] = &#123;&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span> ngx_http_module_name_module_ctx = &#123;&#125;;</span><br><span class="line"><span class="keyword">ngx_module_t</span> ngx_http_module_name_module = &#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数：</li></ol></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)；</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数：</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_module_name_handler</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-1-模块编译"><a href="#3-1-模块编译" class="headerlink" title="3.1 模块编译"></a>3.1 模块编译</h3><blockquote><blockquote><p>对于开发一个模块，我们是需要把这个模块的C代码组织到一个目录里，同时需要编写一个config文件。这个config文件的内容就是告诉nginx的编译脚本，该如何进行编译。</p><footer><strong>淘宝</strong><cite><a href="http://tengine.taobao.org/book/chapter_03.html#config" target="_blank" rel="noopener">Nginx开发从入门到精通</a></cite></footer></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">ngx_addon_name=ngx_http_hello_module</span><br><span class="line">HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_hello_module&quot;</span><br><span class="line">NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_hello_module.c&quot;</span><br></pre></td></tr></table></figure><blockquote><p>执行如下命令进行编译</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure –add-module=/home/jizhao/open_source/book_module        </span><br></pre></td></tr></table></figure><h2 id="4-日志系统"><a href="#4-日志系统" class="headerlink" title="4. 日志系统"></a>4. 日志系统</h2><blockquote><p>Nginx的日志系统分为两个部分，一个是Nginx核心的错误日志（包括debug日志），一个是各模块的访问日志，整个Nginx框架中主要以核心的错误日志为主，各模块的访问日志根据模块调用顺序使用，下面分别介绍两种日志系统。</p></blockquote><h3 id="4-1-错误日志"><a href="#4-1-错误日志" class="headerlink" title="4.1 错误日志"></a>4.1 错误日志</h3><blockquote><p>关于错误日志的配置指令可以参考<a href="http://nginx.org/en/docs/ngx_core_module.html#error_log" target="_blank" rel="noopener">error_log</a>，分析Nginx源码可以发现，源码中多处使用ngx_log_debug0，ngx_log_debug1等类似的宏定义，启用这些宏定义需要在configure的时候执行–with-debug。<br>错误日志初始化分为两个阶段，一个是ngx_log_init函数中初始化日志对象，另外一个就是在解析配置文件的时候会新建一个日志对象。</p></blockquote><h3 id="4-2-访问日志"><a href="#4-2-访问日志" class="headerlink" title="4.2 访问日志"></a>4.2 访问日志</h3><blockquote><p>目前实现了访问日志的官方模块有http模块，stream模块，其中http模块的配置指令可以参考<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">ngx_http_log_module</a>。http模块的日志系统是以http第三方模块的形式存在，所以编写的时候遵循第3节的规则，Nginx将HTTP请求划分为11个阶段，访问日志是最后一个阶段，所以访问日志在HTTP请求完成时写入。</p></blockquote><h2 id="5-upstream机制"><a href="#5-upstream机制" class="headerlink" title="5. upstream机制"></a>5. upstream机制</h2><blockquote><p>upstream机制使得nginx能够作为代理服务器，或者负载均衡服务器，将来自客户端的请求转发到上游，并将上游响应转发到客户端。参考配置如下</p></blockquote><pre><code>#位于http上下文中upstream local {    server 127.0.0.1:8080 weight=5;    server 127.0.0.1:80 weight=2;}</code></pre><h2 id="6-反向代理"><a href="#6-反向代理" class="headerlink" title="6. 反向代理"></a>6. 反向代理</h2><blockquote><p>nginx反向代理实际上是一个upstream模块，实现upstream机制的几个回调函数。参考配置如下：</p></blockquote><pre><code>location / {    proxy_pass http://local}</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>此博文只粗略记录笔记，在后续会写详细的博客对nginx进行分析</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;1-编译步骤&quot;&gt;&lt;a href=&quot;#1-编译步骤&quot; class=&quot;headerlink&quot; title=&quot;1. 编译步骤&quot;&gt;&lt;/a&gt;1.
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>libxml2使用心得</title>
    <link href="https://weeweetan.github.io/2019/05/04/libxml2%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2019/05/04/libxml2使用心得/</id>
    <published>2019-05-04T14:21:35.000Z</published>
    <updated>2019-05-15T07:04:26.805Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考<a href="http://www.blogjava.net/wxb_nudt/archive/2007/11/18/161340.html" target="_blank" rel="noopener">C++的XML编程经验――LIBXML2库使用指南</a>，这篇博文讲得很详细，我在这里只是做出一点补充。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。</p></blockquote><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><blockquote><p>我使用GLib2的<em>g_locale_from_utf8</em>将内容转换为本地程序默认的编码格式，在写入xml内容时使用<em>g_locale_to_utf8</em>将内容转换为UTF-8.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="libxml" scheme="https://weeweetan.github.io/categories/libxml/"/>
    
    
      <category term="libxml" scheme="https://weeweetan.github.io/tags/libxml/"/>
    
  </entry>
  
  <entry>
    <title>GLib使用心得</title>
    <link href="https://weeweetan.github.io/2019/04/28/GLib%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2019/04/28/GLib使用心得/</id>
    <published>2019-04-28T05:51:59.000Z</published>
    <updated>2019-07-11T03:11:05.932Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>关于GLib的介绍这里就不赘述了，具体API介绍可以去<a href="https://developer.gnome.org/glib/" target="_blank" rel="noopener">GLib API Reference</a>查阅，这里只是记录一下使用相关API所遇到的一些坑。</p></blockquote><h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><h3 id="字符串相关API"><a href="#字符串相关API" class="headerlink" title="字符串相关API"></a>字符串相关API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function">GString *<span class="title">g_string_new</span><span class="params">(<span class="keyword">const</span> gchar *init)</span></span>;</span><br><span class="line"><span class="function">GString *<span class="title">g_string_append</span><span class="params">(GString *<span class="built_in">string</span>, <span class="keyword">const</span> gchar *val)</span></span>;</span><br><span class="line"><span class="function">GString *<span class="title">g_string_prepend</span><span class="params">(GString *<span class="built_in">string</span>, <span class="keyword">const</span> gchar *val)</span></span>;</span><br><span class="line"><span class="function">gchar *<span class="title">g_string_free</span><span class="params">(GString *<span class="built_in">string</span>, gboolean free_segment)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。<strong>注意</strong> g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。<br><em>g_string_append</em>跟<em>g_string_prepend</em>都是直接在原字符串上操作，这点要切记。</p></blockquote><h3 id="字符转换相关API"><a href="#字符转换相关API" class="headerlink" title="字符转换相关API"></a>字符转换相关API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gchar *<span class="title">g_filename_display_basename</span><span class="params">(<span class="keyword">const</span> gchar *filename)</span></span>;</span><br><span class="line"><span class="function">gchar *<span class="title">g_locale_from_utf8</span><span class="params">(<span class="keyword">const</span> gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)</span></span>;</span><br><span class="line"><span class="function">gchar *<span class="title">g_locale_to_utf8</span><span class="params">(<span class="keyword">const</span> gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码<br>g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件<br>g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8<br>下面看个例子, 比如我们有个含中文的文件名 <em>/data/test/哈哈.txt</em>如果想获得 <em>哈哈.txt</em>，则必须首先使用 <em>g_locale_to_utf8</em>函数转换一次, 然后再去获取basename</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GString *<span class="built_in">string</span> = g_string_new(<span class="string">"/data/test/哈哈.txt"</span>);</span><br><span class="line">gchar *str = g_locale_to_utf8(<span class="built_in">string</span>-&gt;str, <span class="built_in">string</span>-&gt;len, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">gchar *basename = g_filename_display_basename(str);</span><br></pre></td></tr></table></figure><blockquote><p>如果想使用GString <em>类型保存basename，则必须重新申请内存块<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GString *basename_string = g_string_new(basename); </span><br></pre></td></tr></table></figure><br>千万别像下面这样做<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GString *<span class="built_in">string</span> = g_string_new(<span class="string">"/data/test/哈哈.txt"</span>);</span><br><span class="line"><span class="built_in">string</span>-&gt;str = g_locale_to_utf8(<span class="built_in">string</span>-&gt;str, <span class="built_in">string</span>-&gt;len, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br></pre></td></tr></table></figure><br>如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，</em>g_locale_from_utf8<em> 同理<br><strong>注意</strong> </em>g_locale_to_utf8<em>返回的char </em>需要手动释放内存</p></blockquote><h3 id="解析key-value文件API"><a href="#解析key-value文件API" class="headerlink" title="解析key-value文件API"></a>解析key-value文件API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GKeyFile *<span class="title">g_key_file_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">gboolean <span class="title">g_key_file_load_from_file</span><span class="params">(GKeyFile *key_file, <span class="keyword">const</span> gchar *file, GKeyFileFlags flags, GError **error)</span></span>;</span><br><span class="line"><span class="function">gint <span class="title">g_key_file_get_integer</span><span class="params">(GKeyFile *key_file, <span class="keyword">const</span> gchar *group_name,  <span class="keyword">const</span> gchar *key, GError **error)</span></span>;</span><br><span class="line"><span class="function">gchar *<span class="title">g_key_file_get_string</span><span class="params">(GKeyFile *key_file, <span class="keyword">const</span> gchar *group_name, <span class="keyword">const</span> gchar *key, GError **error)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_key_file_free</span><span class="params">(GKeyFile *key_file)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>这几个API很好理解,用来解析具有键值对特征的文件,<em>g_key_file_new</em>跟<em>g_key_file_free</em>配套使用;<br>g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="GLib" scheme="https://weeweetan.github.io/categories/GLib/"/>
    
    
      <category term="GLib" scheme="https://weeweetan.github.io/tags/GLib/"/>
    
  </entry>
  
  <entry>
    <title>调用glib库出现0xc000007b解决办法</title>
    <link href="https://weeweetan.github.io/2019/04/18/%E8%B0%83%E7%94%A8glib%E5%BA%93%E5%87%BA%E7%8E%B00xc000007b%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/</id>
    <published>2019-04-18T14:47:29.000Z</published>
    <updated>2019-05-18T01:22:38.363Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示：<br><img src="/images/2019-04-18_glib_1.png" alt></p></blockquote><blockquote><p>网上的解决办法都试过，没能解决问题。</p></blockquote><h2 id="出现转机"><a href="#出现转机" class="headerlink" title="出现转机"></a>出现转机</h2><blockquote><p>出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。</p></blockquote><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><blockquote><p>我使用depends分析libglib-2.0.dll，结果如下图所示<br><img src="/images/2019-04-18_glib_2.png" alt><br>从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。<br>1、网上下载libintl-8.dll<br>2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下</p></blockquote><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><blockquote><p>上述步骤完成之后，再次使用depends检查，如下图所示：<br><img src="/images/2019-04-18_glib_3.png" alt><br>程序也正常运行</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><p>我这里只是说明解决问题的方法，图中dll版本问题自行忽略</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="GLib" scheme="https://weeweetan.github.io/categories/GLib/"/>
    
    
      <category term="GLib" scheme="https://weeweetan.github.io/tags/GLib/"/>
    
  </entry>
  
  <entry>
    <title>安装vCenter Server出现1603错误的一种解决方法</title>
    <link href="https://weeweetan.github.io/2018/11/29/%E5%AE%89%E8%A3%85vCenter-Server%E5%87%BA%E7%8E%B01603%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/</id>
    <published>2018-11-29T02:04:37.000Z</published>
    <updated>2019-05-15T14:12:39.771Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配置，导致vCenter Server相关服务无法启动，查找解决方法无果后，就打算重装vCenter Server。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>部署过程主要参考<a href="https://blog.csdn.net/shengxia1999/article/details/52353177" target="_blank" rel="noopener">VMware Vsphere 6.0安装部署 （三） vCenter Server安装</a>。在这里我主要说明一下我所遇到的问题以及解决方法。在安装过程中遇到Encountered an internal error，Install-parameter rhttpproxy.ext.port1 not set具体错误信息如下图所示：<br><img src="/images/2018-11-29_error.png" alt></p></blockquote><blockquote><p>出现这个错误后，会退出安装，在最后会报‘安装组件VCSServiceManager失败并显示错误代码1603’，如下图所示：<br><img src="/images/2018-11-29_error_code.png" alt><br>出现这个错误，首先应当排查在安装vCenter Server 过程中配置的http端口是否被占用(使用命令netstat -nao)，如果端口没有被占用，则使用如下方法：</p></blockquote><ol><li><p>删除C:\Program Files\VMware\vCenter Server目录；</p></li><li><p>重启虚拟机，重新安装</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这个方法不一定能解决所有这类问题，这只是其中一种解决方法。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>VMware虚拟机备份与恢复</title>
    <link href="https://weeweetan.github.io/2018/10/31/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>https://weeweetan.github.io/2018/10/31/VMware虚拟机备份与恢复/</id>
    <published>2018-10-31T08:05:03.000Z</published>
    <updated>2019-06-03T14:12:21.114Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文主要是根据自己实际项目经验对<a href="http://www.cnblogs.com/sammyliu/p/5661085.html" target="_blank" rel="noopener">云与备份之（1）：VMware虚机备份和恢复</a>这篇文章进行补充说明。本文将以部分引用，部分说明的方式进行组织，加粗部分为我自己总结的内容。<br>原文中提到两套SDK（vddk跟Web service SDK），整个虚拟机备份流程需要着两套SDK配合使用，我把这两套SDK整理了一下，使之能够在clion跟idea中运行，地址如下：<a href="https://github.com/weeweetan/VMwareProject" target="_blank" rel="noopener">VMwareProject</a><br><a href="https://github.com/weeweetan/vix_disklib_sample" target="_blank" rel="noopener">vix_disklib_sample</a></p></blockquote><h2 id="1-与备份有关的VMWare基础知识"><a href="#1-与备份有关的VMWare基础知识" class="headerlink" title="1. 与备份有关的VMWare基础知识"></a>1. 与备份有关的VMWare基础知识</h2><h3 id="1-1-VMware-虚机磁盘在-ESXi-宿主机上的文件"><a href="#1-1-VMware-虚机磁盘在-ESXi-宿主机上的文件" class="headerlink" title="1.1 VMware 虚机磁盘在 ESXi 宿主机上的文件"></a>1.1 VMware 虚机磁盘在 ESXi 宿主机上的文件</h3><blockquote><p>简单来说，虚机的每个虚拟磁盘由ESXi 宿主机上的三个文件组成（这里的虚机名字是 sammy-target-win-small，下面是其第一个磁盘对应的三个文件）：</p><ul><li>sammy-target-win-small.vmdk （配置文件，大小 633 字节）</li><li>sammy-target-win-small-flat.vmdk （二进制文件，大小 12884901888 字节）</li><li>sammy-target-win-small-ctk.vmdk （二进制文件，大小 78694 字节）<br>其中，</li></ul><p>第一个文件保存的是该磁盘的元数据，其中包括另外两个文件的信息</p><pre><code># Extent descriptionRW 25165824 VMFS &quot;sammy-target-win-small-flat.vmdk&quot;# Change Tracking FilechangeTrackPath=&quot;sammy-target-win-small-ctk.vmdk&quot;</code></pre><p>第二个文件是 Extent description 文件，二进制数据保存在这个文件中。下面会介绍使用API获取该文件中数据的方法。<br>第三个文件是 CTK 文件。下面讲到 CTK 的时候再说。</p><footer><strong>@刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)</strong></footer></blockquote><h3 id="1-2-虚拟磁盘类型"><a href="#1-2-虚拟磁盘类型" class="headerlink" title="1.2 虚拟磁盘类型"></a>1.2 虚拟磁盘类型</h3><blockquote><p>上一节中的磁盘组织形式并不是唯一的，早期版本的Esxi不是以这种方式组织。vddk文档中定义了8种磁盘类型，在创建虚拟磁盘时，使用不同磁盘类型，则虚拟磁盘的组织方式不同。8中磁盘类型如下：</p><ul><li>VIXDISKLIB_DISK_MONOLITHIC_SPARSE – Growable virtual disk contained in a single virtual disk file. This is the default type for hosted disk, and the only setting in the Virtual Disk API Sample Code sample program.</li><li>VIXDISKLIB_DISK_MONOLITHIC_FLAT – Preallocated virtual disk contained in a single virtual disk file. This takes time to create and occupies a lot of space, but might perform better than sparse.</li><li>VIXDISKLIB_DISK_SPLIT_SPARSE – Growable virtual disk split into 2GB extents ( s sequence). These files can to 2GB, then continue growing in a new extent. This type works on older file systems.</li><li>VIXDISKLIB_DISK_SPLIT_FLAT – Preallocated virtual disk split into 2GB extents ( f sequence). These files start at 2GB, so they take a while to create, but available space can grow in 2GB increments.</li><li>VIXDISKLIB_DISK_VMFS_FLAT – Preallocated virtual disk compatible with ESX 3 and later. Also known as thick disk. This managed disk type is discussed in Managed Disk and Hosted Disk.</li><li>VIXDISKLIB_DISK_VMFS_SPARSE – Employs a copy-on-write (COW) mechanism to save storage space.</li><li>VIXDISKLIB_DISK_VMFS_THIN – Growable virtual disk that consumes only as much space as needed, compatible with ESX 3 or later, supported by VDDK 1.1 or later, and highly recommended.</li><li>VIXDISKLIB_DISK_STREAM_OPTIMIZED – Monolithic sparse format compressed for streaming. Stream optimized format does not support random reads or writes.<br>只有vddk使用<em>VIXDISKLIB_DISK_VMFS_FLAT</em>类型创建虚拟磁盘时才会生成1.1节中所示的虚拟磁盘文件，使用Web Service SDK创建虚拟磁盘则不受此限制。</li></ul></blockquote><h3 id="1-3-虚拟磁盘模式"><a href="#1-3-虚拟磁盘模式" class="headerlink" title="1.3 虚拟磁盘模式"></a>1.3 虚拟磁盘模式</h3><blockquote><p>虚拟磁盘模式分为持久跟非持久，以下为vddk中对持久的定义</p><ul><li>持久模式(persistent)：In persistent disk mode, changes are immediately and permanently written to the virtual disk, so that they survive even through to the next power on.</li><li>非持久模式(nonpersistent)：In nonpersistent mode, changes to the virtual disk are discarded when the virtual machine powers off. The VMDK files revert to their original state.</li></ul></blockquote><blockquote><p>使用vSphere client创建虚拟磁盘跟vddk的选项可能会有区别</p><ul><li>独立持久：持久模式磁盘的行为与物理机上常规磁盘的行为相似。写入持久模式磁盘的所有数据都会永久性地写入磁盘。</li><li>独立非持久：关闭虚拟机电源或重置虚拟机时，对非持久模式磁盘的更改将丢失。使用非持久模式，您可以每次使用相同的虚拟磁盘状态重新启动虚拟机。对磁盘的更改会写入重做日志文件并从中读取，重做日志文件会在关闭虚拟机电源或重置虚拟机时被删除。</li></ul></blockquote><h3 id="1-4-vCenter-Server"><a href="#1-4-vCenter-Server" class="headerlink" title="1.4 vCenter Server"></a>1.4 vCenter Server</h3><blockquote><p>vCenter Server相当于一套管理多台Esxi服务器的系统，如果需要对虚拟机进行备份，则需要部署这么一套系统，具体怎么部署可以参考<a href="https://blog.csdn.net/shengxia1999/article/details/52353177" target="_blank" rel="noopener">VMware Vsphere 6.0安装部署 （三） vCenter Server安装</a>。备份所使用的Web serviceSDK依赖这套系统，对于这套系统的使用可以参考我其他关于vSphere的文章。</p></blockquote><h3 id="1-5-vSphere-Web-Client"><a href="#1-5-vSphere-Web-Client" class="headerlink" title="1.5 vSphere Web Client"></a>1.5 vSphere Web Client</h3><blockquote><p>vSphere Web Client为vCenter Server提供一个web管理界面，文中关于对vCenter的操作都是在这界面上完成。</p></blockquote><h3 id="1-5-虚拟机注册"><a href="#1-5-虚拟机注册" class="headerlink" title="1.5 虚拟机注册"></a>1.5 虚拟机注册</h3><blockquote><p>在vCenter Server中，Esxi服务器以及虚拟机以实体对象的形式存在，已有的虚拟机文件可以通过注册功能，将虚拟机文件激活成虚拟机，这里涉及到虚拟机的其他文件，可以参考<a href="https://docs.vmware.com/cn/VMware-vSphere/6.0/com.vmware.vsphere.vm_admin.doc/GUID-CEFF6D89-8C19-4143-8C26-4B6D6734D2CB.html" target="_blank" rel="noopener">什么是虚拟机?</a>。在vCenter Server中将.vmx文件作为虚拟机，所以在vCenter Server中找到虚拟机文件，右键注册就可以了。</p></blockquote><h2 id="2-备份要点"><a href="#2-备份要点" class="headerlink" title="2. 备份要点"></a>2. 备份要点</h2><blockquote><p>原文中对备份流程进行了详细说明，我这里就不再赘述，我将从以下几个方面说明备份要点。其中具体代码实现可以去<a href="https://blog.csdn.net/u013385554" target="_blank" rel="noopener">我的csdn</a>查看相关文章</p></blockquote><h3 id="2-1-如何确定虚拟机对象？"><a href="#2-1-如何确定虚拟机对象？" class="headerlink" title="2.1 如何确定虚拟机对象？"></a>2.1 如何确定虚拟机对象？</h3><blockquote><p>这个时候就需要使用Web service SDK去遍历vCenter Server中的虚拟机对象，并返回虚拟机的名称和在vCenter中的id，有了这两个变量，就可以确定虚拟机对象了。</p></blockquote><h3 id="2-2-如何获取虚拟机相关配置？"><a href="#2-2-如何获取虚拟机相关配置？" class="headerlink" title="2.2 如何获取虚拟机相关配置？"></a>2.2 如何获取虚拟机相关配置？</h3><blockquote><p>这一步中最重要的是拿到虚拟机磁盘对象，对虚拟机的备份，实际上是对虚拟磁盘的备份，这里还是使用Web ServiceSDk进行获取</p></blockquote><h3 id="2-3-如何获取变化数据？"><a href="#2-3-如何获取变化数据？" class="headerlink" title="2.3 如何获取变化数据？"></a>2.3 如何获取变化数据？</h3><blockquote><p>原文中有提到一个API：QueryChangedDiskAreas<br></p><blockquote><p>获取 CBT 变化块的函数的定义为：QueryChangedDiskAreas(snapshot, deviceKey, startOffSet, changeID)。其中，</p><ul><li>snapshot 代表当前的快照，也就是“变化”时间段的后端点；</li><li>deviceKey 是目标虚拟磁盘的 device ID；</li><li>startOffSet 是开始获取变化块的offset；</li><li>changeID 是指“变化”时间段的前端点，即老的快照的 changeID。<br>其结果类似 “(117768192, 65536),(132120576, 65536),(145096704, 43122688),(265289728, 65536),(958398464, 65536)”，每项的格式为 （offset，length），表示一个发生变化的数据块。</li></ul><footer><strong>@刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)</strong></footer></blockquote><br>使用QueryChangedDiskAreas获取到变化数据后，需要将这些数据保存下来，以供后续使用。<p></p></blockquote><h3 id="2-4-如何下载变化数据？"><a href="#2-4-如何下载变化数据？" class="headerlink" title="2.4 如何下载变化数据？"></a>2.4 如何下载变化数据？</h3><blockquote><p>这个时候就需要vddk，vddk可以连接到远程的虚拟磁盘，并根据上一节保存的数据，将虚拟磁盘中的变化数据读取并保存下来，以供恢复使用。</p></blockquote><h2 id="3-恢复要点"><a href="#3-恢复要点" class="headerlink" title="3. 恢复要点"></a>3. 恢复要点</h2><h3 id="3-1-完全恢复"><a href="#3-1-完全恢复" class="headerlink" title="3.1 完全恢复"></a>3.1 完全恢复</h3><blockquote><p>如果在完全备份的时候采用文件下载的形式进行备份，则在恢复的时候就可以直接将文件上传至vCenter Server然后注册虚拟机就可以了。如果备份的时候只备份了虚拟磁盘，则在恢复的时候需要使用Web Service SDK创建虚拟机，再将磁盘数据写入到新建的虚拟机中。</p></blockquote><h3 id="3-2-增量恢复"><a href="#3-2-增量恢复" class="headerlink" title="3.2 增量恢复"></a>3.2 增量恢复</h3><blockquote><p>增量恢复以完全恢复为前提，每个增量点依次恢复。</p></blockquote><h3 id="3-3-其他办法"><a href="#3-3-其他办法" class="headerlink" title="3.3 其他办法"></a>3.3 其他办法</h3><blockquote><p>如果业务十分紧急，则可以将备份的虚拟机文件以NFS的形式挂载到vCenter Server上，通过注册虚拟机的方式进行恢复。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>Java与PHP之间的Socket通信</title>
    <link href="https://weeweetan.github.io/2018/08/08/Java%E4%B8%8EPHP%E4%B9%8B%E9%97%B4%E7%9A%84Socket%E9%80%9A%E4%BF%A1/"/>
    <id>https://weeweetan.github.io/2018/08/08/Java与PHP之间的Socket通信/</id>
    <published>2018-08-08T15:55:23.000Z</published>
    <updated>2019-07-16T15:13:03.436Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="Java作为服务端"><a href="#Java作为服务端" class="headerlink" title="Java作为服务端"></a>Java作为服务端</h2><blockquote><p>Java端作为服务端，PHP端作为客户端，在之前一篇文章中说了下PHP作为客户端如何与Java端进行通信。由于业务需要，socket必须等待服务端处理完成，并返回处理结果给PHP端。在这里主要说明一下Java端如何处理的，不足之处，望指正。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port); <span class="comment">//创建绑定到特定端口的服务器套接字</span></span><br><span class="line">Socket socket = serverSocket.accept(); <span class="comment">//侦听并接受到此套接字的连接</span></span><br><span class="line"></span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] packetLength = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">inputStream.read(packetLength, <span class="number">0</span>, <span class="number">4</span>);            <span class="comment">//首先从套接字中读取4字节的数据长度</span></span><br><span class="line"><span class="keyword">int</span> target = byteToint(packetLength);            <span class="comment">//这里将字节数组转换成整数</span></span><br><span class="line">System.out.println(<span class="string">"message size:"</span> + target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[target];</span><br><span class="line">inputStream.read(bytes);                            <span class="comment">//读取指定长度的数据</span></span><br><span class="line">sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, target, <span class="string">"UTF-8"</span>));</span><br><span class="line">System.out.println(<span class="string">"get message "</span> + sb);</span><br><span class="line"></span><br><span class="line">String result = <span class="string">"has receive message"</span>;</span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"><span class="keyword">int</span> responseLength =  result.getBytes().length;        <span class="comment">//这个地方的长度，一定要是字节数组的长度，否则如果字符串中包含中文，接收端接收数据会不完整           </span></span><br><span class="line"><span class="keyword">byte</span>[] targets = intTobyte(responseLength);</span><br><span class="line">outputStream.write(targets);                          <span class="comment">//首先发送4个字节的数据大小</span></span><br><span class="line">outputStream.write(result.getBytes());                <span class="comment">//再发送真正的数据</span></span><br><span class="line"></span><br><span class="line">outputStream.flush();</span><br><span class="line">outputStream.close();</span><br><span class="line">inputStream.close();</span><br><span class="line">socket.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>上述代码需要处异常，而且代码中的byteToint和intTobyte这两个函数非原创，是其他博主的劳动成果，感谢这位作者，原文地址<em><a href="https://www.cnblogs.com/langren1992/p/4717241.html" target="_blank" rel="noopener">https://www.cnblogs.com/langren1992/p/4717241.html</a></em>。</p></blockquote><h2 id="PHP作为服务端"><a href="#PHP作为服务端" class="headerlink" title="PHP作为服务端"></a>PHP作为服务端</h2><blockquote><p>相关函数: socket_create、socket_set_block、socket_bind、socket_listen、socket_accept、socket_read、socket_write，这些函数具体参数说明在<a href="https://www.php.net/" target="_blank" rel="noopener">PHP文档</a>上写很详细，这里就不再赘述，这里只是介绍服务端如何处理请求。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保在连接客户端时不会超时</span></span><br><span class="line">set_time_limit(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置IP和端口号</span></span><br><span class="line">$address = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">$port = <span class="number">54321</span>;</span><br><span class="line">$socketServer = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"socket_create() fail:"</span> . socket_strerror(socket_last_error()) . <span class="string">"/n"</span>);</span><br><span class="line"><span class="comment">//设置为阻塞模式</span></span><br><span class="line">socket_set_block($socketServer) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"socket_set_block() fail:"</span> . socket_strerror(socket_last_error()) . <span class="string">"/n"</span>);</span><br><span class="line"><span class="comment">//绑定端口</span></span><br><span class="line">$result = socket_bind($socketServer, $address, $port) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"socket_bind() fail:"</span> . socket_strerror(socket_last_error()) . <span class="string">"/n"</span>);</span><br><span class="line"><span class="comment">//开始监听</span></span><br><span class="line">$result = socket_listen($socketServer, <span class="number">4</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"socket_listen() fail:"</span> . socket_strerror(socket_last_error()) . <span class="string">"/n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//接收连接请求并返回一个子Socket来处理客户端和服务器间的信息</span></span><br><span class="line">    $sock = socket_accept($socketServer) <span class="keyword">or</span>  <span class="keyword">die</span>(<span class="string">"socket_accept() failed: reason: "</span> . socket_strerror(socket_last_error()) . <span class="string">"/n"</span>);</span><br><span class="line">    <span class="keyword">while</span>($sock)&#123;</span><br><span class="line">        <span class="comment">//读取客户端数据</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Read client data \n"</span>;</span><br><span class="line"></span><br><span class="line">        $length = socket_read($sock, <span class="number">4</span>);</span><br><span class="line">        $length = unpack(<span class="string">'i'</span>, $length);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"length:$length[1]   \n"</span>;</span><br><span class="line"></span><br><span class="line">        $request = socket_read($sock, $length[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"$request:$request   \n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据传送 向客户端写入返回结果</span></span><br><span class="line">        $msg = <span class="string">"this is response message \n"</span>;</span><br><span class="line">        $msgLength = strlen($msg);</span><br><span class="line">        $msgLength = pack(<span class="string">'i'</span>, $msgLength);</span><br><span class="line">        socket_write($sock, $msgLength);</span><br><span class="line">        socket_write($sock, $msg, strlen($msg)) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"socket_write() failed: reason: "</span> . socket_strerror(socket_last_error()) .<span class="string">"/n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//根据需要关闭socket</span></span><br><span class="line">socket_close($socketServer);</span><br></pre></td></tr></table></figure><blockquote><p>在接收到客户端的请求后，可以结合PHP的多线程进行处理，这里只是简单的返回字符串。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>各大语言实现socket通信的方式都是大同小异，在服务端的流程都是差不多的。在有现成高性能socket通信框架的情况下，建议不要自己去实现，但是得理解框架底层是怎样实现的。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Java作为服务端&quot;&gt;&lt;a href=&quot;#Java作为服务端&quot; class=&quot;headerlink&quot; title=&quot;Java作为服务端
      
    
    </summary>
    
      <category term="Socket" scheme="https://weeweetan.github.io/categories/Socket/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
      <category term="Socket" scheme="https://weeweetan.github.io/tags/Socket/"/>
    
      <category term="Java" scheme="https://weeweetan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>VMware vSphere WebService SDK使用心得</title>
    <link href="https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK使用心得/</id>
    <published>2018-07-25T12:13:58.000Z</published>
    <updated>2019-05-15T13:27:59.170Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="善用mob（Managed-Object-Browser）"><a href="#善用mob（Managed-Object-Browser）" class="headerlink" title="善用mob（Managed Object Browser）"></a>善用mob（Managed Object Browser）</h2><blockquote><p>mob地址一般是<em><a href="https://vcenter的FQDN/mob" target="_blank" rel="noopener">https://vcenter的FQDN/mob</a></em>，mob可以让你更好的理解SDK中的那些例子，以及根据自己的业务逻辑改写一些功能。下图为mob首页图，图中的content为整个Managed Object的顶层，从这里进去可以找到整个vcenter server中所有对象及其属性。<br><img src="/images/2018-07-25_mob.png" alt></p></blockquote><h2 id="善用GetMOREF类"><a href="#善用GetMOREF类" class="headerlink" title="善用GetMOREF类"></a>善用GetMOREF类</h2><blockquote><p>GetMOREF类具体位置在<em>VMware-vSphere-SDK-6.0.0-2561048\SDK\vsphere-ws\java\JAXWS\samples\com\vmware\connection\helpers</em>，这是VMware官方提供的一个工具类，里面的每个函数对于开发都很有用。例如</p></blockquote><pre><code>​List&lt;VirtualDevice&gt; listvd = ((ArrayOfVirtualDevice) getMOREFs                                .entityProps(vmMor, new String[] { &quot;config.hardware.device&quot; })                                .get(&quot;config.hardware.device&quot;)).getVirtualDevice();</code></pre><blockquote><p>这是VMReconfig.java中的一个片段，这段代码的作用就是去获取指定虚拟机对象的所有设备，vmMor可以通过GetMOREF类中的vmByVMname函数去获得。至于config.hardware.device，就需要用mob一层一层点进去看了，相信结合mob就能理解为什么要这么写。</p></blockquote><pre><code>​​ ManagedObjectReference propCol = connection.getServiceContent().getPropertyCollector(); ManagedObjectReference vmRef = getMOREFs.vmByVMname(virtualMachineName,propCol);</code></pre><blockquote><p>上面这段代码的作用就是如何根据虚拟机名去获取其对应的ManagedObjectReference</p></blockquote><h2 id="善用SDK里面的文档"><a href="#善用SDK里面的文档" class="headerlink" title="善用SDK里面的文档"></a>善用SDK里面的文档</h2><blockquote><p>文档首页为<em>VMware-vSphere-SDK-6.0.0-2561048/SDK/vsphere-ws/docs/ReferenceGuide/index.html</em><br><img src="/images/2018-07-25_doc.png" alt><br>根据需求，在左侧导航栏对应的去找。</p></blockquote><blockquote><p>对SDK我整理了一下，使其能够在idea中编译运行，项目地址在<a href="https://github.com/wulikanhua/VMwareProject" target="_blank" rel="noopener">VMwareProject</a> ​</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;善用mob（Managed-Object-Browser）&quot;&gt;&lt;a href=&quot;#善用mob（Managed-Object-Brows
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>Socket粘包处理</title>
    <link href="https://weeweetan.github.io/2018/07/25/Socket%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86/"/>
    <id>https://weeweetan.github.io/2018/07/25/Socket粘包处理/</id>
    <published>2018-07-25T11:05:52.000Z</published>
    <updated>2019-07-16T15:11:06.374Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据，并等待Java的响应结果，数据格式为JSON。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>PHP端发送数据后，Java端从socket里读取数据，但是一直读不到结束符。</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote><p>PHP需要调用socket_close函数才会向socket里面写入结束符。</p></blockquote><h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><blockquote><p><strong>PHP端与Java端之间确定每次发送数据包的长度，用4个字节表示数据长度，PHP端先发送数据包长度，再发送数据包，Java端先接收4个字节长度的数据包长度，再根据数据包长度接收数据包</strong>。PHP端代码如下:</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP  ) <span class="keyword">or</span> <span class="keyword">die</span> ( <span class="string">'could not create socket'</span>  );  </span><br><span class="line">$connect = socket_connect ( $socket, <span class="string">'xxx.xxx.xxx.xxx'</span>, xxxx);  </span><br><span class="line"><span class="comment">//服务端发送数据 </span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"data"</span> =&gt; <span class="string">"dadadada"</span>);</span><br><span class="line">$strlen = pack(<span class="string">'i'</span>, strlen(json_encode($arr)));</span><br><span class="line">var_dump($strlen);</span><br><span class="line">socket_write ($socket, $strlen);</span><br><span class="line">socket_write ($socket, json_encode($arr), strlen(json_encode($arr)));</span><br><span class="line">$response = socket_read($socket, <span class="number">4</span>); </span><br><span class="line">$res = unpack(<span class="string">'i'</span>, $response);</span><br><span class="line">var_dump($res);</span><br><span class="line">$response = socket_read($socket, $res[<span class="number">1</span>]);</span><br><span class="line">var_dump($response);</span><br><span class="line">socket_close($socket);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.php.net/pack" target="_blank" rel="noopener">pack</a>与<a href="https://www.php.net/unpack" target="_blank" rel="noopener">unpack</a>函数使用说明见PHP官方文档</p></blockquote><p>​</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="Socket" scheme="https://weeweetan.github.io/categories/Socket/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
      <category term="Socket" scheme="https://weeweetan.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>使用gcc编译驱动模块遇到的问题</title>
    <link href="https://weeweetan.github.io/2017/05/22/%E4%BD%BF%E7%94%A8gcc%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://weeweetan.github.io/2017/05/22/使用gcc编译驱动模块遇到的问题/</id>
    <published>2017-05-22T09:30:33.000Z</published>
    <updated>2019-05-17T15:43:16.624Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客<a href="http://bbs.chinaunix.net/thread-2017377-1-1.html" target="_blank" rel="noopener">写一个块设备驱动</a>学习，练习环境为centos6.5 gcc版本为6.3。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>跟着敲完那个简单的驱动程序后，发现编译出错，错误信息为</p></blockquote><pre><code>include/linux/compiler-gcc.h:89:30: fatal error: linux/compiler-gcc6.h: No such file or directory</code></pre><blockquote><p>一通百度，说gcc版本太高，去下载一个<em>compiler-gcc6.h</em>文件，放到内核源码文件夹里面，按着做了，结果编译又出问题了，错误信息为</p></blockquote><pre><code>include/linux/compiler.h:163:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void data_access_exceeds_word_size(void)include/linux/compiler.h:169:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void data_access_exceeds_word_size(void)include/linux/compiler.h:173:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void __read_once_size(volatile void *p, void *res, int size)include/linux/compiler.h:190:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void __write_once_size(volatile void *p, void *res, int size)</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>又是一通百度，发现跟我情况不符，看了下博客发表时间，08年，果断换了一个centos6.0的机器，gcc版本为4.6，编译完美通过,环境因素很重要啊。。。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="Linux" scheme="https://weeweetan.github.io/categories/Linux/"/>
    
    
      <category term="驱动模块" scheme="https://weeweetan.github.io/tags/%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="Linux" scheme="https://weeweetan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP脚本中使用exec总结</title>
    <link href="https://weeweetan.github.io/2017/02/20/PHP%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8exec%E6%80%BB%E7%BB%93/"/>
    <id>https://weeweetan.github.io/2017/02/20/PHP脚本中使用exec总结/</id>
    <published>2017-02-20T01:03:11.000Z</published>
    <updated>2019-05-17T15:54:50.468Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>总结一下这两天加班遇到的坑，由于本次任务涉及到在PHP中使用exec函数运行shell命令，并解析返回值。屁颠屁颠的写好代码，上传到服务器，服务器环境配置centos6.5+Nginx，ssh到服务器，在控制台运行php xxx.php结果完美显示。蛋疼的是前端调用脚本的时候，没有数据，返回false，一脸懵逼，开始想问题所在，试着在浏览器地址栏直接访问xxx.php没有结果。然后把代码改成</p></blockquote><pre><code>exec(&quot;ls 2&gt;&amp;1&quot;, $result);var_dump($result);</code></pre><blockquote><p>显示ls命令没找到，试着加上路径</p></blockquote><pre><code>exec(&quot;/bin/ls 2&gt;&amp;1&quot;, $result);var_dump($result);</code></pre><blockquote><p>显示权限不够。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>lsof -i:80 查看你Nginx的用户是谁，我这里是nginx</li><li>在脚本中添加file_put_contents(“/tmp/test.log”, “xxx”)查看test.log的用户是谁。我这里是nobody</li><li><p>在vim /etc/sudoers添加权限</p><p>nobody ALL=(ALL) NOPASSWD:ALL<br>nginx ALL=(ALL) NOPASSWD:ALL</p></li><li><p>重启nginx服务。</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Esxi5.1挂载NFS存储遇到的问题及解决办法</title>
    <link href="https://weeweetan.github.io/2017/01/13/Esxi5-1%E6%8C%82%E8%BD%BDNFS%E5%AD%98%E5%82%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/</id>
    <published>2017-01-13T01:18:44.000Z</published>
    <updated>2019-05-18T01:20:29.052Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>如何配置NFS以及怎样在Esxi中添加NFS，可以参考<a href="https://www.linuxidc.com/Linux/2017-04/142686.htm" target="_blank" rel="noopener">VMware ESXI 5.5使用NFS添加存储器</a>, 我也是按照这个博客来配置的。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>遇到如下问题：<br><img src="/images/2017-01-13_nfs.jpg" alt></p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>必须要检查你的esxi主机是否配置了<em>VMkernel</em>，检查步骤如下：<br>1、使用 VI/vSphere Client 连接到 Virtual Center/vCenter Server。<br>2、选择 ESX/ESXi 主机。<br>3、单击配置选项卡。<br>4、单击网络。<br>5、查看 VMKernel 的网络图，或单击属性 &gt; 端口 &gt; VMKernel。如果 VMKernel 未列出，必须添加它。</p></blockquote><h2 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h2><blockquote><p>手动挂载命令：</p></blockquote><pre><code>esxcli storage nfs add -H NFS_IP|NFS_HOSTNAME -s Share_mount_point_on_the_NFS -v DatastoreName</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p><strong>必须保证esxi主机与NFS服务器在同一网段或者能够相互通信</strong></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 08 2019 21:03:41 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
</feed>
