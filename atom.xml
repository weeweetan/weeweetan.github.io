<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>weeweetan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weeweetan.github.io/"/>
  <updated>2019-05-26T06:04:11.118Z</updated>
  <id>https://weeweetan.github.io/</id>
  
  <author>
    <name>weeweetan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dos常用命令</title>
    <link href="https://weeweetan.github.io/2019/05/26/Dos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://weeweetan.github.io/2019/05/26/Dos常用命令/</id>
    <published>2019-05-26T05:56:27.000Z</published>
    <updated>2019-05-26T06:04:11.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h2><blockquote><p>sc命令可用于卸载windows服务，如下所示：</p></blockquote><pre><code>sc delete serv</code></pre><blockquote><p>其中serv为服务名，可在服务中查看</p></blockquote><h2 id="xcopy"><a href="#xcopy" class="headerlink" title="xcopy"></a>xcopy</h2><blockquote><p>xcopy命令用于Dos下复制文件夹及子文件夹，如下所示：</p></blockquote><pre><code>xcopy d:\abc\aaa\*.* c:\windows\system /s</code></pre><blockquote><p>其中第一个参数是源位置，第二个参数是目标位置<br>/s：复制目录和子目录，除了空的。        </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sc&quot;&gt;&lt;a href=&quot;#sc&quot; class=&quot;headerlink&quot; title=&quot;sc&quot;&gt;&lt;/a&gt;sc&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;sc命令可用于卸载windows服务，如下所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;sc 
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Dos" scheme="https://weeweetan.github.io/tags/Dos/"/>
    
  </entry>
  
  <entry>
    <title>中国菜翻译方法</title>
    <link href="https://weeweetan.github.io/2019/05/18/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E7%BF%BB%E8%AF%91%E6%96%B9%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2019/05/18/中国菜翻译方法/</id>
    <published>2019-05-18T02:27:42.000Z</published>
    <updated>2019-05-18T02:32:50.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以主料为主"><a href="#以主料为主" class="headerlink" title="以主料为主"></a>以主料为主</h2><blockquote><p>配料或配汁为辅的翻译原则<br>菜肴的主料和配料</p><p>主料（名称/形状）+ with + 配料</p><p>如：松仁香菇 Chinese Mushrooms with Pine Nuts</p><p>菜肴的主料和配汁</p><p>主料 + with / in + 汤汁（Sauce）</p><p>如：冰梅凉瓜 Bitter Melon in Plum Sauc</p></blockquote><h2 id="以烹制方法为主"><a href="#以烹制方法为主" class="headerlink" title="以烹制方法为主"></a>以烹制方法为主</h2><blockquote><p>原料为辅的翻译原则<br>菜肴的做法和主料</p><p>做法（动词过去分词）+ 主料（名称/形状）</p><p>如：拌双耳 Tossed Black and White Fungus</p><p>菜肴的做法、主料和汤汁</p><p>做法(动词过去分词) + 主料（名称/形状）+ with / in + 汤汁</p><p>如：京酱肉丝 Sautéed Shredded Pork in Sweet Bean Sauce</p></blockquote><h2 id="以形状、口感为主"><a href="#以形状、口感为主" class="headerlink" title="以形状、口感为主"></a>以形状、口感为主</h2><blockquote><p>原料为辅的翻译原则<br>菜肴形状或口感以及主配料</p><p>形状/口感 + 主料</p><p>如：玉兔馒头 Rabbit-Shaped Mantou<br>菜肴的做法、形状或口感、做法以及主配料</p><p>做法（动词过去分词）+ 形状/口感 + 主料 + 配料</p><p>如： 小炒黑山羊 Sautéed Sliced Lamb with Pepper and Parsley</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;以主料为主&quot;&gt;&lt;a href=&quot;#以主料为主&quot; class=&quot;headerlink&quot; title=&quot;以主料为主&quot;&gt;&lt;/a&gt;以主料为主&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;配料或配汁为辅的翻译原则&lt;br&gt;菜肴的主料和配料&lt;/p&gt;
&lt;p&gt;主料（名称/形状）+ wi
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="翻译" scheme="https://weeweetan.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>C语言编程常见错误</title>
    <link href="https://weeweetan.github.io/2019/05/17/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <id>https://weeweetan.github.io/2019/05/17/C语言编程常见错误/</id>
    <published>2019-05-17T15:21:03.000Z</published>
    <updated>2019-06-17T11:15:19.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-使用close函数出现bad-file-descriptor错误"><a href="#1-使用close函数出现bad-file-descriptor错误" class="headerlink" title="1. 使用close函数出现bad file descriptor错误"></a>1. 使用close函数出现bad file descriptor错误</h2><blockquote><p>出现这种错误一般是两次close导致，仔细检查代码，调用close关闭文件描述符后，应该将文件描述符置为0，避免重复调用close，切记切记。</p></blockquote><h2 id="2-守护程序闪退问题"><a href="#2-守护程序闪退问题" class="headerlink" title="2. 守护程序闪退问题"></a>2. 守护程序闪退问题</h2><blockquote><p>出现这个问题一般是两次释放同一块内存，仔细检查释放内存与指针赋值相关代码，释放内存后，应将指针置为NULL，避免重复调用close，切记切记。</p></blockquote><h2 id="3-四字节对齐"><a href="#3-四字节对齐" class="headerlink" title="3. 四字节对齐"></a>3. 四字节对齐</h2><h3 id="4-什么是四字节对齐"><a href="#4-什么是四字节对齐" class="headerlink" title="4. 什么是四字节对齐"></a>4. 什么是四字节对齐</h3><blockquote><p>现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。</p></blockquote><h3 id="4-1-四字节对齐作用"><a href="#4-1-四字节对齐作用" class="headerlink" title="4.1 四字节对齐作用"></a>4.1 四字节对齐作用</h3><blockquote><p>定义结构体成员时应当注意四字节对齐，保证内存利用最大化。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。</p></blockquote><h2 id="5-柔性数组"><a href="#5-柔性数组" class="headerlink" title="5. 柔性数组"></a>5. 柔性数组</h2><blockquote><p>定义结构体时，最后一个成员定义为</p></blockquote><pre><code>struct test {    int a;    char b[0];}  </code></pre><blockquote><p>b[0]就称为柔性数组，使用</p></blockquote><pre><code>sizeof(struct test);</code></pre><blockquote><p>返回值为4，即b[0]不占用内存空间。  </p></blockquote><h2 id="6-数字转字符"><a href="#6-数字转字符" class="headerlink" title="6. 数字转字符"></a>6. 数字转字符</h2><blockquote><p>C语言书籍上可能出现过如下代码将数字转为字符</p></blockquote><pre><code>int a = 0;char b = a + &apos;0&apos;;</code></pre><blockquote><p>这个操作有局限性，当a的值超过9的时候就会得到你意向不到的结果，</p></blockquote><pre><code>int a = 10;char b = a + &apos;0&apos;;     </code></pre><blockquote><p>这个时候字符b的值为’:’ </p></blockquote><h2 id="7-fork函数注意事项"><a href="#7-fork函数注意事项" class="headerlink" title="7. fork函数注意事项"></a>7. fork函数注意事项</h2><blockquote><p>fork函数用来产生一个子进程，而且会复制父进程的资源（包括打开的文件描述符，变量等），无论是在子进程还是父进程对打开的文件描述符都需要谨慎对待，调用close函数关闭文件描述符可能不会报错，但是删除文件的时候就会出问题。   </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-使用close函数出现bad-file-descriptor错误&quot;&gt;&lt;a href=&quot;#1-使用close函数出现bad-file-descriptor错误&quot; class=&quot;headerlink&quot; title=&quot;1. 使用close函数出现bad file d
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://weeweetan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记</title>
    <link href="https://weeweetan.github.io/2019/05/08/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://weeweetan.github.io/2019/05/08/Nginx学习笔记/</id>
    <published>2019-05-08T02:49:55.000Z</published>
    <updated>2019-06-05T14:46:05.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-编译步骤"><a href="#1-编译步骤" class="headerlink" title="1. 编译步骤"></a>1. 编译步骤</h2><h3 id="1-1-configure原理"><a href="#1-1-configure原理" class="headerlink" title="1.1 configure原理"></a>1.1 configure原理</h3><blockquote><p>configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。</p></blockquote><h3 id="1-2-auto脚本"><a href="#1-2-auto脚本" class="headerlink" title="1.2 auto脚本"></a>1.2 auto脚本</h3><blockquote><p>auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：<br><img src="/images/2019-05-13_nginx.png" alt><br>上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。</p></blockquote><h4 id="1-2-1-auto-options脚本"><a href="#1-2-1-auto-options脚本" class="headerlink" title="1.2.1 auto/options脚本"></a>1.2.1 auto/options脚本</h4><blockquote><p>auto/options主是处理用户输入的configure选项，以及输出帮助信息等。auto/options的目的主要是处理用户选项，并由选项生成一些全局变量的值，这些值在其它文件中会用到。该文件也会输出configure的帮助信息。<br>应当注意如下代码</p></blockquote><pre><code>for optiondo    opt=&quot;$opt `echo $option | sed -e \&quot;s/\(--[^=]*=\)\(.* .*\)/\1&apos;\2&apos;/\&quot;`&quot;</code></pre><blockquote><p>for后面可以省略要遍历的变量,这时,表示在遍历$@,即用户传入的所有变量组合</p></blockquote><h4 id="1-2-2-auto-init脚本"><a href="#1-2-2-auto-init脚本" class="headerlink" title="1.2.2 auto/init脚本"></a>1.2.2 auto/init脚本</h4><blockquote><blockquote><p>该文件的目录在于初始化一些临时文件的路径，检查echo的兼容性，并创建最原始的Makefile文件。</p><footer><strong>淘宝</strong><cite><a href="http://tengine.taobao.org/book/chapter_09.html#auto" target="_blank" rel="noopener">Nginx开发从入门到精通</a></cite></footer></blockquote><p>注意：这里生成的Makefile文件与configure文件在同一目录，真正执行编译指令的Makefile在objs目录下</p></blockquote><h4 id="1-2-3-auto-sources脚本"><a href="#1-2-3-auto-sources脚本" class="headerlink" title="1.2.3 auto/sources脚本"></a>1.2.3 auto/sources脚本</h4><blockquote><blockquote><p>该文件从文件名中就可以看出，它的主要功能是跟源文件相关的。它的主要作用是定义不同功能或系统所需要的文件的变量。根据功能，分为CORE/REGEX/EVENT/UNIX/FREEBSD/HTTP等。每一个功能将会由四个变量组成，”_MODULES”表示此功能相关的模块，最终会输出到ngx_modules.c文件中，即动态生成需要编译到nginx中的模块；”INCS”表示此功能依赖的源码目录，查找头文件的时候会用到，在编译选项中，会出现在”-I”中；”DEPS”显示指明在Makefile中需要依赖的文件名，即编译时，需要检查这些文件的更新时间；”SRCS”表示需要此功能编译需要的源文件。</p><footer><strong>淘宝</strong><cite><a href="http://tengine.taobao.org/book/chapter_09.html#auto" target="_blank" rel="noopener">Nginx开发从入门到精通</a></cite></footer></blockquote><p>根据上面的描述，所以如果需要对nginx进行功能扩展，添加相应的C文件后，修改这个脚本就可以将自己的功能编译进nginx。</p></blockquote><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h2><h3 id="2-1-模块相关"><a href="#2-1-模块相关" class="headerlink" title="2.1 模块相关"></a>2.1 模块相关</h3><blockquote><p>在<em>ngx_module.h</em>中引用了两个至关重要的外部变量</p></blockquote><pre><code>extern ngx_module_t  *ngx_modules[];extern char          *ngx_module_names[];</code></pre><blockquote><p><em>ngx_modules</em>跟<em>ngx_module_names</em>定义在<em>ngx_modules.c</em>中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用<em>ngx_cycle_modules</em>函数，原型如下：</p></blockquote><pre><code>ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle)</code></pre><blockquote><p>此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下：</p></blockquote><pre><code>main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules</code></pre><h3 id="2-2-数据结构"><a href="#2-2-数据结构" class="headerlink" title="2.2 数据结构"></a>2.2 数据结构</h3><h4 id="2-2-1-ngx-str-t"><a href="#2-2-1-ngx-str-t" class="headerlink" title="2.2.1 ngx_str_t"></a>2.2.1 ngx_str_t</h4><blockquote><p>Nginx开发从入门到精通已经对<a href="http://tengine.taobao.org/book/chapter_02.html#ngx-str-t-100" target="_blank" rel="noopener">ngx_str_t</a>的定义以及相关api进行了非常详细的讲解，以下为定义：</p></blockquote><pre><code>typedef struct {    size_t      len;    u_char     *data;} ngx_str_t;</code></pre><blockquote><p>注意事项：    </p><ol><li>不要试图复制char *到data所指向的内存，可能导致coredump</li><li>初始化相关api都是基于常量字符串，char *类型慎用</li><li>如果非要复制char *到data所指向的内存，一定先分配内存</li></ol></blockquote><h4 id="2-2-2-ngx-array-t"><a href="#2-2-2-ngx-array-t" class="headerlink" title="2.2.2 ngx_array_t"></a>2.2.2 ngx_array_t</h4><blockquote><p>Nginx开发从入门到精通已经对<a href="http://tengine.taobao.org/book/chapter_02.html#ngx-array-t-100" target="_blank" rel="noopener">ngx_array_t</a>的定义以及相关api进行了非常详细的讲解，以下为定义：</p></blockquote><pre><code>typedef struct ngx_array_s       ngx_array_t;struct ngx_array_s {    void        *elts;    ngx_uint_t   nelts;    size_t       size;    ngx_uint_t   nalloc;    ngx_pool_t  *pool;};</code></pre><blockquote><p>注意事项</p><ol><li>如果使用ngx_array_t作为字符串容器，在调用ngx_array_create时，使用字符串长度最后一个参数</li><li>ngx_array_push返回第n个元素首地址，要注意指针运算           </li></ol></blockquote><h2 id="3-handler模块的编写步骤"><a href="#3-handler模块的编写步骤" class="headerlink" title="3. handler模块的编写步骤"></a>3. handler模块的编写步骤</h2><blockquote><ol><li>编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量：</li></ol></blockquote><pre><code>static ngx_command_t ngx_http_module_name_commands[] = {};static ngx_http_module_t ngx_http_module_name_module_ctx = {};ngx_module_t ngx_http_module_name_module = {};</code></pre><blockquote><ol start="2"><li>实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数：</li></ol></blockquote><pre><code>static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)；</code></pre><blockquote><ol start="3"><li>编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数：</li></ol></blockquote><pre><code>static ngx_int_t ngx_http_module_name_handler(ngx_http_request_t *r);</code></pre><h2 id="4-日志系统"><a href="#4-日志系统" class="headerlink" title="4. 日志系统"></a>4. 日志系统</h2><blockquote><p>Nginx的日志系统分为两个部分，一个是Nginx核心的错误日志（包括debug日志），一个是各模块的访问日志，整个Nginx框架中主要以核心的错误日志为主，各模块的访问日志根据模块调用顺序使用，下面分别介绍两种日志系统。</p></blockquote><h3 id="4-1-错误日志"><a href="#4-1-错误日志" class="headerlink" title="4.1 错误日志"></a>4.1 错误日志</h3><blockquote><p>关于错误日志的配置指令可以参考<a href="http://nginx.org/en/docs/ngx_core_module.html#error_log" target="_blank" rel="noopener">error_log</a>，分析Nginx源码可以发现，源码中多处使用ngx_log_debug0，ngx_log_debug1等类似的宏定义，启用这些宏定义需要在configure的时候执行–with-debug。<br>错误日志初始化分为两个阶段，一个是ngx_log_init函数中初始化日志对象，另外一个就是在解析配置文件的时候会新建一个日志对象。</p></blockquote><h3 id="4-2-访问日志"><a href="#4-2-访问日志" class="headerlink" title="4.2 访问日志"></a>4.2 访问日志</h3><blockquote><p>目前实现了访问日志的官方模块有http模块，stream模块，其中http模块的配置指令可以参考<a href="http://nginx.org/en/docs/http/ngx_http_log_module.html" target="_blank" rel="noopener">ngx_http_log_module</a>。http模块的日志系统是以http第三方模块的形式存在，所以编写的时候遵循第3节的规则。   </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-编译步骤&quot;&gt;&lt;a href=&quot;#1-编译步骤&quot; class=&quot;headerlink&quot; title=&quot;1. 编译步骤&quot;&gt;&lt;/a&gt;1. 编译步骤&lt;/h2&gt;&lt;h3 id=&quot;1-1-configure原理&quot;&gt;&lt;a href=&quot;#1-1-configure原理&quot; cla
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>libxml2使用心得</title>
    <link href="https://weeweetan.github.io/2019/05/04/libxml2%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2019/05/04/libxml2使用心得/</id>
    <published>2019-05-04T14:21:35.000Z</published>
    <updated>2019-05-15T07:04:26.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考<a href="http://www.blogjava.net/wxb_nudt/archive/2007/11/18/161340.html" target="_blank" rel="noopener">C++的XML编程经验――LIBXML2库使用指南</a>，这篇博文讲得很详细，我在这里只是做出一点补充。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。</p></blockquote><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><blockquote><p>我使用GLib2的<em>g_locale_from_utf8</em>将内容转换为本地程序默认的编码格式，在写入xml内容时使用<em>g_locale_to_utf8</em>将内容转换为UTF-8.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有
      
    
    </summary>
    
      <category term="libxml" scheme="https://weeweetan.github.io/categories/libxml/"/>
    
    
      <category term="libxml" scheme="https://weeweetan.github.io/tags/libxml/"/>
    
  </entry>
  
  <entry>
    <title>GLib使用心得</title>
    <link href="https://weeweetan.github.io/2019/04/28/GLib%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2019/04/28/GLib使用心得/</id>
    <published>2019-04-28T05:51:59.000Z</published>
    <updated>2019-05-18T01:23:41.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>关于GLib的介绍这里就不赘述了，具体API介绍可以去<a href="https://developer.gnome.org/glib/" target="_blank" rel="noopener">GLib API Reference</a>查阅，这里只是记录一下使用相关API所遇到的一些坑。</p></blockquote><h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><h3 id="字符串相关API"><a href="#字符串相关API" class="headerlink" title="字符串相关API"></a>字符串相关API</h3><pre><code>GString *g_string_new(const gchar *init);GString *g_string_append(GString *string, const gchar *val);GString *g_string_prepend(GString *string, const gchar *val);gchar *g_string_free(GString *string, gboolean free_segment);</code></pre><blockquote><p>如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。<strong>注意</strong> g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。<br><em>g_string_append</em>跟<em>g_string_prepend</em>都是直接在原字符串上操作，这点要切记。</p></blockquote><h3 id="字符转换相关API"><a href="#字符转换相关API" class="headerlink" title="字符转换相关API"></a>字符转换相关API</h3><pre><code>gchar *g_filename_display_basename(const gchar *filename);gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);</code></pre><blockquote><p>g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码<br>g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件<br>g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8<br>下面看个例子, 比如我们有个含中文的文件名 <em>/data/test/哈哈.txt</em>如果想获得 <em>哈哈.txt</em>，则必须首先使用 <em>g_locale_to_utf8</em>函数转换一次, 然后再去获取basename</p></blockquote><pre><code>GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;);gchar *str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL);gchar *basename = g_filename_display_basename(str);</code></pre><blockquote><p>如果想使用GString *类型保存basename，则必须重新申请内存块</p></blockquote><pre><code>GString *basename_string = g_string_new(basename); </code></pre><blockquote><p>千万别像下面这样做</p></blockquote><pre><code>GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;);string-&gt;str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); </code></pre><blockquote><p>如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，<em>g_locale_from_utf8</em> 同理<br><strong>注意</strong> <em>g_locale_to_utf8</em>返回的char *需要手动释放内存</p></blockquote><h3 id="解析key-value文件API"><a href="#解析key-value文件API" class="headerlink" title="解析key-value文件API"></a>解析key-value文件API</h3><pre><code>GKeyFile *g_key_file_new(void);gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name,  const gchar *key, GError **error);gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);void g_key_file_free(GKeyFile *key_file);</code></pre><blockquote><p>这几个API很好理解,用来解析具有键值对特征的文件,<em>g_key_file_new</em>跟<em>g_key_file_free</em>配套使用;<br>g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;关于GLib的介绍这里就不赘述了，具体API介绍可以去&lt;a href=&quot;https://developer.gno
      
    
    </summary>
    
      <category term="GLib" scheme="https://weeweetan.github.io/categories/GLib/"/>
    
    
      <category term="GLib" scheme="https://weeweetan.github.io/tags/GLib/"/>
    
  </entry>
  
  <entry>
    <title>调用glib库出现0xc000007b解决办法</title>
    <link href="https://weeweetan.github.io/2019/04/18/%E8%B0%83%E7%94%A8glib%E5%BA%93%E5%87%BA%E7%8E%B00xc000007b%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/</id>
    <published>2019-04-18T14:47:29.000Z</published>
    <updated>2019-05-18T01:22:38.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示：<br><img src="/images/2019-04-18_glib_1.png" alt></p></blockquote><blockquote><p>网上的解决办法都试过，没能解决问题。</p></blockquote><h2 id="出现转机"><a href="#出现转机" class="headerlink" title="出现转机"></a>出现转机</h2><blockquote><p>出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。</p></blockquote><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><blockquote><p>我使用depends分析libglib-2.0.dll，结果如下图所示<br><img src="/images/2019-04-18_glib_2.png" alt><br>从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。<br>1、网上下载libintl-8.dll<br>2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下</p></blockquote><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><blockquote><p>上述步骤完成之后，再次使用depends检查，如下图所示：<br><img src="/images/2019-04-18_glib_3.png" alt><br>程序也正常运行</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><p>我这里只是说明解决问题的方法，图中dll版本问题自行忽略</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用g
      
    
    </summary>
    
      <category term="GLib" scheme="https://weeweetan.github.io/categories/GLib/"/>
    
    
      <category term="GLib" scheme="https://weeweetan.github.io/tags/GLib/"/>
    
  </entry>
  
  <entry>
    <title>安装vCenter Server出现1603错误的一种解决方法</title>
    <link href="https://weeweetan.github.io/2018/11/29/%E5%AE%89%E8%A3%85vCenter-Server%E5%87%BA%E7%8E%B01603%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/</id>
    <published>2018-11-29T02:04:37.000Z</published>
    <updated>2019-05-15T14:12:39.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配置，导致vCenter Server相关服务无法启动，查找解决方法无果后，就打算重装vCenter Server。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>部署过程主要参考<a href="https://blog.csdn.net/shengxia1999/article/details/52353177" target="_blank" rel="noopener">VMware Vsphere 6.0安装部署 （三） vCenter Server安装</a>。在这里我主要说明一下我所遇到的问题以及解决方法。在安装过程中遇到Encountered an internal error，Install-parameter rhttpproxy.ext.port1 not set具体错误信息如下图所示：<br><img src="/images/2018-11-29_error.png" alt></p></blockquote><blockquote><p>出现这个错误后，会退出安装，在最后会报‘安装组件VCSServiceManager失败并显示错误代码1603’，如下图所示：<br><img src="/images/2018-11-29_error_code.png" alt><br>出现这个错误，首先应当排查在安装vCenter Server 过程中配置的http端口是否被占用(使用命令netstat -nao)，如果端口没有被占用，则使用如下方法：</p></blockquote><ol><li><p>删除C:\Program Files\VMware\vCenter Server目录；</p></li><li><p>重启虚拟机，重新安装</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这个方法不一定能解决所有这类问题，这只是其中一种解决方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>VMware虚拟机备份与恢复</title>
    <link href="https://weeweetan.github.io/2018/10/31/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
    <id>https://weeweetan.github.io/2018/10/31/VMware虚拟机备份与恢复/</id>
    <published>2018-10-31T08:05:03.000Z</published>
    <updated>2019-06-03T14:12:21.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文主要是根据自己实际项目经验对<a href="http://www.cnblogs.com/sammyliu/p/5661085.html" target="_blank" rel="noopener">云与备份之（1）：VMware虚机备份和恢复</a>这篇文章进行补充说明。本文将以部分引用，部分说明的方式进行组织，加粗部分为我自己总结的内容。<br>原文中提到两套SDK（vddk跟Web service SDK），整个虚拟机备份流程需要着两套SDK配合使用，我把这两套SDK整理了一下，使之能够在clion跟idea中运行，地址如下：<a href="https://github.com/weeweetan/VMwareProject" target="_blank" rel="noopener">VMwareProject</a><br><a href="https://github.com/weeweetan/vix_disklib_sample" target="_blank" rel="noopener">vix_disklib_sample</a></p></blockquote><h2 id="1-与备份有关的VMWare基础知识"><a href="#1-与备份有关的VMWare基础知识" class="headerlink" title="1. 与备份有关的VMWare基础知识"></a>1. 与备份有关的VMWare基础知识</h2><h3 id="1-1-VMware-虚机磁盘在-ESXi-宿主机上的文件"><a href="#1-1-VMware-虚机磁盘在-ESXi-宿主机上的文件" class="headerlink" title="1.1 VMware 虚机磁盘在 ESXi 宿主机上的文件"></a>1.1 VMware 虚机磁盘在 ESXi 宿主机上的文件</h3><blockquote><p>简单来说，虚机的每个虚拟磁盘由ESXi 宿主机上的三个文件组成（这里的虚机名字是 sammy-target-win-small，下面是其第一个磁盘对应的三个文件）：</p><ul><li>sammy-target-win-small.vmdk （配置文件，大小 633 字节）</li><li>sammy-target-win-small-flat.vmdk （二进制文件，大小 12884901888 字节）</li><li>sammy-target-win-small-ctk.vmdk （二进制文件，大小 78694 字节）<br>其中，</li></ul><p>第一个文件保存的是该磁盘的元数据，其中包括另外两个文件的信息</p><pre><code># Extent descriptionRW 25165824 VMFS &quot;sammy-target-win-small-flat.vmdk&quot;# Change Tracking FilechangeTrackPath=&quot;sammy-target-win-small-ctk.vmdk&quot;</code></pre><p>第二个文件是 Extent description 文件，二进制数据保存在这个文件中。下面会介绍使用API获取该文件中数据的方法。<br>第三个文件是 CTK 文件。下面讲到 CTK 的时候再说。</p><footer><strong>@刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)</strong></footer></blockquote><h3 id="1-2-虚拟磁盘类型"><a href="#1-2-虚拟磁盘类型" class="headerlink" title="1.2 虚拟磁盘类型"></a>1.2 虚拟磁盘类型</h3><blockquote><p>上一节中的磁盘组织形式并不是唯一的，早期版本的Esxi不是以这种方式组织。vddk文档中定义了8种磁盘类型，在创建虚拟磁盘时，使用不同磁盘类型，则虚拟磁盘的组织方式不同。8中磁盘类型如下：</p><ul><li>VIXDISKLIB_DISK_MONOLITHIC_SPARSE – Growable virtual disk contained in a single virtual disk file. This is the default type for hosted disk, and the only setting in the Virtual Disk API Sample Code sample program.</li><li>VIXDISKLIB_DISK_MONOLITHIC_FLAT – Preallocated virtual disk contained in a single virtual disk file. This takes time to create and occupies a lot of space, but might perform better than sparse.</li><li>VIXDISKLIB_DISK_SPLIT_SPARSE – Growable virtual disk split into 2GB extents ( s sequence). These files can to 2GB, then continue growing in a new extent. This type works on older file systems.</li><li>VIXDISKLIB_DISK_SPLIT_FLAT – Preallocated virtual disk split into 2GB extents ( f sequence). These files start at 2GB, so they take a while to create, but available space can grow in 2GB increments.</li><li>VIXDISKLIB_DISK_VMFS_FLAT – Preallocated virtual disk compatible with ESX 3 and later. Also known as thick disk. This managed disk type is discussed in Managed Disk and Hosted Disk.</li><li>VIXDISKLIB_DISK_VMFS_SPARSE – Employs a copy-on-write (COW) mechanism to save storage space.</li><li>VIXDISKLIB_DISK_VMFS_THIN – Growable virtual disk that consumes only as much space as needed, compatible with ESX 3 or later, supported by VDDK 1.1 or later, and highly recommended.</li><li>VIXDISKLIB_DISK_STREAM_OPTIMIZED – Monolithic sparse format compressed for streaming. Stream optimized format does not support random reads or writes.<br>只有vddk使用<em>VIXDISKLIB_DISK_VMFS_FLAT</em>类型创建虚拟磁盘时才会生成1.1节中所示的虚拟磁盘文件，使用Web Service SDK创建虚拟磁盘则不受此限制。</li></ul></blockquote><h3 id="1-3-虚拟磁盘模式"><a href="#1-3-虚拟磁盘模式" class="headerlink" title="1.3 虚拟磁盘模式"></a>1.3 虚拟磁盘模式</h3><blockquote><p>虚拟磁盘模式分为持久跟非持久，以下为vddk中对持久的定义</p><ul><li>持久模式(persistent)：In persistent disk mode, changes are immediately and permanently written to the virtual disk, so that they survive even through to the next power on.</li><li>非持久模式(nonpersistent)：In nonpersistent mode, changes to the virtual disk are discarded when the virtual machine powers off. The VMDK files revert to their original state.</li></ul></blockquote><blockquote><p>使用vSphere client创建虚拟磁盘跟vddk的选项可能会有区别</p><ul><li>独立持久：持久模式磁盘的行为与物理机上常规磁盘的行为相似。写入持久模式磁盘的所有数据都会永久性地写入磁盘。</li><li>独立非持久：关闭虚拟机电源或重置虚拟机时，对非持久模式磁盘的更改将丢失。使用非持久模式，您可以每次使用相同的虚拟磁盘状态重新启动虚拟机。对磁盘的更改会写入重做日志文件并从中读取，重做日志文件会在关闭虚拟机电源或重置虚拟机时被删除。</li></ul></blockquote><h3 id="1-4-vCenter-Server"><a href="#1-4-vCenter-Server" class="headerlink" title="1.4 vCenter Server"></a>1.4 vCenter Server</h3><blockquote><p>vCenter Server相当于一套管理多台Esxi服务器的系统，如果需要对虚拟机进行备份，则需要部署这么一套系统，具体怎么部署可以参考<a href="https://blog.csdn.net/shengxia1999/article/details/52353177" target="_blank" rel="noopener">VMware Vsphere 6.0安装部署 （三） vCenter Server安装</a>。备份所使用的Web serviceSDK依赖这套系统，对于这套系统的使用可以参考我其他关于vSphere的文章。</p></blockquote><h3 id="1-5-vSphere-Web-Client"><a href="#1-5-vSphere-Web-Client" class="headerlink" title="1.5 vSphere Web Client"></a>1.5 vSphere Web Client</h3><blockquote><p>vSphere Web Client为vCenter Server提供一个web管理界面，文中关于对vCenter的操作都是在这界面上完成。</p></blockquote><h3 id="1-5-虚拟机注册"><a href="#1-5-虚拟机注册" class="headerlink" title="1.5 虚拟机注册"></a>1.5 虚拟机注册</h3><blockquote><p>在vCenter Server中，Esxi服务器以及虚拟机以实体对象的形式存在，已有的虚拟机文件可以通过注册功能，将虚拟机文件激活成虚拟机，这里涉及到虚拟机的其他文件，可以参考<a href="https://docs.vmware.com/cn/VMware-vSphere/6.0/com.vmware.vsphere.vm_admin.doc/GUID-CEFF6D89-8C19-4143-8C26-4B6D6734D2CB.html" target="_blank" rel="noopener">什么是虚拟机?</a>。在vCenter Server中将.vmx文件作为虚拟机，所以在vCenter Server中找到虚拟机文件，右键注册就可以了。</p></blockquote><h2 id="2-备份要点"><a href="#2-备份要点" class="headerlink" title="2. 备份要点"></a>2. 备份要点</h2><blockquote><p>原文中对备份流程进行了详细说明，我这里就不再赘述，我将从以下几个方面说明备份要点。其中具体代码实现可以去<a href="https://blog.csdn.net/u013385554" target="_blank" rel="noopener">我的csdn</a>查看相关文章</p></blockquote><h3 id="2-1-如何确定虚拟机对象？"><a href="#2-1-如何确定虚拟机对象？" class="headerlink" title="2.1 如何确定虚拟机对象？"></a>2.1 如何确定虚拟机对象？</h3><blockquote><p>这个时候就需要使用Web service SDK去遍历vCenter Server中的虚拟机对象，并返回虚拟机的名称和在vCenter中的id，有了这两个变量，就可以确定虚拟机对象了。</p></blockquote><h3 id="2-2-如何获取虚拟机相关配置？"><a href="#2-2-如何获取虚拟机相关配置？" class="headerlink" title="2.2 如何获取虚拟机相关配置？"></a>2.2 如何获取虚拟机相关配置？</h3><blockquote><p>这一步中最重要的是拿到虚拟机磁盘对象，对虚拟机的备份，实际上是对虚拟磁盘的备份，这里还是使用Web ServiceSDk进行获取</p></blockquote><h3 id="2-3-如何获取变化数据？"><a href="#2-3-如何获取变化数据？" class="headerlink" title="2.3 如何获取变化数据？"></a>2.3 如何获取变化数据？</h3><blockquote><p>原文中有提到一个API：QueryChangedDiskAreas<br><blockquote><p>获取 CBT 变化块的函数的定义为：QueryChangedDiskAreas(snapshot, deviceKey, startOffSet, changeID)。其中，</p><ul><li>snapshot 代表当前的快照，也就是“变化”时间段的后端点；</li><li>deviceKey 是目标虚拟磁盘的 device ID；</li><li>startOffSet 是开始获取变化块的offset；</li><li>changeID 是指“变化”时间段的前端点，即老的快照的 changeID。<br>其结果类似 “(117768192, 65536),(132120576, 65536),(145096704, 43122688),(265289728, 65536),(958398464, 65536)”，每项的格式为 （offset，length），表示一个发生变化的数据块。</li></ul><footer><strong>@刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)</strong></footer></blockquote><br>使用QueryChangedDiskAreas获取到变化数据后，需要将这些数据保存下来，以供后续使用。</p></blockquote><h3 id="2-4-如何下载变化数据？"><a href="#2-4-如何下载变化数据？" class="headerlink" title="2.4 如何下载变化数据？"></a>2.4 如何下载变化数据？</h3><blockquote><p>这个时候就需要vddk，vddk可以连接到远程的虚拟磁盘，并根据上一节保存的数据，将虚拟磁盘中的变化数据读取并保存下来，以供恢复使用。</p></blockquote><h2 id="3-恢复要点"><a href="#3-恢复要点" class="headerlink" title="3. 恢复要点"></a>3. 恢复要点</h2><h3 id="3-1-完全恢复"><a href="#3-1-完全恢复" class="headerlink" title="3.1 完全恢复"></a>3.1 完全恢复</h3><blockquote><p>如果在完全备份的时候采用文件下载的形式进行备份，则在恢复的时候就可以直接将文件上传至vCenter Server然后注册虚拟机就可以了。如果备份的时候只备份了虚拟磁盘，则在恢复的时候需要使用Web Service SDK创建虚拟机，再将磁盘数据写入到新建的虚拟机中。</p></blockquote><h3 id="3-2-增量恢复"><a href="#3-2-增量恢复" class="headerlink" title="3.2 增量恢复"></a>3.2 增量恢复</h3><blockquote><p>增量恢复以完全恢复为前提，每个增量点依次恢复。</p></blockquote><h3 id="3-3-其他办法"><a href="#3-3-其他办法" class="headerlink" title="3.3 其他办法"></a>3.3 其他办法</h3><blockquote><p>如果业务十分紧急，则可以将备份的虚拟机文件以NFS的形式挂载到vCenter Server上，通过注册虚拟机的方式进行恢复。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要是根据自己实际项目经验对&lt;a href=&quot;http://www.cnblogs.com/sammyliu/
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>Java与PHP之间的Socket通信</title>
    <link href="https://weeweetan.github.io/2018/08/08/Java%E4%B8%8EPHP%E4%B9%8B%E9%97%B4%E7%9A%84Socket%E9%80%9A%E4%BF%A1/"/>
    <id>https://weeweetan.github.io/2018/08/08/Java与PHP之间的Socket通信/</id>
    <published>2018-08-08T15:55:23.000Z</published>
    <updated>2019-05-15T14:02:48.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java作为服务端"><a href="#Java作为服务端" class="headerlink" title="Java作为服务端"></a>Java作为服务端</h2><blockquote><p>Java端作为服务端，PHP端作为客户端，在之前一篇文章中说了下PHP作为客户端如何与Java端进行通信。由于业务需要，socket必须等待服务端处理完成，并返回处理结果给PHP端。在这里主要说明一下Java端如何处理的，不足之处，望指正。</p></blockquote><pre><code>ServerSocket serverSocket = new ServerSocket(port); //创建绑定到特定端口的服务器套接字Socket socket = serverSocket.accept(); //侦听并接受到此套接字的连接InputStream inputStream = socket.getInputStream();StringBuilder sb = new StringBuilder();byte[] packetLength = new byte[4];inputStream.read(packetLength, 0, 4);            //首先从套接字中读取4字节的数据长度int target = byteToint(packetLength);            //这里将字节数组转换成整数System.out.println(&quot;message size:&quot; + target);byte[] bytes = new byte[target];inputStream.read(bytes);                            //读取指定长度的数据sb.append(new String(bytes, 0, target, &quot;UTF-8&quot;));System.out.println(&quot;get message &quot; + sb);String result = &quot;has receive message&quot;;OutputStream outputStream = socket.getOutputStream();int responseLength =  result.getBytes().length;        //这个地方的长度，一定要是字节数组的长度，否则如果字符串中包含中文，接收端接收数据会不完整           byte[] targets = intTobyte(responseLength);outputStream.write(targets);                          //首先发送4个字节的数据大小outputStream.write(result.getBytes());                //再发送真正的数据outputStream.flush();outputStream.close();inputStream.close();socket.close();</code></pre><blockquote><p>上述代码需要处异常，而且代码中的byteToint和intTobyte这两个函数非原创，是其他博主的劳动成果，感谢这位作者，原文地址<em><a href="https://www.cnblogs.com/langren1992/p/4717241.html" target="_blank" rel="noopener">https://www.cnblogs.com/langren1992/p/4717241.html</a></em>。</p></blockquote><h2 id="PHP作为服务端"><a href="#PHP作为服务端" class="headerlink" title="PHP作为服务端"></a>PHP作为服务端</h2><blockquote><p>相关函数: socket_create、socket_set_block、socket_bind、socket_listen、socket_accept、socket_read、socket_write，这些函数具体参数说明在<a href="https://www.php.net/" target="_blank" rel="noopener">PHP文档</a>上写很详细，这里就不再赘述，这里只是介绍服务端如何处理请求。</p></blockquote><pre><code>//确保在连接客户端时不会超时set_time_limit(0);//设置IP和端口号$address = &quot;127.0.0.1&quot;;$port = 54321;$socketServer = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(&quot;socket_create() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);//设置为阻塞模式socket_set_block($socketServer) or die(&quot;socket_set_block() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);//绑定端口$result = socket_bind($socketServer, $address, $port) or die(&quot;socket_bind() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);//开始监听$result = socket_listen($socketServer, 4) or die(&quot;socket_listen() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);do {    //接收连接请求并返回一个子Socket来处理客户端和服务器间的信息    $sock = socket_accept($socketServer) or  die(&quot;socket_accept() failed: reason: &quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);    while($sock){        //读取客户端数据        echo &quot;Read client data \n&quot;;        $length = socket_read($sock, 4);        $length = unpack(&apos;i&apos;, $length);        echo &quot;length:$length[1]   \n&quot;;        $request = socket_read($sock, $length[1]);        echo &quot;$request:$request   \n&quot;;        //数据传送 向客户端写入返回结果        $msg = &quot;this is response message \n&quot;;        $msgLength = strlen($msg);        $msgLength = pack(&apos;i&apos;, $msgLength);        socket_write($sock, $msgLength);        socket_write($sock, $msg, strlen($msg)) or die(&quot;socket_write() failed: reason: &quot; . socket_strerror(socket_last_error()) .&quot;/n&quot;);        break;    }} while (true);//根据需要关闭socketsocket_close($socketServer);</code></pre><blockquote><p>在接收到客户端的请求后，可以结合PHP的多线程进行处理，这里只是简单的返回字符串。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>各大语言实现socket通信的方式都是大同小异，在服务端的流程都是差不多的。在有现成高性能socket通信框架的情况下，建议不要自己去实现，但是得理解框架底层是怎样实现的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java作为服务端&quot;&gt;&lt;a href=&quot;#Java作为服务端&quot; class=&quot;headerlink&quot; title=&quot;Java作为服务端&quot;&gt;&lt;/a&gt;Java作为服务端&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Java端作为服务端，PHP端作为客户端，在之前一篇文章中
      
    
    </summary>
    
      <category term="Socket" scheme="https://weeweetan.github.io/categories/Socket/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
      <category term="Socket" scheme="https://weeweetan.github.io/tags/Socket/"/>
    
      <category term="Java" scheme="https://weeweetan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>VMware vSphere WebService SDK使用心得</title>
    <link href="https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK使用心得/</id>
    <published>2018-07-25T12:13:58.000Z</published>
    <updated>2019-05-15T13:27:59.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="善用mob（Managed-Object-Browser）"><a href="#善用mob（Managed-Object-Browser）" class="headerlink" title="善用mob（Managed Object Browser）"></a>善用mob（Managed Object Browser）</h2><blockquote><p>mob地址一般是<em><a href="https://vcenter的FQDN/mob" target="_blank" rel="noopener">https://vcenter的FQDN/mob</a></em>，mob可以让你更好的理解SDK中的那些例子，以及根据自己的业务逻辑改写一些功能。下图为mob首页图，图中的content为整个Managed Object的顶层，从这里进去可以找到整个vcenter server中所有对象及其属性。<br><img src="/images/2018-07-25_mob.png" alt></p></blockquote><h2 id="善用GetMOREF类"><a href="#善用GetMOREF类" class="headerlink" title="善用GetMOREF类"></a>善用GetMOREF类</h2><blockquote><p>GetMOREF类具体位置在<em>VMware-vSphere-SDK-6.0.0-2561048\SDK\vsphere-ws\java\JAXWS\samples\com\vmware\connection\helpers</em>，这是VMware官方提供的一个工具类，里面的每个函数对于开发都很有用。例如</p></blockquote><pre><code>​List&lt;VirtualDevice&gt; listvd = ((ArrayOfVirtualDevice) getMOREFs                                .entityProps(vmMor, new String[] { &quot;config.hardware.device&quot; })                                .get(&quot;config.hardware.device&quot;)).getVirtualDevice();</code></pre><blockquote><p>这是VMReconfig.java中的一个片段，这段代码的作用就是去获取指定虚拟机对象的所有设备，vmMor可以通过GetMOREF类中的vmByVMname函数去获得。至于config.hardware.device，就需要用mob一层一层点进去看了，相信结合mob就能理解为什么要这么写。</p></blockquote><pre><code>​​ ManagedObjectReference propCol = connection.getServiceContent().getPropertyCollector(); ManagedObjectReference vmRef = getMOREFs.vmByVMname(virtualMachineName,propCol);</code></pre><blockquote><p>上面这段代码的作用就是如何根据虚拟机名去获取其对应的ManagedObjectReference</p></blockquote><h2 id="善用SDK里面的文档"><a href="#善用SDK里面的文档" class="headerlink" title="善用SDK里面的文档"></a>善用SDK里面的文档</h2><blockquote><p>文档首页为<em>VMware-vSphere-SDK-6.0.0-2561048/SDK/vsphere-ws/docs/ReferenceGuide/index.html</em><br><img src="/images/2018-07-25_doc.png" alt><br>根据需求，在左侧导航栏对应的去找。</p></blockquote><blockquote><p>对SDK我整理了一下，使其能够在idea中编译运行，项目地址在<a href="https://github.com/wulikanhua/VMwareProject" target="_blank" rel="noopener">VMwareProject</a>   ​</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;善用mob（Managed-Object-Browser）&quot;&gt;&lt;a href=&quot;#善用mob（Managed-Object-Browser）&quot; class=&quot;headerlink&quot; title=&quot;善用mob（Managed Object Browser）&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>Socket粘包处理</title>
    <link href="https://weeweetan.github.io/2018/07/25/Socket%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86/"/>
    <id>https://weeweetan.github.io/2018/07/25/Socket粘包处理/</id>
    <published>2018-07-25T11:05:52.000Z</published>
    <updated>2019-05-15T13:53:21.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据，并等待Java的响应结果，数据格式为JSON。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>PHP端发送数据后，Java端从socket里读取数据，但是一直读不到结束符。</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote><p>PHP需要调用socket_close函数才会向socket里面写入结束符。</p></blockquote><h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><blockquote><p><strong>PHP端与Java端之间确定每次发送数据包的长度，用4个字节表示数据长度，PHP端先发送数据包长度，再发送数据包，Java端先接收4个字节长度的数据包长度，再根据数据包长度接收数据包</strong>。PHP端代码如下:</p></blockquote><p>​</p><pre><code>$socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP  ) or die ( &apos;could not create socket&apos;  );  $connect = socket_connect ( $socket, &apos;xxx.xxx.xxx.xxx&apos;, xxxx);  //服务端发送数据 $arr = array(&quot;data&quot; =&gt; &quot;dadadada&quot;);$strlen = pack(&apos;i&apos;, strlen(json_encode($arr)));var_dump($strlen);socket_write ($socket, $strlen);socket_write ($socket, json_encode($arr), strlen(json_encode($arr)));$response = socket_read($socket, 4); $res = unpack(&apos;i&apos;, $response);var_dump($res);$response = socket_read($socket, $res[1]);var_dump($response);socket_close($socket);</code></pre><blockquote><p><a href="https://www.php.net/pack" target="_blank" rel="noopener">pack</a>与<a href="https://www.php.net/unpack" target="_blank" rel="noopener">unpack</a>函数使用说明见PHP官方文档    </p></blockquote><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据
      
    
    </summary>
    
      <category term="Socket" scheme="https://weeweetan.github.io/categories/Socket/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
      <category term="Socket" scheme="https://weeweetan.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>使用gcc编译驱动模块遇到的问题</title>
    <link href="https://weeweetan.github.io/2017/05/22/%E4%BD%BF%E7%94%A8gcc%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://weeweetan.github.io/2017/05/22/使用gcc编译驱动模块遇到的问题/</id>
    <published>2017-05-22T09:30:33.000Z</published>
    <updated>2019-05-17T15:43:16.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客<a href="http://bbs.chinaunix.net/thread-2017377-1-1.html" target="_blank" rel="noopener">写一个块设备驱动</a>学习，练习环境为centos6.5 gcc版本为6.3。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>跟着敲完那个简单的驱动程序后，发现编译出错，错误信息为</p></blockquote><pre><code>include/linux/compiler-gcc.h:89:30: fatal error: linux/compiler-gcc6.h: No such file or directory</code></pre><blockquote><p>一通百度，说gcc版本太高，去下载一个<em>compiler-gcc6.h</em>文件，放到内核源码文件夹里面，按着做了，结果编译又出问题了，错误信息为</p></blockquote><pre><code>include/linux/compiler.h:163:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void data_access_exceeds_word_size(void)include/linux/compiler.h:169:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void data_access_exceeds_word_size(void)include/linux/compiler.h:173:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void __read_once_size(volatile void *p, void *res, int size)include/linux/compiler.h:190:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void __write_once_size(volatile void *p, void *res, int size)</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>又是一通百度，发现跟我情况不符，看了下博客发表时间，08年，果断换了一个centos6.0的机器，gcc版本为4.6，编译完美通过,环境因素很重要啊。。。   </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="Linux" scheme="https://weeweetan.github.io/categories/Linux/"/>
    
    
      <category term="驱动模块" scheme="https://weeweetan.github.io/tags/%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="Linux" scheme="https://weeweetan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP脚本中使用exec总结</title>
    <link href="https://weeweetan.github.io/2017/02/20/PHP%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8exec%E6%80%BB%E7%BB%93/"/>
    <id>https://weeweetan.github.io/2017/02/20/PHP脚本中使用exec总结/</id>
    <published>2017-02-20T01:03:11.000Z</published>
    <updated>2019-05-17T15:54:50.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>总结一下这两天加班遇到的坑，由于本次任务涉及到在PHP中使用exec函数运行shell命令，并解析返回值。屁颠屁颠的写好代码，上传到服务器，服务器环境配置centos6.5+Nginx，ssh到服务器，在控制台运行php xxx.php结果完美显示。蛋疼的是前端调用脚本的时候，没有数据，返回false，一脸懵逼，开始想问题所在，试着在浏览器地址栏直接访问xxx.php没有结果。然后把代码改成</p></blockquote><pre><code>exec(&quot;ls 2&gt;&amp;1&quot;, $result);var_dump($result);</code></pre><blockquote><p>显示ls命令没找到，试着加上路径</p></blockquote><pre><code>exec(&quot;/bin/ls 2&gt;&amp;1&quot;, $result);var_dump($result);</code></pre><blockquote><p>显示权限不够。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>lsof -i:80 查看你Nginx的用户是谁，我这里是nginx</li><li>在脚本中添加file_put_contents(“/tmp/test.log”, “xxx”)查看test.log的用户是谁。我这里是nobody</li><li><p>在vim /etc/sudoers添加权限</p><p> nobody  ALL=(ALL)   NOPASSWD:ALL<br> nginx     ALL=(ALL)   NOPASSWD:ALL</p></li><li><p>重启nginx服务。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;总结一下这两天加班遇到的坑，由于本次任务涉及到在PHP中使用exec函数运行shell命令，并解析返回值。屁颠屁颠
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Esxi5.1挂载NFS存储遇到的问题及解决办法</title>
    <link href="https://weeweetan.github.io/2017/01/13/Esxi5-1%E6%8C%82%E8%BD%BDNFS%E5%AD%98%E5%82%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/</id>
    <published>2017-01-13T01:18:44.000Z</published>
    <updated>2019-05-18T01:20:29.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>如何配置NFS以及怎样在Esxi中添加NFS，可以参考<a href="https://www.linuxidc.com/Linux/2017-04/142686.htm" target="_blank" rel="noopener">VMware ESXI 5.5使用NFS添加存储器</a>, 我也是按照这个博客来配置的。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>遇到如下问题：<br><img src="/images/2017-01-13_nfs.jpg" alt></p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>必须要检查你的esxi主机是否配置了<em>VMkernel</em>，检查步骤如下：<br>1、使用 VI/vSphere Client 连接到 Virtual Center/vCenter Server。<br>2、选择 ESX/ESXi 主机。<br>3、单击配置选项卡。<br>4、单击网络。<br>5、查看 VMKernel 的网络图，或单击属性 &gt; 端口 &gt; VMKernel。如果 VMKernel 未列出，必须添加它。</p></blockquote><h2 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h2><blockquote><p>手动挂载命令：</p></blockquote><pre><code>esxcli storage nfs add -H NFS_IP|NFS_HOSTNAME -s Share_mount_point_on_the_NFS -v DatastoreName</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p><strong>必须保证esxi主机与NFS服务器在同一网段或者能够相互通信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如何配置NFS以及怎样在Esxi中添加NFS，可以参考&lt;a href=&quot;https://www.linuxidc.
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>linux下编译vddk例程的错误总结</title>
    <link href="https://weeweetan.github.io/2016/11/10/linux%E4%B8%8B%E7%BC%96%E8%AF%91vddk%E4%BE%8B%E7%A8%8B%E7%9A%84%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://weeweetan.github.io/2016/11/10/linux下编译vddk例程的错误总结/</id>
    <published>2016-11-10T09:29:27.000Z</published>
    <updated>2019-05-18T02:28:46.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>vddk是<em>visual disk development kit</em>的缩写，是VMware vSphere提供的可用来操作虚拟磁盘的一套SDK，具体可看<a href="https://www.vmware.com/support/developer/vddk/" target="_blank" rel="noopener">VDDK Document</a>，在这里记录一下编译问题。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>按照官方文档编译vixDiskLibSample.cpp时报错</p></blockquote><pre><code>Package vix-disklib was not found in the pkg-config search path.Perhaps you should add the directory containing `vix-disklib.pc&apos;to the PKG_CONFIG_PATH environment variableNo package &apos;vix-disklib&apos; found</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>按照官方文档的说明编辑~/.bash_profile,添加如下内容：</p></blockquote><pre><code>PKG_CONFIG_PATH=/usr/lib/pkgconfigexport PKG_CONFIG_PATHLD_LIBRARY_PATH=/usr/lib/vmware-vix-disklib/lib64export LD_LIBRARY_PATH</code></pre><blockquote><p>其中/usr/lib/vmware-vix-disklib/lib64是vddk安装后，默认的lib路径，添加完成后执行</p></blockquote><pre><code>source bash_profile</code></pre><blockquote><p>再次编译就成功了        </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;vddk是&lt;em&gt;visual disk development kit&lt;/em&gt;的缩写，是VMware vSph
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
      <category term="vddk" scheme="https://weeweetan.github.io/tags/vddk/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://weeweetan.github.io/2016/08/05/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://weeweetan.github.io/2016/08/05/Linux常用命令/</id>
    <published>2016-08-05T13:58:21.000Z</published>
    <updated>2019-06-05T06:27:23.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><blockquote><p>1、使用u退回上一步<br>2、使用U一次撤销对当前行的全部操作<br>3、vim + filename 表示把光标定位到文件最后一行<br>4、vim +数字 filemame 定位到数字行，如果超过文件行数，定位到最后一行<br>5、vim +/word filename 定位到Word第一次出现的行，按n切换<br>6、vim file1 file2 file3 一次性打开或者创建多个文件，底行模式下使用:n向后切换文件，:N和prev向前切换文件<br>7、:w  save<br>:q  quit<br>:!  强制<br>:ls   列出当前编辑器打开的所有文件<br>:n 切换到下一个文件<br>:N 切换到前一个文件<br>:15 定位到15行<br>:/xxx 表示从光标位置向后搜索xxx,定位到第一次出现的时候<br>:?xxx搜索<br>8、命令行模式常用命令<br>h 光标左移<br>j 光标下移<br>k 光标上移<br>l 光标右移<br>Ctrl+f 向下翻页（front）<br>Ctrl+b 向上翻页（back）<br>Ctrl+d 向下翻半页（down）<br>Ctrl+u 向上翻半页（up）</p></blockquote><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><blockquote><p>查看磁盘分区使用状况<br>   -l 仅显示本地磁盘（默认）<br>   -a 显示所有文件系统的磁盘使用情况<br>   -h 以1024进制计算最适合的单位显示磁盘容量<br>   -H 以1000进制计算最适合的单位显示磁盘容量<br>   -T 显示磁盘分区类型<br>   -t 显示指定类型文件系统的磁盘分区<br>   -x 不显示指定类型文件系统的磁盘分区</p></blockquote><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><blockquote><p>统计磁盘上的文件大小<br>   -b 以byte为单位统计文件<br>   -k 以KB为单位统计文件<br>   -m 以MB为单位统计文件<br>   -h 按照1024进制以最适合的单位统计文件<br>   -H 按照1000进制以最适合的单位统计文件<br>   -s 指定统计目标   </p></blockquote><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><blockquote><p>可以列出被进程所打开的文件的信息。被打开的文件可以是<br>1.普通的文件<br>2.目录<br>3.网络文件系统的文件<br>4.字符设备文件<br>5.(函数)共享库<br>6.管道，命名管道<br>7.符号链接<br>8.底层的socket字流，网络socket，unix域名socket<br>9.在linux里面，大部分的东西都是被当做文件的…..还有其他很多</p></blockquote><h3 id="怎样使用lsof"><a href="#怎样使用lsof" class="headerlink" title="怎样使用lsof"></a>怎样使用lsof</h3><blockquote><p>这里主要用案例的形式来介绍lsof 命令的使用</p><ol><li>列出所有打开的文件:<br>lsof<br>备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位</li><li>查看谁正在使用某个文件<br>lsof   /filepath/file</li><li>递归查看某个目录的文件信息<br>lsof +D /filepath/filepath2/<br>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</li><li>比使用+D选项，遍历查看某个目录的所有文件信息 的方法<br>lsof | grep ‘/filepath/filepath2/’</li><li>列出某个用户打开的文件信息<br>lsof  -u username<br>备注: -u 选项，u其实是user的缩写</li><li>列出某个程序所打开的文件信息<br>lsof -c mysql<br>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成lsof | grep mysql,但是第一种方法明显比第二种方法要少打几个字符了</li><li>列出多个程序多打开的文件信息<br>lsof -c mysql -c apache</li><li>列出某个用户以及某个程序所打开的文件信息<br>lsof -u test -c mysql</li><li>列出除了某个用户外的被打开的文件信息<br>lsof   -u ^root<br>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</li><li>通过某个进程号显示该进行打开的文件<br>lsof -p 1</li><li>列出多个进程号对应的文件信息<br>lsof -p 123,456,789</li><li>列出除了某个进程号，其他进程号所打开的文件信息<br>lsof -p ^1<br>13 . 列出所有的网络连接<br>lsof -i</li><li>列出所有tcp 网络连接信息<br>lsof  -i tcp</li><li>列出所有udp网络连接信息<br>lsof  -i udp</li><li>列出谁在使用某个端口<br>lsof -i :3306</li><li>列出谁在使用某个特定的udp端口<br>lsof -i udp:55<br>特定的tcp端口<br>lsof -i tcp:80</li><li>列出某个用户的所有活跃的网络端口<br>lsof  -a -u test -i</li><li>列出所有网络文件系统<br>lsof -N</li><li>域名socket文件<br>lsof -u</li><li>某个用户组所打开的文件信息<br>lsof -g 5555</li><li>根据文件描述列出对应的文件信息<br>lsof -d description(like 2)</li><li>根据文件描述范围列出文件信息<br>lsof -d 2-3</li></ol></blockquote><h2 id="top系列"><a href="#top系列" class="headerlink" title="top系列"></a>top系列</h2><h3 id="iotop-–-I-O-监控"><a href="#iotop-–-I-O-监控" class="headerlink" title="iotop – I/O 监控"></a>iotop – I/O 监控</h3><blockquote><p>iotop 命令利用 Linux 内核监控 I/O 使用情况，它按进程或线程的顺序显示 I/O 使用情况。</p></blockquote><h3 id="htop-–-交互式的进程查看器"><a href="#htop-–-交互式的进程查看器" class="headerlink" title="htop – 交互式的进程查看器"></a>htop – 交互式的进程查看器</h3><blockquote><p>htop 是一款免费并开源的基于 ncurses 的 Linux 进程查看器。它比 top 命令更简单易用。您无需使用 PID、无需离开 htop 界面，便可以杀掉进程或调整其调度优先级。</p></blockquote><h3 id="atop-–-高级版系统与进程监控工具"><a href="#atop-–-高级版系统与进程监控工具" class="headerlink" title="atop – 高级版系统与进程监控工具"></a>atop – 高级版系统与进程监控工具</h3><blockquote><p>atop 是一个非常强大的交互式 Linux 系统负载监控器，它从性能的角度显示最关键的硬件资源信息。您可以快速查看 CPU、内存、磁盘和网络性能。它还可以从进程的级别显示哪些进程造成了相关 CPU 和内存的负载。</p></blockquote><h3 id="iftop-–-显示主机上网络接口的带宽使用情况"><a href="#iftop-–-显示主机上网络接口的带宽使用情况" class="headerlink" title="iftop – 显示主机上网络接口的带宽使用情况"></a>iftop – 显示主机上网络接口的带宽使用情况</h3><blockquote><p>iftop 命令监听指定接口（如 eth0）上的网络通信情况。它显示了一对主机的带宽使用情况。</p></blockquote><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><blockquote><p>虚拟内存统计<br>显示 Slab 缓存的利用率</p></blockquote><pre><code>vmstat -m</code></pre><blockquote><p>获取有关活动和非活动内存页面的信息</p></blockquote><pre><code>vmstat -a   </code></pre><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><h3 id="高亮搜索关键字"><a href="#高亮搜索关键字" class="headerlink" title="高亮搜索关键字"></a>高亮搜索关键字</h3><blockquote><p>step1:修改~/.bashrc，在~/.bashrc中添加如下内容<br>alias grep=’grep –color=auto’<br>step2:重新加载.bashrc文件<br>source ~/.bashrc</p></blockquote><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><blockquote><p>-a ：all，表示列出所有的连接，服务监听，Socket资料<br>-t ：tcp，列出tcp协议的服务<br>-u ：udp，列出udp协议的服务<br>-n ：port number， 用端口号来显示<br>-l ：listening，列出当前监听服务<br>-p ：program，列出服务程序的PID</p></blockquote><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><blockquote><p>显示长输出格式</p></blockquote><pre><code># ps -Al</code></pre><blockquote><p>显示完整输出格式（它将显示传递给进程的命令行参数）</p></blockquote><pre><code># ps -AlF</code></pre><blockquote><p>显示线程（轻量级进程（LWP）和线程的数量（NLWP））</p></blockquote><pre><code># ps -AlFH</code></pre><blockquote><p>在进程后显示线程</p></blockquote><pre><code># ps -AlLm</code></pre><blockquote><p>显示系统上所有的进程</p></blockquote><pre><code># ps ax# ps aux</code></pre><blockquote><p>显示进程树</p></blockquote><pre><code># ps -ejH# ps axjf# pstree</code></pre><blockquote><p>显示进程的安全信息</p></blockquote><pre><code># ps -eo euser,ruser,suser,fuser,f,comm,label# ps axZ# ps -eM</code></pre><blockquote><p>显示指定用户（如 vivek）运行的进程</p></blockquote><pre><code># ps -U vivek -u vivek u</code></pre><blockquote><p>设置用户自定义的输出格式</p></blockquote><pre><code># ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm# ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm# ps -eopid,tt,user,fname,tmout,f,wchan</code></pre><blockquote><p>显示某进程（如 lighttpd）的 PID</p></blockquote><pre><code># ps -C lighttpd -o pid=</code></pre><blockquote><p>或</p></blockquote><pre><code># pgrep lighttpd</code></pre><blockquote><p>或</p></blockquote><pre><code># pgrep -u vivek php-cgi</code></pre><blockquote><p>显示指定 PID（如 55977）的进程名称</p></blockquote><pre><code># ps -p 55977 -o comm=</code></pre><blockquote><p>找出占用内存资源最多的前 10 个进程</p></blockquote><pre><code># ps -auxf | sort -nr -k 4 | head -10</code></pre><blockquote><p>找出占用 CPU 资源最多的前 10 个进程</p></blockquote><pre><code># ps -auxf | sort -nr -k 3 | head -10</code></pre><p>##ss</p><blockquote><p>ss 命令用于获取套接字统计信息。它可以显示类似于 netstat 的信息。不过 netstat 几乎要过时了，ss 命令更具优势。要显示所有 TCP 或 UDP 套接字：</p></blockquote><pre><code># ss -t -a</code></pre><p>或</p><pre><code># ss -u -a</code></pre><blockquote><p>显示所有带有 SELinux 安全上下文Security Context的 TCP 套接字：</p></blockquote><pre><code># ss -t -a -Z </code></pre><h2 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h2><blockquote><p>pmap 命令用以显示进程的内存映射，使用此命令可以查找内存瓶颈。</p></blockquote><pre><code># pmap -d PID</code></pre><blockquote><p>显示 PID 为 47394 的进程的内存信息，请输入：</p></blockquote><pre><code># pmap -d 47394     </code></pre><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><blockquote><p>?sar 命令用于收集、汇报和保存系统活动信息。要查看网络统计，请输入：</p></blockquote><pre><code># sar -n DEV | more</code></pre><blockquote><p>显示 24 日的网络统计：</p></blockquote><pre><code># sar -n DEV -f /var/log/sa/sa24 | more</code></pre><blockquote><p>显示实时使用情况：</p></blockquote><pre><code># sar 4 5     </code></pre><h2 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h2><blockquote><p>mpstat 命令显示每个可用处理器的使用情况，编号从 0 开始。命令 mpstat -P ALL 显示了每个处理器的平均使用率：</p></blockquote><pre><code># mpstat -P ALL     </code></pre><h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><blockquote><p>显示了当前登录在该系统上的用户及其进程。</p></blockquote><pre><code># w username    </code></pre><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><blockquote><p>tcpdump 命令是简单的分析网络通信的命令。您需要充分了解 TCP/IP 协议才便于使用此工具。例如，要显示有关 DNS 的流量信息，请输入：</p></blockquote><pre><code># tcpdump -i eth1 &apos;udp port 53&apos;</code></pre><blockquote><p>查看所有去往和来自端口 80 的 IPv4 HTTP 数据包，仅打印真正包含数据的包，而不是像 SYN、FIN 和仅含 ACK 这类的数据包，请输入：</p></blockquote><pre><code># tcpdump &apos;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&apos;</code></pre><blockquote><p>显示所有目标地址为 202.54.1.5 的 FTP 会话，请输入：</p></blockquote><pre><code># tcpdump -i eth1 &apos;dst 202.54.1.5 and (port 21 or 20&apos;</code></pre><blockquote><p>打印所有目标地址为 192.168.1.5 的 HTTP 会话：</p></blockquote><pre><code># tcpdump -ni eth0 &apos;dst 192.168.1.5 and tcp and port http&apos;</code></pre><blockquote><p>使用 wireshark 查看文件的详细内容，请输入：</p></blockquote><pre><code># tcpdump -n -i eth1 -s 0 -w output.txt src or dst port 80    </code></pre><h2 id="lsb-release"><a href="#lsb-release" class="headerlink" title="lsb_release"></a>lsb_release</h2><blockquote><p>lsb_release是读取/etc/redhat-release文件中的第一行记录，这里面记载了系统版本 </p></blockquote><h2 id><a href="#" class="headerlink" title="!"></a>!</h2><blockquote><p><strong>!</strong>在Linux命令行中有特色含义，即感叹号后面的内容会被截断，所以如果需要将感叹号当作普通字符处理，需要使用单引号，如下：</p></blockquote><pre><code>echo &quot;hello world&apos;!&apos;&quot;</code></pre><h2 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h2><blockquote><p>fdisk只能给磁盘做MBR分区，MBR只能有四个主分区，每个分区最大2TB</p></blockquote><h2 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h2><blockquote><p>parted既可以做MBR分区也可以做GPT分区，GPT几乎没有分区限制，也没有大小限制   </p></blockquote><h2 id="ntpdate"><a href="#ntpdate" class="headerlink" title="ntpdate"></a>ntpdate</h2><blockquote><p>ntpdate命令是用来设置本地日期和时间。它从指定的每个服务器获得了一些样本，并应用标准 NTP 时钟过滤器和选择算法来选择最好的样本。<br>可使用如下命令进行网络时间更新</p></blockquote><pre><code>ntpdate -u ntp.api.bz</code></pre><blockquote><p>-u参数可以越过防火墙与主机同步；ntp.api.bz：NTP服务器(上海)。        </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vim&quot;&gt;&lt;a href=&quot;#vim&quot; class=&quot;headerlink&quot; title=&quot;vim&quot;&gt;&lt;/a&gt;vim&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1、使用u退回上一步&lt;br&gt;2、使用U一次撤销对当前行的全部操作&lt;br&gt;3、vim + filename 
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Linux" scheme="https://weeweetan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>centos6.5下lamp环境部署laravel</title>
    <link href="https://weeweetan.github.io/2016/07/31/centos6-5%E4%B8%8Blamp%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2laravel/"/>
    <id>https://weeweetan.github.io/2016/07/31/centos6-5下lamp环境部署laravel/</id>
    <published>2016-07-31T13:54:35.000Z</published>
    <updated>2019-05-18T13:56:16.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装composer，命令如下"><a href="#安装composer，命令如下" class="headerlink" title="安装composer，命令如下"></a>安装composer，命令如下</h2><pre><code>curl -sS https://getcomposer.org/installer | phpmv composer.phar /usr/local/bin/composerchmod +x /usr/local/bin/composer </code></pre><h2 id="切换到Apache默认目录下"><a href="#切换到Apache默认目录下" class="headerlink" title="切换到Apache默认目录下"></a>切换到Apache默认目录下</h2><pre><code>cd /var/www/composer create-project laravel/laravel --prefer-dist &quot;5.1.11&quot;composer install</code></pre><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><pre><code>cd laravelchmod -R 777 storage/</code></pre><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><pre><code>vim/etc/httpd/conf/httpd.conf</code></pre><blockquote><p>把<em>DocumentRoot “/var/www/html”</em>改为<em>DocumentRoot “/var/www/laravel/public”</em></p></blockquote><h2 id="重启Apache服务"><a href="#重启Apache服务" class="headerlink" title="重启Apache服务"></a>重启Apache服务</h2><pre><code>service httpd restart</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装composer，命令如下&quot;&gt;&lt;a href=&quot;#安装composer，命令如下&quot; class=&quot;headerlink&quot; title=&quot;安装composer，命令如下&quot;&gt;&lt;/a&gt;安装composer，命令如下&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;curl -sS h
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
      <category term="Laravel" scheme="https://weeweetan.github.io/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见问题</title>
    <link href="https://weeweetan.github.io/2016/05/22/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://weeweetan.github.io/2016/05/22/MySQL常见问题/</id>
    <published>2016-05-22T05:55:31.000Z</published>
    <updated>2019-05-25T15:38:28.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改目录后MySQL无法启动"><a href="#修改目录后MySQL无法启动" class="headerlink" title="修改目录后MySQL无法启动"></a>修改目录后MySQL无法启动</h2><blockquote><p>这种问题一般是selinux造成的<br>1、终端输入sestatus，如出现SELinux status:                 enabled，则selinux为开启状态，<br>2、编辑/etc/selinux/config 文件，将SELINUX=enforcing改为SELINUX=disabled，重启机器</p></blockquote><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><blockquote><p>修改密码分为两种情况，一种情况是拥有原来密码，另外一种情况则是忘记密码</p></blockquote><h3 id="拥有原来的myql的root的密码；"><a href="#拥有原来的myql的root的密码；" class="headerlink" title="拥有原来的myql的root的密码；"></a>拥有原来的myql的root的密码；</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><blockquote><p>在mysql系统外，使用mysqladmin</p></blockquote><pre><code># mysqladmin -u root -p password &quot;test123&quot;Enter password: 【输入原来的密码】</code></pre><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><blockquote><p>通过登录mysql系统，</p></blockquote><pre><code># mysql -uroot -pEnter password: 【输入原来的密码】mysql&gt;use mysql;mysql&gt; update user set password=password(&quot;test&quot;) where user=&apos;root&apos;;mysql&gt; flush privileges;mysql&gt; exit;      </code></pre><h3 id="忘记原来的myql的root的密码；"><a href="#忘记原来的myql的root的密码；" class="headerlink" title="忘记原来的myql的root的密码；"></a>忘记原来的myql的root的密码；</h3><blockquote><p>首先，你必须要有操作系统的root权限了。要是连系统的root权限都没有的话，先考虑root系统再走下面的步骤。<br>类似于安全模式登录系统，有人建议说是pkill mysql，但是我不建议哈。因为当你执行了这个命令后，会导致这样的状况：<br>/etc/init.d/mysqld status<br>mysqld dead but subsys locked<br>这样即使你是在安全模式下启动mysql都未必会有用的，所以一般是这样/etc/init.d/mysqld stop，如果你不幸先用了pkill，那么就start一下再stop咯。</p></blockquote><pre><code># mysqld_safe --skip-grant-tables &amp;</code></pre><blockquote><p>&amp;，表示在后台运行，不再后台运行的话，就再打开一个终端咯。</p></blockquote><pre><code># mysqlmysql&gt; use mysql;mysql&gt; UPDATE user SET password=password(&quot;test123&quot;) WHERE user=&apos;root&apos;;   mysql&gt; flush privileges;mysql&gt; exit;                         </code></pre><blockquote><p>本来mysql是不分大小写的，但是这个是修改的mysql中的mysql数据库的具体的值，要注意到。</p></blockquote><h2 id="插入10万条记录的SQL"><a href="#插入10万条记录的SQL" class="headerlink" title="插入10万条记录的SQL"></a>插入10万条记录的SQL</h2><pre><code>drop table if exists foo;create table foo(id int unsigned not null auto_increment primary key,val smallint unsigned not null default 0)engine=innodb;drop procedure if exists load_foo_test_data;delimiter #create procedure load_foo_test_data()begindeclare v_max int unsigned default 100000;declare v_counter int unsigned default 0;  truncate table foo;  start transaction;  while v_counter &lt; v_max do    insert into foo (val) values ( floor(0 + (rand() * 65535)) );    set v_counter=v_counter+1;  end while;  commit;end #delimiter ;call load_foo_test_data();</code></pre><h2 id="MySQL开启远程访问"><a href="#MySQL开启远程访问" class="headerlink" title="MySQL开启远程访问"></a>MySQL开启远程访问</h2><blockquote><ol><li>选择mysql库，选user表 新增用户</li></ol></blockquote><pre><code>mysql&gt; insert into user(Host,User,Password) values(&apos;%&apos;,&apos;用户名（必须是英文数字）&apos;,&apos;密码&apos;);</code></pre><blockquote><p>刷新权限</p></blockquote><pre><code>mysql&gt;flush privileges;</code></pre><blockquote><ol start="2"><li>授权给新增的用户</li></ol></blockquote><pre><code>mysql&gt; Grant all privileges on *.* to &apos;用户名&apos;@&apos;%&apos; identified by &apos;密码&apos; with grant option;</code></pre><blockquote><p>注释：其中：“ <em>.</em> ”代表所有数据库和表（也就是root权限） 其格式为:数据库名称 . 表名<br>刷新权限</p></blockquote><pre><code>mysql&gt;flush privileges;</code></pre><h2 id="数据库优化十个原则"><a href="#数据库优化十个原则" class="headerlink" title="数据库优化十个原则"></a>数据库优化十个原则</h2><blockquote><ol><li>尽量避免在列上进行计算，这样会导致索引失效</li></ol></blockquote><pre><code>select * from t where year(d)&gt;=2011   =&gt;   select * from t where d&gt;=&apos;2011-01-01&apos;;</code></pre><blockquote><ol start="2"><li>使用join时，应该用小结果集驱动大结果集。同时把复杂的join查询拆分成多个query。因为join多个表时，可能导致更多的锁定和堵塞。</li><li>注意like模糊查询的使用，避免%%。</li><li>仅列出需要查询的字段，这对速度不会又明显的影响，主要考虑节省内存。</li><li>使用批量插入语句节省交互。</li><li>limit的基数比较大时使用between。</li><li>不要使用rand函数获取多条随机记录。</li><li>避免使用null</li><li>不要使用count(id),而应该是count(*)</li><li>不要做所谓的排序操作，而应尽可能在索引中完成排序。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;修改目录后MySQL无法启动&quot;&gt;&lt;a href=&quot;#修改目录后MySQL无法启动&quot; class=&quot;headerlink&quot; title=&quot;修改目录后MySQL无法启动&quot;&gt;&lt;/a&gt;修改目录后MySQL无法启动&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这种问题一般是se
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="MySQL" scheme="https://weeweetan.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
