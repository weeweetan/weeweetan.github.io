<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>weeweetan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weeweetan.github.io/"/>
  <updated>2019-05-17T15:29:49.734Z</updated>
  <id>https://weeweetan.github.io/</id>
  
  <author>
    <name>weeweetan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言编程常见错误</title>
    <link href="https://weeweetan.github.io/2019/05/17/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <id>https://weeweetan.github.io/2019/05/17/C语言编程常见错误/</id>
    <published>2019-05-17T15:21:03.000Z</published>
    <updated>2019-05-17T15:29:49.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用close函数出现bad-file-descriptor错误"><a href="#使用close函数出现bad-file-descriptor错误" class="headerlink" title="使用close函数出现bad file descriptor错误"></a>使用close函数出现bad file descriptor错误</h2><blockquote><p>出现这种错误一般是两次close导致，仔细检查代码，调用close关闭文件描述符后，应该将文件描述符置为0，避免重复调用close，切记切记。</p></blockquote><h2 id="守护程序闪退问题"><a href="#守护程序闪退问题" class="headerlink" title="守护程序闪退问题"></a>守护程序闪退问题</h2><blockquote><p>出现这个问题一般是两次释放同一块内存，仔细检查释放内存与指针赋值相关代码，释放内存后，应将指针置为NULL，避免重复调用close，切记切记。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用close函数出现bad-file-descriptor错误&quot;&gt;&lt;a href=&quot;#使用close函数出现bad-file-descriptor错误&quot; class=&quot;headerlink&quot; title=&quot;使用close函数出现bad file descript
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="C" scheme="https://weeweetan.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx学习笔记</title>
    <link href="https://weeweetan.github.io/2019/05/08/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://weeweetan.github.io/2019/05/08/Nginx学习笔记/</id>
    <published>2019-05-08T02:49:55.000Z</published>
    <updated>2019-05-15T07:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h2><h3 id="configure原理"><a href="#configure原理" class="headerlink" title="configure原理"></a>configure原理</h3><blockquote><p>configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。</p></blockquote><h3 id="auto脚本"><a href="#auto脚本" class="headerlink" title="auto脚本"></a>auto脚本</h3><blockquote><p>auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：<br><img src="/images/2019-05-13_nginx.png" alt><br>上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。</p></blockquote><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><blockquote><p>在<em>ngx_module.h</em>中引用了两个至关重要的外部变量</p></blockquote><pre><code>extern ngx_module_t  *ngx_modules[];extern char          *ngx_module_names[];</code></pre><blockquote><p><em>ngx_modules</em>跟<em>ngx_module_names</em>定义在<em>ngx_modules.c</em>中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用<em>ngx_cycle_modules</em>函数，原型如下：</p></blockquote><pre><code>ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle)</code></pre><blockquote><p>此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下：</p></blockquote><pre><code>main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules</code></pre><h2 id="handler模块的编写步骤"><a href="#handler模块的编写步骤" class="headerlink" title="handler模块的编写步骤"></a>handler模块的编写步骤</h2><ol><li><p>编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量：</p><p> static ngx_command_t ngx_http_module_name_commands[] = {};<br> static ngx_http_module_t ngx_http_module_name_module_ctx = {};<br> ngx_module_t ngx_http_module_name_module = {};</p></li><li><p>实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数：</p><p> static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)；</p></li><li><p>编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数：</p><p> static ngx_int_t ngx_http_module_name_handler(ngx_http_request_t *r);</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编译步骤&quot;&gt;&lt;a href=&quot;#编译步骤&quot; class=&quot;headerlink&quot; title=&quot;编译步骤&quot;&gt;&lt;/a&gt;编译步骤&lt;/h2&gt;&lt;h3 id=&quot;configure原理&quot;&gt;&lt;a href=&quot;#configure原理&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>libxml2使用心得</title>
    <link href="https://weeweetan.github.io/2019/05/04/libxml2%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2019/05/04/libxml2使用心得/</id>
    <published>2019-05-04T14:21:35.000Z</published>
    <updated>2019-05-15T07:04:26.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考<a href="http://www.blogjava.net/wxb_nudt/archive/2007/11/18/161340.html" target="_blank" rel="noopener">C++的XML编程经验――LIBXML2库使用指南</a>，这篇博文讲得很详细，我在这里只是做出一点补充。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。</p></blockquote><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><blockquote><p>我使用GLib2的<em>g_locale_from_utf8</em>将内容转换为本地程序默认的编码格式，在写入xml内容时使用<em>g_locale_to_utf8</em>将内容转换为UTF-8.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有
      
    
    </summary>
    
      <category term="libxml" scheme="https://weeweetan.github.io/categories/libxml/"/>
    
    
      <category term="libxml" scheme="https://weeweetan.github.io/tags/libxml/"/>
    
  </entry>
  
  <entry>
    <title>GLib使用心得</title>
    <link href="https://weeweetan.github.io/2019/04/28/GLib%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2019/04/28/GLib使用心得/</id>
    <published>2019-04-28T05:51:59.000Z</published>
    <updated>2019-05-18T01:23:41.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>关于GLib的介绍这里就不赘述了，具体API介绍可以去<a href="https://developer.gnome.org/glib/" target="_blank" rel="noopener">GLib API Reference</a>查阅，这里只是记录一下使用相关API所遇到的一些坑。</p></blockquote><h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><h3 id="字符串相关API"><a href="#字符串相关API" class="headerlink" title="字符串相关API"></a>字符串相关API</h3><pre><code>GString *g_string_new(const gchar *init);GString *g_string_append(GString *string, const gchar *val);GString *g_string_prepend(GString *string, const gchar *val);gchar *g_string_free(GString *string, gboolean free_segment);</code></pre><blockquote><p>如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。<strong>注意</strong> g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。<br><em>g_string_append</em>跟<em>g_string_prepend</em>都是直接在原字符串上操作，这点要切记。</p></blockquote><h3 id="字符转换相关API"><a href="#字符转换相关API" class="headerlink" title="字符转换相关API"></a>字符转换相关API</h3><pre><code>gchar *g_filename_display_basename(const gchar *filename);gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);</code></pre><blockquote><p>g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码<br>g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件<br>g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8<br>下面看个例子, 比如我们有个含中文的文件名 <em>/data/test/哈哈.txt</em>如果想获得 <em>哈哈.txt</em>，则必须首先使用 <em>g_locale_to_utf8</em>函数转换一次, 然后再去获取basename</p></blockquote><pre><code>GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;);gchar *str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL);gchar *basename = g_filename_display_basename(str);</code></pre><blockquote><p>如果想使用GString *类型保存basename，则必须重新申请内存块</p></blockquote><pre><code>GString *basename_string = g_string_new(basename); </code></pre><blockquote><p>千万别像下面这样做</p></blockquote><pre><code>GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;);string-&gt;str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); </code></pre><blockquote><p>如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，<em>g_locale_from_utf8</em> 同理<br><strong>注意</strong> <em>g_locale_to_utf8</em>返回的char *需要手动释放内存</p></blockquote><h3 id="解析key-value文件API"><a href="#解析key-value文件API" class="headerlink" title="解析key-value文件API"></a>解析key-value文件API</h3><pre><code>GKeyFile *g_key_file_new(void);gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name,  const gchar *key, GError **error);gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);void g_key_file_free(GKeyFile *key_file);</code></pre><blockquote><p>这几个API很好理解,用来解析具有键值对特征的文件,<em>g_key_file_new</em>跟<em>g_key_file_free</em>配套使用;<br>g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;关于GLib的介绍这里就不赘述了，具体API介绍可以去&lt;a href=&quot;https://developer.gno
      
    
    </summary>
    
      <category term="GLib" scheme="https://weeweetan.github.io/categories/GLib/"/>
    
    
      <category term="GLib" scheme="https://weeweetan.github.io/tags/GLib/"/>
    
  </entry>
  
  <entry>
    <title>调用glib库出现0xc000007b解决办法</title>
    <link href="https://weeweetan.github.io/2019/04/18/%E8%B0%83%E7%94%A8glib%E5%BA%93%E5%87%BA%E7%8E%B00xc000007b%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/</id>
    <published>2019-04-18T14:47:29.000Z</published>
    <updated>2019-05-18T01:22:38.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示：<br><img src="/images/2019-04-18_glib_1.png" alt></p></blockquote><blockquote><p>网上的解决办法都试过，没能解决问题。</p></blockquote><h2 id="出现转机"><a href="#出现转机" class="headerlink" title="出现转机"></a>出现转机</h2><blockquote><p>出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。</p></blockquote><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><blockquote><p>我使用depends分析libglib-2.0.dll，结果如下图所示<br><img src="/images/2019-04-18_glib_2.png" alt><br>从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。<br>1、网上下载libintl-8.dll<br>2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下</p></blockquote><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><blockquote><p>上述步骤完成之后，再次使用depends检查，如下图所示：<br><img src="/images/2019-04-18_glib_3.png" alt><br>程序也正常运行</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><p>我这里只是说明解决问题的方法，图中dll版本问题自行忽略</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用g
      
    
    </summary>
    
      <category term="GLib" scheme="https://weeweetan.github.io/categories/GLib/"/>
    
    
      <category term="GLib" scheme="https://weeweetan.github.io/tags/GLib/"/>
    
  </entry>
  
  <entry>
    <title>安装vCenter Server出现1603错误的一种解决方法</title>
    <link href="https://weeweetan.github.io/2018/11/29/%E5%AE%89%E8%A3%85vCenter-Server%E5%87%BA%E7%8E%B01603%E9%94%99%E8%AF%AF%E7%9A%84%E4%B8%80%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/</id>
    <published>2018-11-29T02:04:37.000Z</published>
    <updated>2019-05-15T14:12:39.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配置，导致vCenter Server相关服务无法启动，查找解决方法无果后，就打算重装vCenter Server。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>部署过程主要参考<a href="https://blog.csdn.net/shengxia1999/article/details/52353177" target="_blank" rel="noopener">VMware Vsphere 6.0安装部署 （三） vCenter Server安装</a>。在这里我主要说明一下我所遇到的问题以及解决方法。在安装过程中遇到Encountered an internal error，Install-parameter rhttpproxy.ext.port1 not set具体错误信息如下图所示：<br><img src="/images/2018-11-29_error.png" alt></p></blockquote><blockquote><p>出现这个错误后，会退出安装，在最后会报‘安装组件VCSServiceManager失败并显示错误代码1603’，如下图所示：<br><img src="/images/2018-11-29_error_code.png" alt><br>出现这个错误，首先应当排查在安装vCenter Server 过程中配置的http端口是否被占用(使用命令netstat -nao)，如果端口没有被占用，则使用如下方法：</p></blockquote><ol><li><p>删除C:\Program Files\VMware\vCenter Server目录；</p></li><li><p>重启虚拟机，重新安装</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这个方法不一定能解决所有这类问题，这只是其中一种解决方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>Java与PHP之间的Socket通信</title>
    <link href="https://weeweetan.github.io/2018/08/08/Java%E4%B8%8EPHP%E4%B9%8B%E9%97%B4%E7%9A%84Socket%E9%80%9A%E4%BF%A1/"/>
    <id>https://weeweetan.github.io/2018/08/08/Java与PHP之间的Socket通信/</id>
    <published>2018-08-08T15:55:23.000Z</published>
    <updated>2019-05-15T14:02:48.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java作为服务端"><a href="#Java作为服务端" class="headerlink" title="Java作为服务端"></a>Java作为服务端</h2><blockquote><p>Java端作为服务端，PHP端作为客户端，在之前一篇文章中说了下PHP作为客户端如何与Java端进行通信。由于业务需要，socket必须等待服务端处理完成，并返回处理结果给PHP端。在这里主要说明一下Java端如何处理的，不足之处，望指正。</p></blockquote><pre><code>ServerSocket serverSocket = new ServerSocket(port); //创建绑定到特定端口的服务器套接字Socket socket = serverSocket.accept(); //侦听并接受到此套接字的连接InputStream inputStream = socket.getInputStream();StringBuilder sb = new StringBuilder();byte[] packetLength = new byte[4];inputStream.read(packetLength, 0, 4);            //首先从套接字中读取4字节的数据长度int target = byteToint(packetLength);            //这里将字节数组转换成整数System.out.println(&quot;message size:&quot; + target);byte[] bytes = new byte[target];inputStream.read(bytes);                            //读取指定长度的数据sb.append(new String(bytes, 0, target, &quot;UTF-8&quot;));System.out.println(&quot;get message &quot; + sb);String result = &quot;has receive message&quot;;OutputStream outputStream = socket.getOutputStream();int responseLength =  result.getBytes().length;        //这个地方的长度，一定要是字节数组的长度，否则如果字符串中包含中文，接收端接收数据会不完整           byte[] targets = intTobyte(responseLength);outputStream.write(targets);                          //首先发送4个字节的数据大小outputStream.write(result.getBytes());                //再发送真正的数据outputStream.flush();outputStream.close();inputStream.close();socket.close();</code></pre><blockquote><p>上述代码需要处异常，而且代码中的byteToint和intTobyte这两个函数非原创，是其他博主的劳动成果，感谢这位作者，原文地址<em><a href="https://www.cnblogs.com/langren1992/p/4717241.html" target="_blank" rel="noopener">https://www.cnblogs.com/langren1992/p/4717241.html</a></em>。</p></blockquote><h2 id="PHP作为服务端"><a href="#PHP作为服务端" class="headerlink" title="PHP作为服务端"></a>PHP作为服务端</h2><blockquote><p>相关函数: socket_create、socket_set_block、socket_bind、socket_listen、socket_accept、socket_read、socket_write，这些函数具体参数说明在<a href="https://www.php.net/" target="_blank" rel="noopener">PHP文档</a>上写很详细，这里就不再赘述，这里只是介绍服务端如何处理请求。</p></blockquote><pre><code>//确保在连接客户端时不会超时set_time_limit(0);//设置IP和端口号$address = &quot;127.0.0.1&quot;;$port = 54321;$socketServer = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(&quot;socket_create() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);//设置为阻塞模式socket_set_block($socketServer) or die(&quot;socket_set_block() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);//绑定端口$result = socket_bind($socketServer, $address, $port) or die(&quot;socket_bind() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);//开始监听$result = socket_listen($socketServer, 4) or die(&quot;socket_listen() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);do {    //接收连接请求并返回一个子Socket来处理客户端和服务器间的信息    $sock = socket_accept($socketServer) or  die(&quot;socket_accept() failed: reason: &quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;);    while($sock){        //读取客户端数据        echo &quot;Read client data \n&quot;;        $length = socket_read($sock, 4);        $length = unpack(&apos;i&apos;, $length);        echo &quot;length:$length[1]   \n&quot;;        $request = socket_read($sock, $length[1]);        echo &quot;$request:$request   \n&quot;;        //数据传送 向客户端写入返回结果        $msg = &quot;this is response message \n&quot;;        $msgLength = strlen($msg);        $msgLength = pack(&apos;i&apos;, $msgLength);        socket_write($sock, $msgLength);        socket_write($sock, $msg, strlen($msg)) or die(&quot;socket_write() failed: reason: &quot; . socket_strerror(socket_last_error()) .&quot;/n&quot;);        break;    }} while (true);//根据需要关闭socketsocket_close($socketServer);</code></pre><blockquote><p>在接收到客户端的请求后，可以结合PHP的多线程进行处理，这里只是简单的返回字符串。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>各大语言实现socket通信的方式都是大同小异，在服务端的流程都是差不多的。在有现成高性能socket通信框架的情况下，建议不要自己去实现，但是得理解框架底层是怎样实现的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java作为服务端&quot;&gt;&lt;a href=&quot;#Java作为服务端&quot; class=&quot;headerlink&quot; title=&quot;Java作为服务端&quot;&gt;&lt;/a&gt;Java作为服务端&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Java端作为服务端，PHP端作为客户端，在之前一篇文章中
      
    
    </summary>
    
      <category term="Socket" scheme="https://weeweetan.github.io/categories/Socket/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
      <category term="Socket" scheme="https://weeweetan.github.io/tags/Socket/"/>
    
      <category term="Java" scheme="https://weeweetan.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>VMware vSphere WebService SDK使用心得</title>
    <link href="https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK使用心得/</id>
    <published>2018-07-25T12:13:58.000Z</published>
    <updated>2019-05-15T13:27:59.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="善用mob（Managed-Object-Browser）"><a href="#善用mob（Managed-Object-Browser）" class="headerlink" title="善用mob（Managed Object Browser）"></a>善用mob（Managed Object Browser）</h2><blockquote><p>mob地址一般是<em><a href="https://vcenter的FQDN/mob" target="_blank" rel="noopener">https://vcenter的FQDN/mob</a></em>，mob可以让你更好的理解SDK中的那些例子，以及根据自己的业务逻辑改写一些功能。下图为mob首页图，图中的content为整个Managed Object的顶层，从这里进去可以找到整个vcenter server中所有对象及其属性。<br><img src="/images/2018-07-25_mob.png" alt></p></blockquote><h2 id="善用GetMOREF类"><a href="#善用GetMOREF类" class="headerlink" title="善用GetMOREF类"></a>善用GetMOREF类</h2><blockquote><p>GetMOREF类具体位置在<em>VMware-vSphere-SDK-6.0.0-2561048\SDK\vsphere-ws\java\JAXWS\samples\com\vmware\connection\helpers</em>，这是VMware官方提供的一个工具类，里面的每个函数对于开发都很有用。例如</p></blockquote><pre><code>​List&lt;VirtualDevice&gt; listvd = ((ArrayOfVirtualDevice) getMOREFs                                .entityProps(vmMor, new String[] { &quot;config.hardware.device&quot; })                                .get(&quot;config.hardware.device&quot;)).getVirtualDevice();</code></pre><blockquote><p>这是VMReconfig.java中的一个片段，这段代码的作用就是去获取指定虚拟机对象的所有设备，vmMor可以通过GetMOREF类中的vmByVMname函数去获得。至于config.hardware.device，就需要用mob一层一层点进去看了，相信结合mob就能理解为什么要这么写。</p></blockquote><pre><code>​​ ManagedObjectReference propCol = connection.getServiceContent().getPropertyCollector(); ManagedObjectReference vmRef = getMOREFs.vmByVMname(virtualMachineName,propCol);</code></pre><blockquote><p>上面这段代码的作用就是如何根据虚拟机名去获取其对应的ManagedObjectReference</p></blockquote><h2 id="善用SDK里面的文档"><a href="#善用SDK里面的文档" class="headerlink" title="善用SDK里面的文档"></a>善用SDK里面的文档</h2><blockquote><p>文档首页为<em>VMware-vSphere-SDK-6.0.0-2561048/SDK/vsphere-ws/docs/ReferenceGuide/index.html</em><br><img src="/images/2018-07-25_doc.png" alt><br>根据需求，在左侧导航栏对应的去找。</p></blockquote><blockquote><p>对SDK我整理了一下，使其能够在idea中编译运行，项目地址在<a href="https://github.com/wulikanhua/VMwareProject" target="_blank" rel="noopener">VMwareProject</a>   ​</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;善用mob（Managed-Object-Browser）&quot;&gt;&lt;a href=&quot;#善用mob（Managed-Object-Browser）&quot; class=&quot;headerlink&quot; title=&quot;善用mob（Managed Object Browser）&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
  <entry>
    <title>Socket粘包处理</title>
    <link href="https://weeweetan.github.io/2018/07/25/Socket%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86/"/>
    <id>https://weeweetan.github.io/2018/07/25/Socket粘包处理/</id>
    <published>2018-07-25T11:05:52.000Z</published>
    <updated>2019-05-15T13:53:21.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据，并等待Java的响应结果，数据格式为JSON。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>PHP端发送数据后，Java端从socket里读取数据，但是一直读不到结束符。</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote><p>PHP需要调用socket_close函数才会向socket里面写入结束符。</p></blockquote><h2 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h2><blockquote><p><strong>PHP端与Java端之间确定每次发送数据包的长度，用4个字节表示数据长度，PHP端先发送数据包长度，再发送数据包，Java端先接收4个字节长度的数据包长度，再根据数据包长度接收数据包</strong>。PHP端代码如下:</p></blockquote><p>​</p><pre><code>$socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP  ) or die ( &apos;could not create socket&apos;  );  $connect = socket_connect ( $socket, &apos;xxx.xxx.xxx.xxx&apos;, xxxx);  //服务端发送数据 $arr = array(&quot;data&quot; =&gt; &quot;dadadada&quot;);$strlen = pack(&apos;i&apos;, strlen(json_encode($arr)));var_dump($strlen);socket_write ($socket, $strlen);socket_write ($socket, json_encode($arr), strlen(json_encode($arr)));$response = socket_read($socket, 4); $res = unpack(&apos;i&apos;, $response);var_dump($res);$response = socket_read($socket, $res[1]);var_dump($response);socket_close($socket);</code></pre><blockquote><p><a href="https://www.php.net/pack" target="_blank" rel="noopener">pack</a>与<a href="https://www.php.net/unpack" target="_blank" rel="noopener">unpack</a>函数使用说明见PHP官方文档    </p></blockquote><p>​</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据
      
    
    </summary>
    
      <category term="Socket" scheme="https://weeweetan.github.io/categories/Socket/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
      <category term="Socket" scheme="https://weeweetan.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>使用gcc编译驱动模块遇到的问题</title>
    <link href="https://weeweetan.github.io/2017/05/22/%E4%BD%BF%E7%94%A8gcc%E7%BC%96%E8%AF%91%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://weeweetan.github.io/2017/05/22/使用gcc编译驱动模块遇到的问题/</id>
    <published>2017-05-22T09:30:33.000Z</published>
    <updated>2019-05-17T15:43:16.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客<a href="http://bbs.chinaunix.net/thread-2017377-1-1.html" target="_blank" rel="noopener">写一个块设备驱动</a>学习，练习环境为centos6.5 gcc版本为6.3。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>跟着敲完那个简单的驱动程序后，发现编译出错，错误信息为</p></blockquote><pre><code>include/linux/compiler-gcc.h:89:30: fatal error: linux/compiler-gcc6.h: No such file or directory</code></pre><blockquote><p>一通百度，说gcc版本太高，去下载一个<em>compiler-gcc6.h</em>文件，放到内核源码文件夹里面，按着做了，结果编译又出问题了，错误信息为</p></blockquote><pre><code>include/linux/compiler.h:163:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void data_access_exceeds_word_size(void)include/linux/compiler.h:169:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void data_access_exceeds_word_size(void)include/linux/compiler.h:173:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void __read_once_size(volatile void *p, void *res, int size)include/linux/compiler.h:190:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos;static __always_inline void __write_once_size(volatile void *p, void *res, int size)</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>又是一通百度，发现跟我情况不符，看了下博客发表时间，08年，果断换了一个centos6.0的机器，gcc版本为4.6，编译完美通过,环境因素很重要啊。。。   </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="Linux" scheme="https://weeweetan.github.io/categories/Linux/"/>
    
    
      <category term="驱动模块" scheme="https://weeweetan.github.io/tags/%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97/"/>
    
      <category term="Linux" scheme="https://weeweetan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PHP脚本中使用exec总结</title>
    <link href="https://weeweetan.github.io/2017/02/20/PHP%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8exec%E6%80%BB%E7%BB%93/"/>
    <id>https://weeweetan.github.io/2017/02/20/PHP脚本中使用exec总结/</id>
    <published>2017-02-20T01:03:11.000Z</published>
    <updated>2019-05-17T15:54:50.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>总结一下这两天加班遇到的坑，由于本次任务涉及到在PHP中使用exec函数运行shell命令，并解析返回值。屁颠屁颠的写好代码，上传到服务器，服务器环境配置centos6.5+Nginx，ssh到服务器，在控制台运行php xxx.php结果完美显示。蛋疼的是前端调用脚本的时候，没有数据，返回false，一脸懵逼，开始想问题所在，试着在浏览器地址栏直接访问xxx.php没有结果。然后把代码改成</p></blockquote><pre><code>exec(&quot;ls 2&gt;&amp;1&quot;, $result);var_dump($result);</code></pre><blockquote><p>显示ls命令没找到，试着加上路径</p></blockquote><pre><code>exec(&quot;/bin/ls 2&gt;&amp;1&quot;, $result);var_dump($result);</code></pre><blockquote><p>显示权限不够。</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>lsof -i:80 查看你Nginx的用户是谁，我这里是nginx</li><li>在脚本中添加file_put_contents(“/tmp/test.log”, “xxx”)查看test.log的用户是谁。我这里是nobody</li><li><p>在vim /etc/sudoers添加权限</p><p> nobody  ALL=(ALL)   NOPASSWD:ALL<br> nginx     ALL=(ALL)   NOPASSWD:ALL</p></li><li><p>重启nginx服务。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;总结一下这两天加班遇到的坑，由于本次任务涉及到在PHP中使用exec函数运行shell命令，并解析返回值。屁颠屁颠
      
    
    </summary>
    
      <category term="总结" scheme="https://weeweetan.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="PHP" scheme="https://weeweetan.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Esxi5.1挂载NFS存储遇到的问题及解决办法</title>
    <link href="https://weeweetan.github.io/2017/01/13/Esxi5-1%E6%8C%82%E8%BD%BDNFS%E5%AD%98%E5%82%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/</id>
    <published>2017-01-13T01:18:44.000Z</published>
    <updated>2019-05-18T01:20:29.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>如何配置NFS以及怎样在Esxi中添加NFS，可以参考<a href="https://www.linuxidc.com/Linux/2017-04/142686.htm" target="_blank" rel="noopener">VMware ESXI 5.5使用NFS添加存储器</a>, 我也是按照这个博客来配置的。</p></blockquote><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><blockquote><p>遇到如下问题：<br><img src="/images/2017-01-13_nfs.jpg" alt></p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote><p>必须要检查你的esxi主机是否配置了<em>VMkernel</em>，检查步骤如下：<br>1、使用 VI/vSphere Client 连接到 Virtual Center/vCenter Server。<br>2、选择 ESX/ESXi 主机。<br>3、单击配置选项卡。<br>4、单击网络。<br>5、查看 VMKernel 的网络图，或单击属性 &gt; 端口 &gt; VMKernel。如果 VMKernel 未列出，必须添加它。</p></blockquote><h2 id="手动挂载"><a href="#手动挂载" class="headerlink" title="手动挂载"></a>手动挂载</h2><blockquote><p>手动挂载命令：</p></blockquote><pre><code>esxcli storage nfs add -H NFS_IP|NFS_HOSTNAME -s Share_mount_point_on_the_NFS -v DatastoreName</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p><strong>必须保证esxi主机与NFS服务器在同一网段或者能够相互通信</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如何配置NFS以及怎样在Esxi中添加NFS，可以参考&lt;a href=&quot;https://www.linuxidc.
      
    
    </summary>
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/categories/VMware-vSphere/"/>
    
    
      <category term="VMware-vSphere" scheme="https://weeweetan.github.io/tags/VMware-vSphere/"/>
    
  </entry>
  
</feed>
