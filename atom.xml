<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>weeweetan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weeweetan.github.io/"/>
  <updated>2019-05-15T07:06:29.000Z</updated>
  <id>https://weeweetan.github.io/</id>
  
  <author>
    <name>weeweetan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx学习笔记</title>
    <link href="https://weeweetan.github.io/2019/05/08/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://weeweetan.github.io/2019/05/08/Nginx学习笔记/</id>
    <published>2019-05-08T02:49:55.000Z</published>
    <updated>2019-05-15T07:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h2><h3 id="configure原理"><a href="#configure原理" class="headerlink" title="configure原理"></a>configure原理</h3><blockquote><p>configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。</p></blockquote><h3 id="auto脚本"><a href="#auto脚本" class="headerlink" title="auto脚本"></a>auto脚本</h3><blockquote><p>auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：<br><img src="/images/2019-05-13_nginx.png" alt><br>上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。</p></blockquote><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><blockquote><p>在<em>ngx_module.h</em>中引用了两个至关重要的外部变量</p></blockquote><pre><code>extern ngx_module_t  *ngx_modules[];extern char          *ngx_module_names[];</code></pre><blockquote><p><em>ngx_modules</em>跟<em>ngx_module_names</em>定义在<em>ngx_modules.c</em>中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用<em>ngx_cycle_modules</em>函数，原型如下：</p></blockquote><pre><code>ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle)</code></pre><blockquote><p>此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下：</p></blockquote><pre><code>main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules</code></pre><h2 id="handler模块的编写步骤"><a href="#handler模块的编写步骤" class="headerlink" title="handler模块的编写步骤"></a>handler模块的编写步骤</h2><ol><li><p>编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量：</p><p> static ngx_command_t ngx_http_module_name_commands[] = {};<br> static ngx_http_module_t ngx_http_module_name_module_ctx = {};<br> ngx_module_t ngx_http_module_name_module = {};</p></li><li><p>实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数：</p><p> static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)；</p></li><li><p>编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数：</p><p> static ngx_int_t ngx_http_module_name_handler(ngx_http_request_t *r);</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编译步骤&quot;&gt;&lt;a href=&quot;#编译步骤&quot; class=&quot;headerlink&quot; title=&quot;编译步骤&quot;&gt;&lt;/a&gt;编译步骤&lt;/h2&gt;&lt;h3 id=&quot;configure原理&quot;&gt;&lt;a href=&quot;#configure原理&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Nginx" scheme="https://weeweetan.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://weeweetan.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>libxml2使用心得</title>
    <link href="https://weeweetan.github.io/2019/05/04/libxml2%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2019/05/04/libxml2使用心得/</id>
    <published>2019-05-04T14:21:35.000Z</published>
    <updated>2019-05-15T07:04:26.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考<a href="http://www.blogjava.net/wxb_nudt/archive/2007/11/18/161340.html" target="_blank" rel="noopener">C++的XML编程经验――LIBXML2库使用指南</a>，这篇博文讲得很详细，我在这里只是做出一点补充。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。</p></blockquote><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><blockquote><p>我使用GLib2的<em>g_locale_from_utf8</em>将内容转换为本地程序默认的编码格式，在写入xml内容时使用<em>g_locale_to_utf8</em>将内容转换为UTF-8.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有
      
    
    </summary>
    
      <category term="libxml" scheme="https://weeweetan.github.io/categories/libxml/"/>
    
    
      <category term="libxml" scheme="https://weeweetan.github.io/tags/libxml/"/>
    
  </entry>
  
  <entry>
    <title>GLib使用心得</title>
    <link href="https://weeweetan.github.io/2019/04/28/GLib%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://weeweetan.github.io/2019/04/28/GLib使用心得/</id>
    <published>2019-04-28T05:51:59.000Z</published>
    <updated>2019-05-15T07:05:34.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于GLib的介绍这里就不赘述了，具体API介绍可以去<a href="https://developer.gnome.org/glib/" target="_blank" rel="noopener">GLib API Reference</a>查阅，这里只是记录一下使用相关API所遇到的一些坑。</p><h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><h3 id="字符串相关API"><a href="#字符串相关API" class="headerlink" title="字符串相关API"></a>字符串相关API</h3><pre><code>GString *g_string_new(const gchar *init);GString *g_string_append(GString *string, const gchar *val);GString *g_string_prepend(GString *string, const gchar *val);gchar *g_string_free(GString *string, gboolean free_segment);</code></pre><blockquote><p>如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。<strong>注意</strong> g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。<br><em>g_string_append</em>跟<em>g_string_prepend</em>都是直接在原字符串上操作，这点要切记。</p></blockquote><h3 id="字符转换相关API"><a href="#字符转换相关API" class="headerlink" title="字符转换相关API"></a>字符转换相关API</h3><pre><code>gchar *g_filename_display_basename(const gchar *filename);gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);</code></pre><blockquote><p>g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码<br>g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件<br>g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8<br>下面看个例子, 比如我们有个含中文的文件名 <em>/data/test/哈哈.txt</em>如果想获得 <em>哈哈.txt</em>，则必须首先使用 <em>g_locale_to_utf8</em>函数转换一次, 然后再去获取basename</p></blockquote><pre><code>GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;);gchar *str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL);gchar *basename = g_filename_display_basename(str);</code></pre><blockquote><p>如果想使用GString *类型保存basename，则必须重新申请内存块</p></blockquote><pre><code>GString *basename_string = g_string_new(basename); </code></pre><blockquote><p>千万别像下面这样做</p></blockquote><pre><code>GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;);string-&gt;str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); </code></pre><blockquote><p>如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，<em>g_locale_from_utf8</em> 同理<br><strong>注意</strong> <em>g_locale_to_utf8</em>返回的char *需要手动释放内存</p></blockquote><h3 id="解析key-value文件API"><a href="#解析key-value文件API" class="headerlink" title="解析key-value文件API"></a>解析key-value文件API</h3><pre><code>GKeyFile *g_key_file_new(void);gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name,  const gchar *key, GError **error);gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);void g_key_file_free(GKeyFile *key_file);</code></pre><blockquote><p>这几个API很好理解,用来解析具有键值对特征的文件,<em>g_key_file_new</em>跟<em>g_key_file_free</em>配套使用;<br>g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于GLib的介绍这里就不赘述了，具体API介绍可以去&lt;a href=&quot;https://developer.gnome.org/glib/&quot;
      
    
    </summary>
    
      <category term="GLib" scheme="https://weeweetan.github.io/categories/GLib/"/>
    
    
      <category term="GLib" scheme="https://weeweetan.github.io/tags/GLib/"/>
    
  </entry>
  
  <entry>
    <title>调用glib库出现0xc000007b解决办法</title>
    <link href="https://weeweetan.github.io/2019/04/18/%E8%B0%83%E7%94%A8glib%E5%BA%93%E5%87%BA%E7%8E%B00xc000007b%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/</id>
    <published>2019-04-18T14:47:29.000Z</published>
    <updated>2019-05-15T07:05:59.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示：<br><img src="/images/2019-04-18_glib_1.png" alt></p><p>网上的解决办法都试过，没能解决问题。</p><h2 id="出现转机"><a href="#出现转机" class="headerlink" title="出现转机"></a>出现转机</h2><p>出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。</p><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><p>我使用depends分析libglib-2.0.dll，结果如下图所示<br><img src="/images/2019-04-18_glib_2.png" alt><br>从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。<br>1、网上下载libintl-8.dll<br>2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>上述步骤完成之后，再次使用depends检查，如下图所示：<br><img src="/images/2019-04-18_glib_3.png" alt><br>程序也正常运行</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>我这里只是说明解决问题的方法，图中dll版本问题自行忽略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所
      
    
    </summary>
    
      <category term="GLib" scheme="https://weeweetan.github.io/categories/GLib/"/>
    
    
      <category term="GLib" scheme="https://weeweetan.github.io/tags/GLib/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://weeweetan.github.io/2019/04/16/hello-world/"/>
    <id>https://weeweetan.github.io/2019/04/16/hello-world/</id>
    <published>2019-04-16T13:44:16.987Z</published>
    <updated>2019-04-16T13:44:16.987Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
