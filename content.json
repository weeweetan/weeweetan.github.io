{"meta":{"title":"weeweetan's blog","subtitle":"GitHub个人站点","description":"主要记录nginx、虚拟机备份以及其他学习笔记","author":"weeweetan","url":"https://weeweetan.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-04-30T06:58:00.000Z","updated":"2021-09-11T13:38:08.988Z","comments":true,"path":"about/index.html","permalink":"https://weeweetan.github.io/about/index.html","excerpt":"","text":"尝试过的技术VMware虚拟机备份与恢复数据库备份与恢复基于卷的持续数据保护Linux块设备驱动Linux C编程ThinkPHP框架Laravel框架Java SECDN缓存，调度目前正在研究的技术Nginx弹性负载均衡(ELB)"},{"title":"分类","date":"2019-10-07T13:32:54.940Z","updated":"2019-05-15T04:37:44.000Z","comments":false,"path":"categories/index.html","permalink":"https://weeweetan.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-10-07T13:32:54.940Z","updated":"2019-05-15T04:37:44.000Z","comments":false,"path":"books/index.html","permalink":"https://weeweetan.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-07T13:32:55.096Z","updated":"2019-05-15T04:37:44.000Z","comments":true,"path":"links/index.html","permalink":"https://weeweetan.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-07T13:32:55.143Z","updated":"2019-05-15T04:37:44.000Z","comments":false,"path":"repository/index.html","permalink":"https://weeweetan.github.io/repository/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2019-05-15T01:36:14.000Z","updated":"2019-05-15T01:42:30.000Z","comments":true,"path":"resume/index.html","permalink":"https://weeweetan.github.io/resume/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-07T13:32:55.174Z","updated":"2019-05-15T04:37:44.000Z","comments":false,"path":"tags/index.html","permalink":"https://weeweetan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BPF之巅学习笔记","slug":"BPF之巅学习笔记","date":"2024-03-09T13:34:31.000Z","updated":"2025-04-26T16:39:55.213Z","comments":true,"path":"2024/03/09/BPF之巅学习笔记/","link":"","permalink":"https://weeweetan.github.io/2024/03/09/BPF之巅学习笔记/","excerpt":"","text":"第二章2.3 扩展版BPF2.4 调用栈回溯2.5 火焰图2.6 事件源2.7 kprobes内核探测点2.8 uprobes用户层探测点2.9 跟踪点2.10 USDT2.11 动态USDT2.12 性能监控计数器2.13 perf_events第三章3.1 概论3.2 性能分析方法论3.2.1 业务负载画像谁导致了这个负载(eg PID, process name, UID, IP address)?Why is the load called (code path, stack trace, flame graph)?What is the load (IOPS, throughput, type)?How is the load changing over time (per-interval summaries)?3.2.2 下钻分析Start examining the highest level.Examine next-level details.3.2.3 USE方法论Utilization 使用率Saturation 负载率Errors 错误3.2.4 检查清单法3.3 Linux 60s分析3.3.1 uptime3.3.2 dmesg|tail3.3.3 vmstat 13.3.4 mpstat -P ALL 13.3.5 pidstat 13.3.6 iostat -xz 13.3.7 free -m3.3.8 sar -n DEV 13.3.9 sar -n TCP,ETCP 13.3.10 top3.4 BCC工具检查清单3.4.1 execsnoop统计系统调用exec123456# execsnoopPCOMM PID RET ARGSsupervise 9660 0 ./runsupervise 9661 0 ./runmkdir 9662 0 /bin/mkdir -p ./mainrun 9663 0 ./run3.4.2 opensnoop统计系统调用open12345678# opensnoopPID COMM FD ERR PATH1565 redis-server 5 0 /proc/1565/stat1603 snmpd 9 0 /proc/net/dev1603 snmpd 11 0 /proc/net/if_inet61603 snmpd -1 2 /sys/class/net/eth0/device/vendor1603 snmpd 11 0 /proc/sys/net/ipv4/neigh/eth0/retrans_time_ms1603 snmpd 11 0 /proc/sys/net/ipv6/neigh/eth0/retrans_time3.4.3 ext4slower统计ext4文件系统12345678# ext4slowerTracing ext4 operations slower than 10 msTIME COMM PID T BYTES OFF_KB LAT(ms) FILENAME06:35:01 cron 16464 R 1249 0 16.05 common-auth06:35:01 cron 16463 R 1249 0 16.04 common-auth06:35:01 cron 16465 R 1249 0 16.03 common-auth06:35:01 cron 16465 R 4096 0 10.62 login.defs06:35:01 cron 16464 R 4096 0 10.61 login.defs3.4.4 biolatencybio延迟直方图1234567891011121314# biolatency -mTracing block device I/O... Hit Ctrl-C to end.^Cmsecs : count distribution0 -&gt; 1 : 16335 |****************************************|2 -&gt; 3 : 2272 |***** |4 -&gt; 7 : 3603 |******** |8 -&gt; 15 : 4328 |********** |16 -&gt; 31 : 3379 |******** |32 -&gt; 63 : 5815 |************** |64 -&gt; 127 : 0 | |128 -&gt; 255 : 0 | |256 -&gt; 511 : 0 | |512 -&gt; 1023 : 1 | |3.4.5 biosnoopbio size直方图12345678# biosnoopTIME(s) COMM PID DISK T SECTOR BYTES LAT(ms)0.000004001 supervise 1950 xvda1 W 13092560 4096 0.740.000178002 supervise 1950 xvda1 W 13092432 4096 0.610.001469001 supervise 1956 xvda1 W 13092440 4096 1.240.001588002 supervise 1956 xvda1 W 13115128 4096 1.091.022346001 supervise 1950 xvda1 W 13115272 4096 0.98[...]3.4.6 cachestat统计文件系统缓存1234567# cachestatHITS MISSES DIRTIES HITRATIO BUFFERS_MB CACHED_MB53401 2755 20953 95.09% 14 9022349599 4098 21460 92.37% 14 9023016601 2689 61329 86.06% 14 9038115197 2477 58028 85.99% 14 90522[...]3.4.7 tcpconnect统计系统调用connect12345678# tcpconnectPID COMM IP SADDR DADDR DPORT1479 telnet 4 127.0.0.1 127.0.0.1 231469 curl 4 10.201.219.236 54.245.105.25 801469 curl 4 10.201.219.236 54.67.101.145 801991 telnet 6 ::1 ::1 232015 ssh 6 fe80::2000:bff:fe82:3ac fe80::2000:bff:fe82:3ac 22[...]3.4.8 tcpaccept统计系统调用accept123456# tcpacceptPID COMM IP RADDR LADDR LPORT907 sshd 4 192.168.56.1 192.168.56.102 22907 sshd 4 127.0.0.1 127.0.0.1 225389 perl 6 1234:ab12:2040:5020:2299:0:5:0 1234:ab12:2040:5020:2299:0:5:0 7001[...]3.4.9 tcpretranstcp重传统计123456# tcpretransTIME PID IP LADDR:LPORT T&gt; RADDR:RPORT STATE01:55:05 0 4 10.153.223.157:22 R&gt; 69.53.245.40:34619 ESTABLISHED01:55:05 0 4 10.153.223.157:22 R&gt; 69.53.245.40:34619 ESTABLISHED01:55:17 0 4 10.153.223.157:22 R&gt; 69.53.245.40:22957 ESTABLISHED[...]3.4.10 runqlatcpu上运行队列统计1234567891011121314151617181920# runqlatTracing run queue latency... Hit Ctrl-C to end.^Cusecs : count distribution0 -&gt; 1 : 233 |*********** |2 -&gt; 3 : 742 |************************************ |4 -&gt; 7 : 203 |********** |8 -&gt; 15 : 173 |******** |16 -&gt; 31 : 24 |* |32 -&gt; 63 : 0 | |64 -&gt; 127 : 30 |* |128 -&gt; 255 : 6 | |256 -&gt; 511 : 3 | |512 -&gt; 1023 : 5 | |1024 -&gt; 2047 : 27 |* |2048 -&gt; 4095 : 30 |* |4096 -&gt; 8191 : 20 | |8192 -&gt; 16383 : 29 |* |16384 -&gt; 32767 : 809 |****************************************|32768 -&gt; 65535 : 64 |*** |3.4.11 profile采集CPU12345678910111213141516171819202122# profileSampling at 49 Hertz of all threads by user + kernel stack... Hit Ctrl-C to end.^C[...]copy_user_enhanced_fast_stringcopy_user_enhanced_fast_string_copy_from_iter_fulltcp_sendmsg_lockedtcp_sendmsginet_sendmsgsock_sendmsgsock_write_iternew_sync_write__vfs_writevfs_writeSyS_writedo_syscall_64entry_SYSCALL_64_after_hwframe[unknown][unknown]- iperf (24092)58第四章4.1 BCC的组件4.2 BCC的特性4.3 安装BCC4.4 BCC的工具4.5 funccount统计指定函数调用次数4.6 stackcount统计栈调用次数14.7 trace用于跟踪和调试应用程序的执行过程14.8 argdist函数参数分布统计4.9 工具文档4.9.1 Man Page: opensnoop4.9.2 Examples File: opensnoop4.10 开发BCC工具4.11 BCC的内部实现4.12 BCC的调试4.12.1 printf() Debugging4.12.2 BCC Debug output4.12.3 BCC Debug Flag4.12.4 bpflist4.12.5 bpftool4.12.6 dmesg4.12.7 Resetting Events4.13 Summary第五章5.1 bpftrace的组件5.2 bpftrace的特性5.2.1 bpftrace Event Sources5.2.2 bpftrace Actions5.2.3 bpftrace General Features5.2.4 bpftrace Compared to Other Observability Tools5.3 bpftrace的安装5.3.1 Kernel Requirements5.3.2 Ubuntu5.3.3 Fedora5.3.4 Post-Build Steps5.3.5 Other Distributions5.4 bpftrace工具5.4.1 Highlighted Tools5.4.2 Tool Characteristics5.4.3 Tool Execution5.5 bpftrace单行程序5.6 bpftrace的文档5.7 bpftrace编程5.7.1 Usage5.7.2 Program Structure5.7.3 Comments5.7.4 Probe Format5.7.5 Probe Wildcards5.7.6 Filters5.7.7 Actions5.7.8 Hello, World!5.7.9 Functions5.7.10 Variables5.7.11 Map Functions5.7.12 Timing vfs_read()5.8 bpftrace的帮助信息5.9 bpftrace的探针类型5.9.1 tracepoint5.9.2 usdt5.9.3 kprobe and kretprobe5.9.4 uprobe and uretprobe5.9.5 software and hardware5.9.6 profile and interval5.10 bpftrace的控制流5.10.1 Filter5.10.2 Ternary Operators5.10.3 If Statements5.10.4 Unrolled Loops5.13.3 str()5.11 bpftrace的运算符5.12 bpftrace的变量5.12.1 Built-in Variables5.12.2 Built-ins: pid, comm, and uid5.12.3 Built-ins: kstack and ustack5.12.4 Built-ins: Positional Parameters5.12.5 Scratch5.12.6 Maps5.13 bpftrace的函数5.13.1 printf()5.13.2 join()5.13.3 str()5.13.4 kstack() and ustack()5.13.5 ksym() and usym()5.13.6 kaddr() and uaddr()5.13.7 system()5.13.8 exit()5.14 bpftrace映射表的操作函数5.14.1 count()5.14.2 sum(), avg(), min(), and max()5.14.3 hist()5.14.4 lhist()5.14.5 delete()5.14.6 clear() and zero()5.14.7 print()5.15 bpftrace的下一步工作5.15.1 Explicit Address Modes5.15.2 Other Additions5.15.3 ply5.16 bpftrace的内部运作5.17 bpftrace的调试5.17.1 printf() Debugging5.17.2 Debug Mode5.17.3 Verbose Mode5.18 Summary第六章 CPU6.1 背景知识6.1.1 CPU Fundamentals6.1.2 BPF Capabilities6.1.3 Strategy6.2 传统工具6.2.1 Kernel Statistics6.2.2 Hardware Statistics6.2.3 Hardware Sampling6.2.4 Timed Sampling6.2.5 Event Statistics and Tracing6.3 BPF工具6.3.1 execsnoop6.3.2 exitsnoop6.3.3 runqlat6.3.4 runqlen6.3.5 runqslower6.3.6 cpudist6.3.7 cpufreq6.3.8 profile6.3.9 offcputime6.3.10 syscount6.3.11 argdist and trace6.3.12 funccount6.3.13 softirqs6.3.14 hardirqs6.3.15 smpcalls6.3.16 llcstat6.3.17 Other Tools6.4 BPF单行程序6.4.1 BCC6.4.2 bpftrace第七章 内存7.1 背景知识7.1.1 Memory Fundamentals7.1.2 BPF Capabilities7.1.3 Strategy7.2 传统工具7.2.1 Kernel Log7.2.2 Kernel Statistics7.2.3 Hardware Statistics and Sampling7.3 BPF工具7.3.1 oomkill7.3.2 memleak7.3.3 mmapsnoop7.3.4 brkstack7.3.5 shmsnoop7.3.6 faults7.3.7 ffaults7.3.8 vmscan7.3.9 drsnoop7.3.10 swapin7.3.11 hfaults7.3.12 Other Tools7.4 BPF单行程序7.4.1 BCC7.4.2 bpftrace7.5 Optional Exercises7.6 Summary第八章 文件系统8.1 背景知识8.1.1 File Systems Fundamentals8.1.2 BPF Capabilities8.1.3 Strategy8.2 传统工具8.2.1 df8.2.2 mount8.2.3 strace8.2.4 perf8.2.5 fatrace8.3 BPF工具8.3.1 opensnoop8.3.2 statsnoop8.3.3 syncsnoop8.3.4 mmapfiles8.3.5 scread8.3.6 fmapfaul8.3.7 filelife8.3.8 vfssta8.3.8 vfssta8.3.9 vfscount8.3.10 vfssiz8.3.11 fsrwsta8.3.12 fileslower8.3.13 filetop8.3.14 writesync8.3.15 filetype8.3.16 cachestat8.3.17 writeback8.3.18 dcstat8.3.19 dcsnoop8.3.20 mountsnoop8.3.21 xfsslower8.3.22 xfsdist8.3.23 ext4dist8.3.24 icstat8.3.25 bufgrow8.3.26 readahead8.3.27 Other Tools8.4 BPF单行程序第九章 磁盘io9.1 背景知识9.2 传统工具9.3 BPF工具9.3.1 biolatency9.3.2 biosnoop9.3.3 biotop9.3.4 bitesize9.3.5 seeksize9.3.6 biopattern9.3.7 biostacks9.3.8 bioerr9.3.9 mdflush9.3.10 iosched9.3.11 scsilatency9.3.12 scsiresult9.3.13 nvmelatency9.4 BPF单行程序####第十章 网络10.1 背景知识10.2 传统工具10.3 BPF工具10.3.1 sockstat10.3.2 sofamily10.3.3 soprotocol10.3.4 soconnect10.3.5 soaccept10.3.6 socketio10.3.7 socksize10.3.8 sormem10.3.9 soconnlat10.3.10 so1stbyte10.3.11 tcpconnect10.3.12 tcpaccept10.3.13 tcplife10.3.14 tcptop10.3.15 tcpsnoop10.3.16 tcpretrans10.3.17 tcpsynbl10.3.18 tcpwin10.3.19 tcpnagle10.3.20 udpconnect10.3.21 gethostlatency10.3.22 ipecn10.3.23 superping10.3.24 qdisc-fq10.3.25 qdisc-cbq, qdisc-cbs, qdisc-codel, qdisc-fq_codel, qdisc-red, and qdisc-tbf10.3.26 netsize10.4 BPF单行程序第十一章 安全11.1 背景知识11.2 BPF工具11.3 BPF单行程序第十二章 编程语言12.1 背景知识12.2 C12.3 Java12.4 bash shell12.5 其他语言第十三章 应用程序13.1 背景知识13.2 BPF工具13.3 单行程序13.4 BPF单行程序示例第十四章 内核14.1 背景知识14.2 分析策略14.3 传统工具14.4 BPF工具14.5 BPF单行程序14.6 BPF单行程序示例第十五章 容器15.1 背景知识15.2 传统工具15.3 BPF工具15.4 BPF单行程序15.5 可选练习第十六章 虚拟机管理器16.1 背景知识16.2 传统工具16.3 访客系统的BPF工具16.4 宿主机的BPF工具","categories":[{"name":"BPF","slug":"BPF","permalink":"https://weeweetan.github.io/categories/BPF/"}],"tags":[{"name":"BPF","slug":"BPF","permalink":"https://weeweetan.github.io/tags/BPF/"}]},{"title":"Nginx的mirror模块详解","slug":"Nginx的mirror模块详解","date":"2023-12-14T14:28:05.000Z","updated":"2024-02-28T14:33:13.923Z","comments":true,"path":"2023/12/14/Nginx的mirror模块详解/","link":"","permalink":"https://weeweetan.github.io/2023/12/14/Nginx的mirror模块详解/","excerpt":"","text":"1.相关指令12345678910Syntax: mirror uri | off;Default: mirror off;Context: http, server, locationSyntax: mirror_request_body on | off;Default: mirror_request_body on;Context: http, server, location2.配置解析函数首先看下指令mirror的配置解析函数ngx_http_mirror的实现1234567891011121314151617181920212223242526272829303132333435363738static char *ngx_http_mirror(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_mirror_loc_conf_t *mlcf = conf; ngx_str_t *value, *s; value = cf-&gt;args-&gt;elts; //判断参数是否为off if (ngx_strcmp(value[1].data, \"off\") == 0) &#123; if (mlcf-&gt;mirror != NGX_CONF_UNSET_PTR) &#123; return \"is duplicate\"; &#125; mlcf-&gt;mirror = NULL; return NGX_CONF_OK; &#125; if (mlcf-&gt;mirror == NULL) &#123; return \"is duplicate\"; &#125; // 构造数组mlcf-&gt;mirror if (mlcf-&gt;mirror == NGX_CONF_UNSET_PTR) &#123; mlcf-&gt;mirror = ngx_array_create(cf-&gt;pool, 4, sizeof(ngx_str_t)); if (mlcf-&gt;mirror == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; // push一个数组元素，用于保存mirror配置 s = ngx_array_push(mlcf-&gt;mirror); if (s == NULL) &#123; return NGX_CONF_ERROR; &#125; // 保存参数，也就是url *s = value[1]; return NGX_CONF_OK;&#125;接下来看看handler函数ngx_http_mirror_handler的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546static ngx_int_tngx_http_mirror_handler(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_http_mirror_ctx_t *ctx; ngx_http_mirror_loc_conf_t *mlcf; // 子请求，直接返回 if (r != r-&gt;main) &#123; return NGX_DECLINED; &#125; // 获取location级别的配置 mlcf = ngx_http_get_module_loc_conf(r, ngx_http_mirror_module); // 没有配置mirror，直接返回 if (mlcf-&gt;mirror == NULL) &#123; return NGX_DECLINED; &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"mirror handler\"); // 处理请求body if (mlcf-&gt;request_body) &#123; ctx = ngx_http_get_module_ctx(r, ngx_http_mirror_module); if (ctx) &#123; return ctx-&gt;status; &#125; // 申请ctx内存 ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_mirror_ctx_t)); if (ctx == NULL) &#123; return NGX_ERROR; &#125; ctx-&gt;status = NGX_DONE; // 设置ctx ngx_http_set_ctx(r, ctx, ngx_http_mirror_module); // 读request_body rc = ngx_http_read_client_request_body(r, ngx_http_mirror_body_handler); if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; // 结束请求 ngx_http_finalize_request(r, NGX_DONE); return NGX_DONE; &#125; // 调用handler return ngx_http_mirror_handler_internal(r);&#125;接下来看看ngx_http_mirror_body_handler处理逻辑1234567891011121314static voidngx_http_mirror_body_handler(ngx_http_request_t *r)&#123; ngx_http_mirror_ctx_t *ctx; // get ctx ctx = ngx_http_get_module_ctx(r, ngx_http_mirror_module); //调用internal ctx-&gt;status = ngx_http_mirror_handler_internal(r); r-&gt;preserve_body = 1; // 重新执行各个阶段 r-&gt;write_event_handler = ngx_http_core_run_phases; ngx_http_core_run_phases(r);&#125;接下来看下ngx_http_mirror_init的处理逻辑1234567891011121314151617static ngx_int_tngx_http_mirror_init(ngx_conf_t *cf)&#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); // precontent阶段，push出一个元素，用于保存handler h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PRECONTENT_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; // handler赋值 *h = ngx_http_mirror_handler; return NGX_OK;&#125;接下来看看ngx_http_mirror_handler_internal实现，主要是遍历所有mirror指令，创建子请求12345678910111213141516171819202122232425262728static ngx_int_tngx_http_mirror_handler_internal(ngx_http_request_t *r)&#123; ngx_str_t *name; ngx_uint_t i; ngx_http_request_t *sr; ngx_http_mirror_loc_conf_t *mlcf; mlcf = ngx_http_get_module_loc_conf(r, ngx_http_mirror_module); name = mlcf-&gt;mirror-&gt;elts; // 遍历location下的mirror指令 for (i = 0; i &lt; mlcf-&gt;mirror-&gt;nelts; i++) &#123; //创建子请求 if (ngx_http_subrequest(r, &amp;name[i], &amp;r-&gt;args, &amp;sr, NULL, NGX_HTTP_SUBREQUEST_BACKGROUND) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; sr-&gt;header_only = 1; sr-&gt;method = r-&gt;method; sr-&gt;method_name = r-&gt;method_name; &#125; return NGX_DECLINED;&#125;以上就是mirror模块主要功能","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的auth_basic模块详解","slug":"Nginx的auth-basic模块详解","date":"2023-09-21T15:14:35.000Z","updated":"2024-03-08T14:38:03.899Z","comments":true,"path":"2023/09/21/Nginx的auth-basic模块详解/","link":"","permalink":"https://weeweetan.github.io/2023/09/21/Nginx的auth-basic模块详解/","excerpt":"","text":"1.相关指令123456789Syntax: auth_basic string | off;Default: auth_basic off;Context: http, server, location, limit_exceptSyntax: auth_basic_user_file file;Default: —Context: http, server, location, limit_except2.配置解析函数首先看下指令auth_basic的配置解析函数ngx_http_set_complex_value_slot，这是个通用的函数，这里不再赘述接下来看下指令auth_basic_user_file的配置解析函数123456789101112131415161718192021222324252627282930313233343536static char *ngx_http_auth_basic_user_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; // 模块配置 ngx_http_auth_basic_loc_conf_t *alcf = conf; ngx_str_t *value; ngx_http_compile_complex_value_t ccv; // 判断是否重复设置 if (alcf-&gt;user_file != NGX_CONF_UNSET_PTR) &#123; return \"is duplicate\"; &#125; //申请内存 alcf-&gt;user_file = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t)); if (alcf-&gt;user_file == NULL) &#123; return NGX_CONF_ERROR; &#125; value = cf-&gt;args-&gt;elts; // 初始化变量 ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = alcf-&gt;user_file; ccv.zero = 1; ccv.conf_prefix = 1; // 编译变量 if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK;&#125;3.handler函数1.接下来看下ngx_http_auth_basic_handler的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199static ngx_int_tngx_http_auth_basic_handler(ngx_http_request_t *r)&#123; off_t offset; ssize_t n; ngx_fd_t fd; ngx_int_t rc; ngx_err_t err; ngx_str_t pwd, realm, user_file; ngx_uint_t i, level, login, left, passwd; ngx_file_t file; ngx_http_auth_basic_loc_conf_t *alcf; u_char buf[NGX_HTTP_AUTH_BUF_SIZE]; enum &#123; sw_login, sw_passwd, sw_skip &#125; state; alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_basic_module); if (alcf-&gt;realm == NULL || alcf-&gt;user_file == NULL) &#123; return NGX_DECLINED; &#125; // 编译变量 if (ngx_http_complex_value(r, alcf-&gt;realm, &amp;realm) != NGX_OK) &#123; return NGX_ERROR; &#125; if (realm.len == 3 &amp;&amp; ngx_strncmp(realm.data, \"off\", 3) == 0) &#123; return NGX_DECLINED; &#125; // 从authorization header中解析出user以及password rc = ngx_http_auth_basic_user(r); // 没有解析出user password, 添加必要header，返回401 if (rc == NGX_DECLINED) &#123; ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0, \"no user/password was provided for basic authentication\"); return ngx_http_auth_basic_set_realm(r, &amp;realm); &#125; if (rc == NGX_ERROR) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; // 编译变量 if (ngx_http_complex_value(r, alcf-&gt;user_file, &amp;user_file) != NGX_OK) &#123; return NGX_ERROR; &#125; // 打开文件 fd = ngx_open_file(user_file.data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0); // 打开失败 if (fd == NGX_INVALID_FILE) &#123; err = ngx_errno; if (err == NGX_ENOENT) &#123; level = NGX_LOG_ERR; rc = NGX_HTTP_FORBIDDEN; &#125; else &#123; level = NGX_LOG_CRIT; rc = NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; ngx_log_error(level, r-&gt;connection-&gt;log, err, ngx_open_file_n \" \\\"%s\\\" failed\", user_file.data); return rc; &#125; ngx_memzero(&amp;file, sizeof(ngx_file_t)); file.fd = fd; file.name = user_file; file.log = r-&gt;connection-&gt;log; state = sw_login; passwd = 0; login = 0; left = 0; offset = 0; for ( ;; ) &#123; i = left; // 读文件 n = ngx_read_file(&amp;file, buf + left, NGX_HTTP_AUTH_BUF_SIZE - left, offset); if (n == NGX_ERROR) &#123; rc = NGX_HTTP_INTERNAL_SERVER_ERROR; goto cleanup; &#125; // 文件读完 if (n == 0) &#123; break; &#125; // 状态机处理 for (i = left; i &lt; left + n; i++) &#123; switch (state) &#123; case sw_login: if (login == 0) &#123; // 跳过注释 if (buf[i] == '#' || buf[i] == CR) &#123; state = sw_skip; break; &#125; // 跳过换行符 if (buf[i] == LF) &#123; break; &#125; &#125; // 长度不匹配，直接跳过 if (buf[i] != r-&gt;headers_in.user.data[login]) &#123; state = sw_skip; break; &#125; //username匹配完成 if (login == r-&gt;headers_in.user.len) &#123; state = sw_passwd; passwd = i + 1; &#125; login++; break; //开始解析密码 case sw_passwd: if (buf[i] == LF || buf[i] == CR || buf[i] == ':') &#123; buf[i] = '\\0'; pwd.len = i - passwd; pwd.data = &amp;buf[passwd]; //处理密码 rc = ngx_http_auth_basic_crypt_handler(r, &amp;pwd, &amp;realm); goto cleanup; &#125; break; case sw_skip: if (buf[i] == LF) &#123; state = sw_login; login = 0; &#125; break; &#125; &#125; //密码没有解析完，继续解析 if (state == sw_passwd) &#123; left = left + n - passwd; ngx_memmove(buf, &amp;buf[passwd], left); passwd = 0; &#125; else &#123; left = 0; &#125; // 偏移n offset += n; &#125; // 解析到密码段 if (state == sw_passwd) &#123; pwd.len = i - passwd; pwd.data = ngx_pnalloc(r-&gt;pool, pwd.len + 1); if (pwd.data == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; //拷贝密码 ngx_cpystrn(pwd.data, &amp;buf[passwd], pwd.len + 1); //对密码进行处理 rc = ngx_http_auth_basic_crypt_handler(r, &amp;pwd, &amp;realm); goto cleanup; &#125; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"user \\\"%V\\\" was not found in \\\"%s\\\"\", &amp;r-&gt;headers_in.user, user_file.data); // 调用函数，设置auth header rc = ngx_http_auth_basic_set_realm(r, &amp;realm);cleanup: // 关闭文件 if (ngx_close_file(file.fd) == NGX_FILE_ERROR) &#123; ngx_log_error(NGX_LOG_ALERT, r-&gt;connection-&gt;log, ngx_errno, ngx_close_file_n \" \\\"%s\\\" failed\", user_file.data); &#125; ngx_explicit_memzero(buf, NGX_HTTP_AUTH_BUF_SIZE); return rc;&#125;接下来看下ngx_http_auth_basic_crypt_handler函数实现12345678910111213141516171819202122232425262728293031static ngx_int_tngx_http_auth_basic_crypt_handler(ngx_http_request_t *r, ngx_str_t *passwd, ngx_str_t *realm)&#123; ngx_int_t rc; u_char *encrypted; // 使用header中的passwd作为key进行编码 rc = ngx_crypt(r-&gt;pool, r-&gt;headers_in.passwd.data, passwd-&gt;data, &amp;encrypted); ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;rc: %i user: \\&quot;%V\\&quot; salt: \\&quot;%s\\&quot;&quot;, rc, &amp;r-&gt;headers_in.user, passwd-&gt;data); if (rc != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; // 比较编码后的字符串 if (ngx_strcmp(encrypted, passwd-&gt;data) == 0) &#123; return NGX_OK; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;encrypted: \\&quot;%s\\&quot;&quot;, encrypted); ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;user \\&quot;%V\\&quot;: password mismatch&quot;, &amp;r-&gt;headers_in.user); return ngx_http_auth_basic_set_realm(r, realm);&#125;接下来看看ngx_http_auth_basic_set_realm的函数实现12345678910111213141516171819202122232425262728293031static ngx_int_tngx_http_auth_basic_set_realm(ngx_http_request_t *r, ngx_str_t *realm)&#123; size_t len; u_char *basic, *p; // 从headers list中获取一个元素 r-&gt;headers_out.www_authenticate = ngx_list_push(&amp;r-&gt;headers_out.headers); if (r-&gt;headers_out.www_authenticate == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; //初始化header len len = sizeof(&quot;Basic realm=\\&quot;\\&quot;&quot;) - 1 + realm-&gt;len; // 申请内存 basic = ngx_pnalloc(r-&gt;pool, len); if (basic == NULL) &#123; r-&gt;headers_out.www_authenticate-&gt;hash = 0; r-&gt;headers_out.www_authenticate = NULL; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; //复制header p = ngx_cpymem(basic, &quot;Basic realm=\\&quot;&quot;, sizeof(&quot;Basic realm=\\&quot;&quot;) - 1); p = ngx_cpymem(p, realm-&gt;data, realm-&gt;len); *p = &apos;&quot;&apos;; // 设置header r-&gt;headers_out.www_authenticate-&gt;hash = 1; ngx_str_set(&amp;r-&gt;headers_out.www_authenticate-&gt;key, &quot;WWW-Authenticate&quot;); r-&gt;headers_out.www_authenticate-&gt;value.data = basic; r-&gt;headers_out.www_authenticate-&gt;value.len = len; //返回401 return NGX_HTTP_UNAUTHORIZED;&#125;以上就是这个auth-basic模块的实现","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的geoip模块详解","slug":"Nginx的geoip模块详解","date":"2023-06-29T15:06:24.000Z","updated":"2023-09-20T14:50:43.033Z","comments":true,"path":"2023/06/29/Nginx的geoip模块详解/","link":"","permalink":"https://weeweetan.github.io/2023/06/29/Nginx的geoip模块详解/","excerpt":"","text":"1.相关指令123456789101112131415161718192021222324Syntax: geoip_country file;Default: —Context: httpSyntax: geoip_city file;Default: —Context: httpSyntax: geoip_org file;Default: —Context: httpThis directive appeared in version 1.0.3.Syntax: geoip_proxy address | CIDR;Default: —Context: httpThis directive appeared in versions 1.3.0 and 1.2.1.Syntax: geoip_proxy_recursive on | off;Default: geoip_proxy_recursive off;Context: httpThis directive appeared in versions 1.3.0 and 1.2.1.2.配置解析函数首先看下配置解析函数ngx_http_geoip_country123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static char *ngx_http_geoip_country(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_geoip_conf_t *gcf = conf; ngx_str_t *value; //重复配置校验 if (gcf-&gt;country) &#123; return \"is duplicate\"; &#125; // 获取指令后面的参数 value = cf-&gt;args-&gt;elts; // 打开数据文件 gcf-&gt;country = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE); if (gcf-&gt;country == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"GeoIP_open(\\\"%V\\\") failed\", &amp;value[1]); return NGX_CONF_ERROR; &#125; // 判断参数个数，设置编码格式 if (cf-&gt;args-&gt;nelts == 3) &#123; if (ngx_strcmp(value[2].data, \"utf8\") == 0) &#123; GeoIP_set_charset(gcf-&gt;country, GEOIP_CHARSET_UTF8); &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\", &amp;value[2]); return NGX_CONF_ERROR; &#125; &#125; switch (gcf-&gt;country-&gt;databaseType) &#123; case GEOIP_COUNTRY_EDITION: return NGX_CONF_OK;#if (NGX_HAVE_GEOIP_V6) case GEOIP_COUNTRY_EDITION_V6: gcf-&gt;country_v6 = 1; return NGX_CONF_OK;#endif default: ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid GeoIP database \\\"%V\\\" type:%d\", &amp;value[1], gcf-&gt;country-&gt;databaseType); return NGX_CONF_ERROR; &#125;&#125;接下来看下配置解析函数ngx_http_geoip_org123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static char *ngx_http_geoip_org(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_geoip_conf_t *gcf = conf; ngx_str_t *value; // 重复配置检查 if (gcf-&gt;org) &#123; return \"is duplicate\"; &#125; value = cf-&gt;args-&gt;elts; // 打开数据文件 gcf-&gt;org = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE); if (gcf-&gt;org == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"GeoIP_open(\\\"%V\\\") failed\", &amp;value[1]); return NGX_CONF_ERROR; &#125; // 设置文件编码格式 if (cf-&gt;args-&gt;nelts == 3) &#123; if (ngx_strcmp(value[2].data, \"utf8\") == 0) &#123; GeoIP_set_charset(gcf-&gt;org, GEOIP_CHARSET_UTF8); &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\", &amp;value[2]); return NGX_CONF_ERROR; &#125; &#125; //选择数据类型 switch (gcf-&gt;org-&gt;databaseType) &#123; case GEOIP_ISP_EDITION: case GEOIP_ORG_EDITION: case GEOIP_DOMAIN_EDITION: case GEOIP_ASNUM_EDITION: return NGX_CONF_OK;#if (NGX_HAVE_GEOIP_V6) case GEOIP_ISP_EDITION_V6: case GEOIP_ORG_EDITION_V6: case GEOIP_DOMAIN_EDITION_V6: case GEOIP_ASNUM_EDITION_V6: gcf-&gt;org_v6 = 1; return NGX_CONF_OK;#endif default: ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid GeoIP database \\\"%V\\\" type:%d\", &amp;value[1], gcf-&gt;org-&gt;databaseType); return NGX_CONF_ERROR; &#125;&#125;接下来看下配置解析函数ngx_http_geoip_city12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static char *ngx_http_geoip_city(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_geoip_conf_t *gcf = conf; ngx_str_t *value; // 重复设置判断 if (gcf-&gt;city) &#123; return \"is duplicate\"; &#125; value = cf-&gt;args-&gt;elts; // 打开数据文件 gcf-&gt;city = GeoIP_open((char *) value[1].data, GEOIP_MEMORY_CACHE); if (gcf-&gt;city == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"GeoIP_open(\\\"%V\\\") failed\", &amp;value[1]); return NGX_CONF_ERROR; &#125; //处理编码格式 if (cf-&gt;args-&gt;nelts == 3) &#123; if (ngx_strcmp(value[2].data, \"utf8\") == 0) &#123; GeoIP_set_charset(gcf-&gt;city, GEOIP_CHARSET_UTF8); &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\", &amp;value[2]); return NGX_CONF_ERROR; &#125; &#125; // 针对数据类型做处理 switch (gcf-&gt;city-&gt;databaseType) &#123; case GEOIP_CITY_EDITION_REV0: case GEOIP_CITY_EDITION_REV1: return NGX_CONF_OK;#if (NGX_HAVE_GEOIP_V6) case GEOIP_CITY_EDITION_REV0_V6: case GEOIP_CITY_EDITION_REV1_V6: gcf-&gt;city_v6 = 1; return NGX_CONF_OK;#endif default: ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid GeoIP City database \\\"%V\\\" type:%d\", &amp;value[1], gcf-&gt;city-&gt;databaseType); return NGX_CONF_ERROR; &#125;&#125;接下来看下配置解析函数ngx_http_geoip_proxy123456789101112131415161718192021222324252627282930static char *ngx_http_geoip_proxy(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_geoip_srv_conf_t *gscf = conf; ngx_str_t *value; ngx_cidr_t cidr, *c; value = cf-&gt;args-&gt;elts; // 解析cidr地址 if (ngx_http_geoip_cidr_value(cf, &amp;value[1], &amp;cidr) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; // 初始化proxy数组 if (gscf-&gt;proxies == NGX_CONF_UNSET_PTR) &#123; gscf-&gt;proxies = ngx_array_create(cf-&gt;pool, 4, sizeof(ngx_cidr_t)); if (gscf-&gt;proxies == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; // push 一个元素用于保存cidr c = ngx_array_push(gscf-&gt;proxies); if (c == NULL) &#123; return NGX_CONF_ERROR; &#125; // 保存cidr地址 *c = cidr; return NGX_CONF_OK;&#125;指令geoip_proxy_recursive使用原生函数ngx_conf_set_flag_slot，这里就不再赘述3.hander函数此模块没有handler函数4.变量处理函数此模块功能都是为变量实现，所以主要函数都是为变量实现首先来看下变量geoip_country_code的处理函数ngx_http_geoip_country_variable1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static ngx_int_tngx_http_geoip_country_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)&#123; // 根据data类型获取对应函数指针，ngx_http_geoip_country_functions在代码有定义 ngx_http_geoip_variable_handler_pt handler = ngx_http_geoip_country_functions[data];#if (NGX_HAVE_GEOIP_V6) ngx_http_geoip_variable_handler_v6_pt handler_v6 = ngx_http_geoip_country_v6_functions[data];#endif const char *val; ngx_http_geoip_conf_t *gcf; // 获取main级别conf gcf = ngx_http_get_module_main_conf(r, ngx_http_geoip_module); // 没有配置country数据 if (gcf-&gt;country == NULL) &#123; goto not_found; &#125; //在handler内部调用ngx_http_geoip_addr#if (NGX_HAVE_GEOIP_V6) val = gcf-&gt;country_v6 ? handler_v6(gcf-&gt;country, ngx_http_geoip_addr_v6(r, gcf)) : handler(gcf-&gt;country, ngx_http_geoip_addr(r, gcf));#else val = handler(gcf-&gt;country, ngx_http_geoip_addr(r, gcf));#endif if (val == NULL) &#123; goto not_found; &#125; //为变量赋值 v-&gt;len = ngx_strlen(val); v-&gt;valid = 1; v-&gt;no_cacheable = 0; v-&gt;not_found = 0; v-&gt;data = (u_char *) val; return NGX_OK;not_found: v-&gt;not_found = 1; return NGX_OK;&#125;接下来看看ngx_http_geoip_addr函数实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static u_longngx_http_geoip_addr(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)&#123; ngx_addr_t addr; ngx_array_t *xfwd; struct sockaddr_in *sin; addr.sockaddr = r-&gt;connection-&gt;sockaddr; addr.socklen = r-&gt;connection-&gt;socklen; /* addr.name = r-&gt;connection-&gt;addr_text; */ xfwd = &amp;r-&gt;headers_in.x_forwarded_for; //获取server级别配置 ngx_http_geoip_srv_conf_t *gscf = ngx_http_get_module_srv_conf(r, ngx_http_geoip_module); //从xff头中获取ip if (xfwd-&gt;nelts &gt; 0 &amp;&amp; gscf-&gt;proxies != NULL) &#123; (void) ngx_http_get_forwarded_addr(r, &amp;addr, xfwd, NULL, gscf-&gt;proxies, gscf-&gt;proxy_recursive); &#125;#if (NGX_HAVE_INET6) //判断是否为IPV6 if (addr.sockaddr-&gt;sa_family == AF_INET6) &#123; u_char *p; in_addr_t inaddr; struct in6_addr *inaddr6; inaddr6 = &amp;((struct sockaddr_in6 *) addr.sockaddr)-&gt;sin6_addr; if (IN6_IS_ADDR_V4MAPPED(inaddr6)) &#123; p = inaddr6-&gt;s6_addr; inaddr = p[12] &lt;&lt; 24; inaddr += p[13] &lt;&lt; 16; inaddr += p[14] &lt;&lt; 8; inaddr += p[15]; return inaddr; &#125; &#125;#endif //非ipv4协议 if (addr.sockaddr-&gt;sa_family != AF_INET) &#123; return INADDR_NONE; &#125; //返回主机字节序 sin = (struct sockaddr_in *) addr.sockaddr; return ntohl(sin-&gt;sin_addr.s_addr);&#125;接下来看下ngx_http_geoip_city_variable函数实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static ngx_int_tngx_http_geoip_city_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)&#123; char *val; size_t len; GeoIPRecord *gr; //获取city record gr = ngx_http_geoip_get_city_record(r); if (gr == NULL) &#123; goto not_found; &#125; //获取val的值 val = *(char **) ((char *) gr + data); if (val == NULL) &#123; goto no_value; &#125; //获取变量长度 len = ngx_strlen(val); v-&gt;data = ngx_pnalloc(r-&gt;pool, len); if (v-&gt;data == NULL) &#123; GeoIPRecord_delete(gr); return NGX_ERROR; &#125; //复制变量值 ngx_memcpy(v-&gt;data, val, len); v-&gt;len = len; v-&gt;valid = 1; v-&gt;no_cacheable = 0; v-&gt;not_found = 0; //回收geoip资源 GeoIPRecord_delete(gr); return NGX_OK;no_value: GeoIPRecord_delete(gr);not_found: v-&gt;not_found = 1; return NGX_OK;&#125;以上就是geoip模块的所有内容","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的try_files模块","slug":"Nginx的try-files模块","date":"2023-02-26T15:59:53.000Z","updated":"2023-05-28T19:59:50.438Z","comments":true,"path":"2023/02/26/Nginx的try-files模块/","link":"","permalink":"https://weeweetan.github.io/2023/02/26/Nginx的try-files模块/","excerpt":"","text":"1.相关指令1234Syntax: try_files file ... uri;try_files file ... =code;Default: —Context: server, location2.配置解析函数首先看下配置解析函数ngx_http_try_files123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081static char *ngx_http_try_files(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_try_files_loc_conf_t *tlcf = conf; ngx_str_t *value; ngx_int_t code; ngx_uint_t i, n; ngx_http_try_file_t *tf; ngx_http_script_compile_t sc; //判断是否重复设置 if (tlcf-&gt;try_files) &#123; return \"is duplicate\"; &#125; // 申请必要内存，根据参数申请内存 tf = ngx_pcalloc(cf-&gt;pool, cf-&gt;args-&gt;nelts * sizeof(ngx_http_try_file_t)); if (tf == NULL) &#123; return NGX_CONF_ERROR; &#125; tlcf-&gt;try_files = tf; value = cf-&gt;args-&gt;elts; // 解析参数 for (i = 0; i &lt; cf-&gt;args-&gt;nelts - 1; i++) &#123; tf[i].name = value[i + 1]; // 判断当前参数是否可以作为文件查找的目录，如果是，则将test_dir置位 if (tf[i].name.len &gt; 0 &amp;&amp; tf[i].name.data[tf[i].name.len - 1] == '/' &amp;&amp; i + 2 &lt; cf-&gt;args-&gt;nelts) &#123; tf[i].test_dir = 1; tf[i].name.len--; tf[i].name.data[tf[i].name.len] = '\\0'; &#125; // 计算参数中的变量的个数 n = ngx_http_script_variables_count(&amp;tf[i].name); // 处理变量 if (n) &#123; ngx_memzero(&amp;sc, sizeof(ngx_http_script_compile_t)); sc.cf = cf; sc.source = &amp;tf[i].name; sc.lengths = &amp;tf[i].lengths; sc.values = &amp;tf[i].values; sc.variables = n; sc.complete_lengths = 1; sc.complete_values = 1; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; else &#123; /* add trailing '\\0' to length */ tf[i].name.len++; &#125; &#125; //如果最后一个参数第一个字符是=，则解析最后一个参数的code if (tf[i - 1].name.data[0] == '=') &#123; code = ngx_atoi(tf[i - 1].name.data + 1, tf[i - 1].name.len - 2); if (code == NGX_ERROR || code &gt; 999) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid code \\\"%*s\\\"\", tf[i - 1].name.len - 1, tf[i - 1].name.data); return NGX_CONF_ERROR; &#125; tf[i].code = code; &#125; return NGX_CONF_OK;&#125;filter模块需要在配置解析完成之后，在适当的阶段介入，在ngx_http_try_files_module_ctx中设置12345678910111213static ngx_http_module_t ngx_http_try_files_module_ctx = &#123; NULL, /* preconfiguration */ ngx_http_try_files_init, /* postconfiguration */ NULL, /* create main configuration */ NULL, /* init main configuration */ NULL, /* create server configuration */ NULL, /* merge server configuration */ ngx_http_try_files_create_loc_conf, /* create location configuration */ NULL /* merge location configuration */&#125;;看下ngx_http_try_files_init函数实现，可以看到try_files模块的filter在precontent阶段介入12345678910111213141516171819static ngx_int_tngx_http_try_files_init(ngx_conf_t *cf)&#123; ngx_http_handler_pt *h; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); // 从precontent阶段的handler中取一个 h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_PRECONTENT_PHASE].handlers); if (h == NULL) &#123; return NGX_ERROR; &#125; *h = ngx_http_try_files_handler; return NGX_OK;&#125;接下来看下ngx_http_try_files_handler模块具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211static ngx_int_tngx_http_try_files_handler(ngx_http_request_t *r)&#123; size_t len, root, alias, reserve, allocated; u_char *p, *name; ngx_str_t path, args; ngx_uint_t test_dir; ngx_http_try_file_t *tf; ngx_open_file_info_t of; ngx_http_script_code_pt code; ngx_http_script_engine_t e; ngx_http_core_loc_conf_t *clcf; ngx_http_script_len_code_pt lcode; ngx_http_try_files_loc_conf_t *tlcf; tlcf = ngx_http_get_module_loc_conf(r, ngx_http_try_files_module); //如果没有配置try_file直接返回 if (tlcf-&gt;try_files == NULL) &#123; return NGX_DECLINED; &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"try files handler\"); allocated = 0; root = 0; name = NULL; /* suppress MSVC warning */ path.data = NULL; tf = tlcf-&gt;try_files; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); // 获取location下配置的alias alias = clcf-&gt;alias; for ( ;; ) &#123; // 解析try_files后面的变量 if (tf-&gt;lengths) &#123; ngx_memzero(&amp;e, sizeof(ngx_http_script_engine_t)); e.ip = tf-&gt;lengths-&gt;elts; e.request = r; /* 1 is for terminating '\\0' as in static names */ len = 1; while (*(uintptr_t *) e.ip) &#123; lcode = *(ngx_http_script_len_code_pt *) e.ip; len += lcode(&amp;e); &#125; &#125; else &#123; len = tf-&gt;name.len; &#125; // 如果没有alias，则判断try_files第一个参数长度与uri的长度 if (!alias) &#123; reserve = len &gt; r-&gt;uri.len ? len - r-&gt;uri.len : 0; &#125; else if (alias == NGX_MAX_SIZE_T_VALUE) &#123; reserve = len; &#125; else &#123; reserve = len &gt; r-&gt;uri.len - alias ? len - (r-&gt;uri.len - alias) : 0; &#125; if (reserve &gt; allocated || !allocated) &#123; /* 16 bytes are preallocation */ allocated = reserve + 16; // 根据uri映射磁盘文件 if (ngx_http_map_uri_to_path(r, &amp;path, &amp;root, allocated) == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; name = path.data + root; &#125; if (tf-&gt;values == NULL) &#123; /* tf-&gt;name.len includes the terminating '\\0' */ ngx_memcpy(name, tf-&gt;name.data, tf-&gt;name.len); path.len = (name + tf-&gt;name.len - 1) - path.data; &#125; else &#123; e.ip = tf-&gt;values-&gt;elts; e.pos = name; e.flushed = 1; //处理变量 while (*(uintptr_t *) e.ip) &#123; code = *(ngx_http_script_code_pt *) e.ip; code((ngx_http_script_engine_t *) &amp;e); &#125; path.len = e.pos - path.data; *e.pos = '\\0'; if (alias &amp;&amp; alias != NGX_MAX_SIZE_T_VALUE &amp;&amp; ngx_strncmp(name, r-&gt;uri.data, alias) == 0) &#123; ngx_memmove(name, name + alias, len - alias); path.len -= alias; &#125; &#125; test_dir = tf-&gt;test_dir; // 指针后移 tf++; ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"trying to use %s: \\\"%s\\\" \\\"%s\\\"\", test_dir ? \"dir\" : \"file\", name, path.data); if (tf-&gt;lengths == NULL &amp;&amp; tf-&gt;name.len == 0) &#123; // 如果最后一个参数code有设置，则直接返回该code if (tf-&gt;code) &#123; return tf-&gt;code; &#125; path.len -= root; path.data += root; // 如果是@开头的path，则跳转到对应location if (path.data[0] == '@') &#123; (void) ngx_http_named_location(r, &amp;path); &#125; else &#123; ngx_http_split_args(r, &amp;path, &amp;args); //内部重定向 (void) ngx_http_internal_redirect(r, &amp;path, &amp;args); &#125; // 结束请求 ngx_http_finalize_request(r, NGX_DONE); return NGX_DONE; &#125; ngx_memzero(&amp;of, sizeof(ngx_open_file_info_t)); // 设置cache_file参数 of.read_ahead = clcf-&gt;read_ahead; of.directio = clcf-&gt;directio; of.valid = clcf-&gt;open_file_cache_valid; of.min_uses = clcf-&gt;open_file_cache_min_uses; of.test_only = 1; of.errors = clcf-&gt;open_file_cache_errors; of.events = clcf-&gt;open_file_cache_events; // 处理软链接 if (ngx_http_set_disable_symlinks(r, clcf, &amp;path, &amp;of) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; // 打开文件 if (ngx_open_cached_file(clcf-&gt;open_file_cache, &amp;path, &amp;of, r-&gt;pool) != NGX_OK) &#123; if (of.err == 0) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; if (of.err != NGX_ENOENT &amp;&amp; of.err != NGX_ENOTDIR &amp;&amp; of.err != NGX_ENAMETOOLONG) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, of.err, \"%s \\\"%s\\\" failed\", of.failed, path.data); &#125; continue; &#125; // 当前目录不可用于查找文件 if (of.is_dir != test_dir) &#123; continue; &#125; path.len -= root; path.data += root; if (!alias) &#123; r-&gt;uri = path; &#125; else if (alias == NGX_MAX_SIZE_T_VALUE) &#123; if (!test_dir) &#123; r-&gt;uri = path; r-&gt;add_uri_to_alias = 1; &#125; &#125; else &#123; name = r-&gt;uri.data; r-&gt;uri.len = alias + path.len; r-&gt;uri.data = ngx_pnalloc(r-&gt;pool, r-&gt;uri.len); if (r-&gt;uri.data == NULL) &#123; r-&gt;uri.len = 0; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; p = ngx_copy(r-&gt;uri.data, name, alias); // 保存path ngx_memcpy(p, path.data, path.len); &#125; // 设置文件后缀 ngx_http_set_exten(r); ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"try file uri: \\\"%V\\\"\", &amp;r-&gt;uri); return NGX_DECLINED; &#125; /* not reached */3.总结以上就是try_files模块的详解，从指令到handler都进行了一些说明。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的header_filter模块","slug":"Nginx的header-filter模块","date":"2022-12-16T15:41:15.000Z","updated":"2023-02-26T15:55:03.390Z","comments":true,"path":"2022/12/16/Nginx的header-filter模块/","link":"","permalink":"https://weeweetan.github.io/2022/12/16/Nginx的header-filter模块/","excerpt":"","text":"1.相关指令header_filter模块主要有以下几个指令123Syntax: add_header name value [always];Default: —12345Context: http, server, location, if in locationSyntax: add_trailer name value [always];Default: —Context: http, server, location, if in locationThis directive appeared in version 1.13.2.123456Syntax: expires [modified] time;expires epoch | max | off;Default: expires off;Context: http, server, location, if in location配置示例123456789expires 24h;expires modified +24h;expires @24h;expires 0;expires -1;expires epoch;expires $expires;add_header Cache-Control private;2. 源码解析2.1 配置解析函数首先来看下add_header指令解析函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283static char *ngx_http_headers_add(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_headers_conf_t *hcf = conf; ngx_str_t *value; ngx_uint_t i; ngx_array_t **headers; ngx_http_header_val_t *hv; ngx_http_set_header_t *set; ngx_http_compile_complex_value_t ccv; value = cf-&gt;args-&gt;elts; // 取到数组指针 headers = (ngx_array_t **) ((char *) hcf + cmd-&gt;offset); if (*headers == NULL) &#123; *headers = ngx_array_create(cf-&gt;pool, 1, sizeof(ngx_http_header_val_t)); if (*headers == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; //从数组中push一个元素 hv = ngx_array_push(*headers); if (hv == NULL) &#123; return NGX_CONF_ERROR; &#125; // 取配置header的key hv-&gt;key = value[1]; hv-&gt;handler = NULL; hv-&gt;offset = 0; hv-&gt;always = 0; if (headers == &amp;hcf-&gt;headers) &#123; hv-&gt;handler = ngx_http_add_header; set = ngx_http_set_headers; for (i = 0; set[i].name.len; i++) &#123; if (ngx_strcasecmp(value[1].data, set[i].name.data) != 0) &#123; continue; &#125; hv-&gt;offset = set[i].offset; hv-&gt;handler = set[i].handler; break; &#125; &#125; if (value[2].len == 0) &#123; ngx_memzero(&amp;hv-&gt;value, sizeof(ngx_http_complex_value_t)); &#125; else &#123; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[2]; ccv.complex_value = &amp;hv-&gt;value; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; if (cf-&gt;args-&gt;nelts == 3) &#123; return NGX_CONF_OK; &#125; if (ngx_strcmp(value[3].data, &quot;always&quot;) != 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid parameter \\&quot;%V\\&quot;&quot;, &amp;value[3]); return NGX_CONF_ERROR; &#125; hv-&gt;always = 1; return NGX_CONF_OK;&#125;接下来看下expires指令解析函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static char *ngx_http_headers_expires(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_headers_conf_t *hcf = conf; char *err; ngx_str_t *value; ngx_int_t rc; ngx_uint_t n; ngx_http_complex_value_t cv; ngx_http_compile_complex_value_t ccv; // 判断是否已经设置过该指令 if (hcf-&gt;expires != NGX_HTTP_EXPIRES_UNSET) &#123; return &quot;is duplicate&quot;; &#125; value = cf-&gt;args-&gt;elts; //判断指令后的参数 if (cf-&gt;args-&gt;nelts == 2) &#123; hcf-&gt;expires = NGX_HTTP_EXPIRES_ACCESS; n = 1; &#125; else &#123; /* cf-&gt;args-&gt;nelts == 3 */ if (ngx_strcmp(value[1].data, &quot;modified&quot;) != 0) &#123; return &quot;invalid value&quot;; &#125; hcf-&gt;expires = NGX_HTTP_EXPIRES_MODIFIED; n = 2; &#125; // 准备变量 ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[n]; ccv.complex_value = &amp;cv; //编译变量 if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (cv.lengths != NULL) &#123; hcf-&gt;expires_value = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t)); if (hcf-&gt;expires_value == NULL) &#123; return NGX_CONF_ERROR; &#125; *hcf-&gt;expires_value = cv; return NGX_CONF_OK; &#125; rc = ngx_http_parse_expires(&amp;value[n], &amp;hcf-&gt;expires, &amp;hcf-&gt;expires_time, &amp;err); if (rc != NGX_OK) &#123; return err; &#125; return NGX_CONF_OK;&#125;2.2 filter函数2.2.1 headers_filter函数首先看下ngx_http_headers_filter函数实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182static ngx_int_tngx_http_headers_filter(ngx_http_request_t *r)&#123; ngx_str_t value; ngx_uint_t i, safe_status; ngx_http_header_val_t *h; ngx_http_headers_conf_t *conf; // 子请求不做处理，直接返回 if (r != r-&gt;main) &#123; return ngx_http_next_header_filter(r); &#125; // 获取location级别配置 conf = ngx_http_get_module_loc_conf(r, ngx_http_headers_filter_module); if (conf-&gt;expires == NGX_HTTP_EXPIRES_OFF &amp;&amp; conf-&gt;headers == NULL &amp;&amp; conf-&gt;trailers == NULL) &#123; return ngx_http_next_header_filter(r); &#125; switch (r-&gt;headers_out.status) &#123; case NGX_HTTP_OK: case NGX_HTTP_CREATED: case NGX_HTTP_NO_CONTENT: case NGX_HTTP_PARTIAL_CONTENT: case NGX_HTTP_MOVED_PERMANENTLY: case NGX_HTTP_MOVED_TEMPORARILY: case NGX_HTTP_SEE_OTHER: case NGX_HTTP_NOT_MODIFIED: case NGX_HTTP_TEMPORARY_REDIRECT: case NGX_HTTP_PERMANENT_REDIRECT: safe_status = 1; break; default: safe_status = 0; break; &#125; if (conf-&gt;expires != NGX_HTTP_EXPIRES_OFF &amp;&amp; safe_status) &#123; if (ngx_http_set_expires(r, conf) != NGX_OK) &#123; return NGX_ERROR; &#125; &#125; if (conf-&gt;headers) &#123; h = conf-&gt;headers-&gt;elts; for (i = 0; i &lt; conf-&gt;headers-&gt;nelts; i++) &#123; if (!safe_status &amp;&amp; !h[i].always) &#123; continue; &#125; if (ngx_http_complex_value(r, &amp;h[i].value, &amp;value) != NGX_OK) &#123; return NGX_ERROR; &#125; if (h[i].handler(r, &amp;h[i], &amp;value) != NGX_OK) &#123; return NGX_ERROR; &#125; &#125; &#125; if (conf-&gt;trailers) &#123; h = conf-&gt;trailers-&gt;elts; for (i = 0; i &lt; conf-&gt;trailers-&gt;nelts; i++) &#123; if (!safe_status &amp;&amp; !h[i].always) &#123; continue; &#125; r-&gt;expect_trailers = 1; break; &#125; &#125; return ngx_http_next_header_filter(r);&#125;2.2.2 ngx_http_trailers_filter函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182static ngx_int_tngx_http_trailers_filter(ngx_http_request_t *r, ngx_chain_t *in)&#123; ngx_str_t value; ngx_uint_t i, safe_status; ngx_chain_t *cl; ngx_table_elt_t *t; ngx_http_header_val_t *h; ngx_http_headers_conf_t *conf; //获取location级别配置 conf = ngx_http_get_module_loc_conf(r, ngx_http_headers_filter_module); // 如果满足如下条件，则跳过本filter if (in == NULL || conf-&gt;trailers == NULL || !r-&gt;expect_trailers || r-&gt;header_only) &#123; return ngx_http_next_body_filter(r, in); &#125; // 找到最后一个buf for (cl = in; cl; cl = cl-&gt;next) &#123; if (cl-&gt;buf-&gt;last_buf) &#123; break; &#125; &#125; // 如果cl为null，则跳过本filter if (cl == NULL) &#123; return ngx_http_next_body_filter(r, in); &#125; // 根据响应码做选择 switch (r-&gt;headers_out.status) &#123; case NGX_HTTP_OK: case NGX_HTTP_CREATED: case NGX_HTTP_NO_CONTENT: case NGX_HTTP_PARTIAL_CONTENT: case NGX_HTTP_MOVED_PERMANENTLY: case NGX_HTTP_MOVED_TEMPORARILY: case NGX_HTTP_SEE_OTHER: case NGX_HTTP_NOT_MODIFIED: case NGX_HTTP_TEMPORARY_REDIRECT: case NGX_HTTP_PERMANENT_REDIRECT: safe_status = 1; break; default: safe_status = 0; break; &#125; // 遍历配置的所有trailer h = conf-&gt;trailers-&gt;elts; for (i = 0; i &lt; conf-&gt;trailers-&gt;nelts; i++) &#123; if (!safe_status &amp;&amp; !h[i].always) &#123; continue; &#125; if (ngx_http_complex_value(r, &amp;h[i].value, &amp;value) != NGX_OK) &#123; return NGX_ERROR; &#125; if (value.len) &#123; t = ngx_list_push(&amp;r-&gt;headers_out.trailers); if (t == NULL) &#123; return NGX_ERROR; &#125; t-&gt;key = h[i].key; t-&gt;value = value; t-&gt;hash = 1; &#125; &#125; return ngx_http_next_body_filter(r, in);&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"docker下安装使用systemptap","slug":"docker下安装使用systemptap","date":"2022-03-12T09:50:26.000Z","updated":"2022-03-14T15:07:44.066Z","comments":true,"path":"2022/03/12/docker下安装使用systemptap/","link":"","permalink":"https://weeweetan.github.io/2022/03/12/docker下安装使用systemptap/","excerpt":"","text":"","categories":[],"tags":[{"name":"systemtap","slug":"systemtap","permalink":"https://weeweetan.github.io/tags/systemtap/"}]},{"title":"systemtap调试技巧","slug":"systemtap调试技巧","date":"2021-12-28T14:16:25.000Z","updated":"2024-02-27T13:56:59.888Z","comments":true,"path":"2021/12/28/systemtap调试技巧/","link":"","permalink":"https://weeweetan.github.io/2021/12/28/systemtap调试技巧/","excerpt":"","text":"1、安装Centos1.1 必要库1yum -y install elfutils、gcc、kernel-devel、kernel-debuginfo、yum-utils1.2 yum安装1yum -y systemtapUbuntu1.1 必要库1234$ apt-get install build-essential$ apt-get install gettext$ apt-get install elfutils$ apt-get install libdw-dev1.2 源码安装12345$ git clone git://sourceware.org/git/systemtap.git$ cd systemtap$ git checkout release-4.9$ ./configure$ make -j (getconf _NPROCESSORS_ONLN)目前需要使用release4.9分支，安装完成后，在/usr/local/systemtap2、入门2.1、简介SystemTap是一个Linux非常有用的调试（跟踪/探测）工具，常用于Linux内核或者应用程序的信息采集，需要编译时，指定-g选项，比如：获取一个函数里面运行时的变量、调用堆栈，甚至可以直接修改变量的值，对诊断性能或功能问题非常有帮助。SystemTap提供非常简单的命令行接口和很简洁的脚本语言，以及非常丰富的tapset和例子。2.2、何时使用定位（内核）函数位置查看函数被调用时的调用堆栈、局部变量、参数查看函数指针变量实际指的是哪个函数查看代码的执行轨迹（哪些行被执行了）查看内核或者进程的执行流程调试内存泄露或者内存重复释放统计函数调用次数……2.3、stap命令123456789101112131415stap [OPTIONS] FILENAME [ARGUMENTS]stap [OPTIONS] - [ARGUMENTS]stap [OPTIONS] –e SCRIPT [ARGUMENTS]比较常用和有用的参数：-e SCRIPT Run given script.-l PROBE List matching probes.-L PROBE List matching probes and local variables.-g guru mode -D NM=VAL emit macro definition into generated C code-o FILE send script output to file, instead of stdout.-x PID sets target() to PID-T time set execute time-G var=val set variable-d object add trace object2.4、staprun命令1staprun [OPTIONS] MODULE [MODULE-OPTIONS]stap命令与staprun命令的区别在于：stap命令的操作对象是stp文件或script命令等，而staprun命令的操作对象是编译生成的内核模块。3、脚本语言3.1、probe“probe” &lt;=&gt; “探测”, 是SystemTap进行具体地收集数据的关键字。“probe point” 是probe动作的时机，也称探测点。也就是probe程序监视的某事件点，一旦侦测的事件触发了，则probe将从此处插入内核或者用户进程中。“probe handle” 是当probe插入内核或者用户进程后所做的具体动作。probe用法：1probe probe-point &#123; statement &#125;在Hello World例子中begin和end就是probe-point， statement就是该探测点的处理逻辑，在Hello World例子中statement只有一行print，statement可以是复杂的代码块。探测点语法：123456789101112131415161718kernel.function(PATTERN)kernel.function(PATTERN).callkernel.function(PATTERN).returnkernel.function(PATTERN).return.maxactive(VALUE)kernel.function(PATTERN).inlinekernel.function(PATTERN).label(LPATTERN)module(MPATTERN).function(PATTERN)module(MPATTERN).function(PATTERN).callmodule(MPATTERN).function(PATTERN).return.maxactive(VALUE)module(MPATTERN).function(PATTERN).inlinekernel.statement(PATTERN)kernel.statement(ADDRESS).absolutemodule(MPATTERN).statement(PATTERN)process(PROCESSPATH).function(PATTERN)process(PROCESSPATH).function(PATTERN).callprocess(PROCESSPATH).function(PATTERN).returnprocess(PROCESSPATH).function(PATTERN).inlineprocess(PROCESSPATH).statement(PATTERN)PATTERN语法为：12func[@file]func@file:linenumber例如：1234kernel.function(\"*init*\")module(\"ext3\").function(\"*\")kernel.statement(\"*@kernel/time.c:296\")process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_process_request\")在return探测点可以用&dollar;return获取该函数的返回值。inline函数无法安装.return探测点，也无法用$return获取其返回值。3.2 基本语法SystemTap脚本语法比较简单，与C语言类似，只是每一行结尾”;”是可选的。主要语句如下：if/else、while、for/foreach、break/continue、return、next、delete、try/catch其中：next：主要在probe探测点逻辑处理中使用，调用此语句时，立刻从调用函数中退出。不同于exit()的是，next只是退出当前的调用函数，而此SystemTap并没有终了，但exit()则会终止SystemTap。3.3 变量不需要明确声明变量类型，脚本语言会根据函数参数等自动判断变量是什么类型的。局部变量：在声明的probe和block（”{ }“范围内的部分）内有效。全局变量：用”global“声明的变量，在此SystemTap的整个动作过程中都有效。全局变量的声明位置没有具体要求。需要注意的是，全局变量默认有锁保护，使用过多会有性能损失，如果用全局变量保存指针，可能出现指针所指的内容被进程修改，在探测点中拿不到真正的数据。获取进程中的变量（全局变量、局部变量、参数）直接在变量名前面加$即可。3.4 注释123# ...... ： Shell语言风格 //...... ： C++语言风格 /*......*/ ： C语言风格3.5 运算符比较运算符、算数运算符基本上与C语言一样，需要特别指出的是：(1)、.操作符：连接两个字符串，类似于php；(2)、=~和!~：正则匹配和正则不匹配；3.6 函数函数的例子123456789101112131415function indent:string (delta:long)&#123; return _generic_indent(-1, \"\", delta)&#125;function _generic_indent (idx, desc, delta)&#123; ts = __indent_timestamp () if (! _indent_counters[idx]) _indent_timestamps[idx] = ts depth = _generic_indent_depth(idx, delta) return sprintf(\"%6d (%d:%d) %s:%-*s\", (ts - _indent_timestamps[idx]), depth, delta, desc, depth, \"\")&#125; function strlen:long(s:string) %&#123; STAP_RETURN(strlen(STAP_ARG_s));%&#125; 官方有很多很有用的函数，详情请参考：https://sourceware.org/systemtap/tapsets/以及在本机安装了SystemTap之后在目录/usr/local/share/systemtap/tapset/下也可以看具体函数的实现以及一些奇特的用法。3.7、技巧3.7.1、定位函数位置在一个大型项目中找出函数在哪里定义有时很有用，特别是一些比较难找出在哪里定义的函数，比如内核或者glibc中的某个函数想要看其实现时，首先得找出其在哪个文件的哪一行定义，用SystemTap一行命令就可以搞定。比如要看printf在glibc中哪里定义的：12root@j9 ~# stap -l 'kernel.function(\"sys_recv\")'kernel.function(\"sys_recv@/build/buildd/linux-lts-trusty-3.13.0/net/socket.c:1868\")可以看出recv是在socket.c第1868行定义的。甚至可以*号来模糊查找：1234567891011121314root@j9 ~# stap -l 'kernel.function(\"*recv\")' kernel.function(\"__audit_mq_sendrecv@/build/buildd/linux-lts-trusty-3.13.0/kernel/auditsc.c:2062\")kernel.function(\"audit_mq_sendrecv@/build/buildd/linux-lts-trusty-3.13.0/include/linux/audit.h:263\")kernel.function(\"compat_sys_recv@/build/buildd/linux-lts-trusty-3.13.0/net/compat.c:762\")kernel.function(\"i2c_master_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/i2c/i2c-core.c:1827\")kernel.function(\"ip_cmsg_recv@/build/buildd/linux-lts-trusty-3.13.0/net/ipv4/ip_sockglue.c:147\")kernel.function(\"kgdb_tty_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/tty/serial/kgdb_nmi.c:109\")kernel.function(\"ppp_do_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/net/ppp/ppp_generic.c:1617\")kernel.function(\"scm_recv@/build/buildd/linux-lts-trusty-3.13.0/include/net/scm.h:109\")kernel.function(\"sys_recv@/build/buildd/linux-lts-trusty-3.13.0/net/socket.c:1868\")kernel.function(\"tcp_event_data_recv@/build/buildd/linux-lts-trusty-3.13.0/net/ipv4/tcp_input.c:615\")kernel.function(\"tcp_splice_data_recv@/build/buildd/linux-lts-trusty-3.13.0/net/ipv4/tcp.c:637\")kernel.function(\"tpm_tis_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/char/tpm/tpm_tis.c:231\")kernel.function(\"try_fill_recv@/build/buildd/linux-lts-trusty-3.13.0/drivers/net/virtio_net.c:615\")同理，也可以用来定位用户进程的函数位置：比如tengine的文件ngx_shmem.c里面为了兼容各个操作系统而实现了三个版本的ngx_shm_alloc，用#if (NGX_HAVE_MAP_ANON)、#elif (NGX_HAVE_MAP_DEVZERO)、#elif (NGX_HAVE_SYSVSHM)、#endif来做条件编译，那怎么知道编译出来的是哪个版本呢，用SystemTap的话就很简单了，否则要去grep一下这几宏有没有定义才知道了。12[root@cache4 tengine]# stap -l 'process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_shm_alloc\")'process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_shm_alloc@src/os/unix/ngx_shmem.c:15\")3.7.2 查看可用探测点以及该探测点上可用的变量在一些探测点上能获取的变量比较有限，这是因为这些变量可能已经被编译器优化掉了，优化掉的变量就获取不到了。一般先用-L参数来看看有哪些变量可以直接使用：12[root@cache4 tengine]# stap -L 'process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_shm_alloc\")' process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_shm_alloc@src/os/unix/ngx_shmem.c:15\") $shm:ngx_shm_t*可见在该探测点上可以直接使用$shm这个变量，其类型是ngx_shm_t*。statement探测点也类似：12345[root@cache4 tengine]# stap -L 'process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_pcalloc@src/core/ngx_palloc.c:*\")' process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_pcalloc@src/core/ngx_palloc.c:395\") $pool:ngx_pool_t* $size:size_tprocess(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_pcalloc@src/core/ngx_palloc.c:398\") $pool:ngx_pool_t* $size:size_tprocess(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_pcalloc@src/core/ngx_palloc.c:399\") $size:size_tprocess(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_pcalloc@src/core/ngx_palloc.c:404\") $size:size_t $p:void*可以直接使用这些探测点3.7.3 输出调用堆栈用户态探测点堆栈：print_ubacktrace()、sprint_ubacktrace()内核态探测点堆栈：print_backtrace()、sprint_backtrace()不带s和带s的区别是前者直接输出，后者是返回堆栈字符串。这几个函数非常有用，在排查问题时可以根据一些特定条件来过滤函数被执行时是怎么调用进来的，比如排查tengine返回5xx时的调用堆栈是怎样的：123456789101112131415161718192021222324#cat debug_tengine_5xx.stp probe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_finalize_request\").call &#123; if ($rc &gt;= 500) &#123; printf(\"rc: %d\\n\", $rc) print_ubacktrace() &#125;&#125;#stap debug_tengine_5xx.stp rc: 502 0x49af2e : ngx_http_finalize_request+0xe/0x480 [/home/admin/tengine/bin/nginx] 0x543305 : ngx_http_video_flv_send_rest+0xf5/0x380 [/home/admin/tengine/bin/nginx] 0x543187 : ngx_http_video_finalize_request+0x57/0xe0 [/home/admin/tengine/bin/nginx] 0x49828f : ngx_http_terminate_request+0x4f/0xc0 [/home/admin/tengine/bin/nginx] 0x49b760 : ngx_http_test_reading+0x50/0x130 [/home/admin/tengine/bin/nginx] 0x49779f : ngx_http_request_handler+0x1f/0x40 [/home/admin/tengine/bin/nginx] 0x47ea8f : ngx_epoll_process_events+0x2df/0x330 [/home/admin/tengine/bin/nginx] 0x4753f9 : ngx_process_events_and_timers+0x69/0x1c0 [/home/admin/tengine/bin/nginx] 0x47d4d8 : ngx_worker_process_cycle+0x138/0x260 [/home/admin/tengine/bin/nginx] 0x47a38a : ngx_spawn_process+0x1ca/0x5e0 [/home/admin/tengine/bin/nginx] 0x47c73c : ngx_start_worker_processes+0x7c/0x100 [/home/admin/tengine/bin/nginx] 0x47db5f : ngx_master_process_cycle+0x3af/0x9b0 [/home/admin/tengine/bin/nginx] 0x45a740 : main+0xa90/0xb50 [/home/admin/tengine/bin/nginx] 0x3623e1ecdd [/lib64/libc-2.12.so+0x1ecdd/0x38d000]比如看看内核是怎么收包的：12345678910111213141516171819root@jusse ~# cat netif_receive_skb.stp probe kernel.function(\"netif_receive_skb\") &#123; printf(\"--------------------------------------------------------\\n\"); print_backtrace(); printf(\"--------------------------------------------------------\\n\"); &#125; root@jusse ~# stap netif_receive_skb.stp-------------------------------------------------------- 0xffffffff8164dc00 : netif_receive_skb+0x0/0x90 [kernel] 0xffffffff8164e280 : napi_gro_receive+0xb0/0x130 [kernel] 0xffffffff81554537 : handle_incoming_queue+0xe7/0x100 [kernel] 0xffffffff815555d9 : xennet_poll+0x279/0x430 [kernel] 0xffffffff8164ee09 : net_rx_action+0x139/0x250 [kernel] 0xffffffff810702cd : __do_softirq+0xdd/0x300 [kernel] 0xffffffff8107088e : irq_exit+0x11e/0x140 [kernel] 0xffffffff8144e785 : xen_evtchn_do_upcall+0x35/0x50 [kernel] 0xffffffff8176c9ed : xen_hvm_callback_vector+0x6d/0x80 [kernel]--------------------------------------------------------3.7.4 获取函数参数一些被编译器优化掉的函数参数用-L去看的时候没有找到，这样的话在探测点里面也不能直接用$方式获取该参数变量，这时可以使用SystemTap提供的_arg函数接口，是根据类型指定的，比如pointer_arg是获取指针类型参数，int_arg是获取整型参数，类似的还有long_arg、longlong_arg、uint_arg、ulong_arg、ulonglong_arg、s32_arg、s64_arg、u32_arg、u64_arg：12345678910111213root@j9 ~# stap -L 'kernel.function(\"sys_open\")' kernel.function(\"SyS_open@/build/buildd/linux-lts-trusty-3.13.0/fs/open.c:1011\") $ret:long introot@j9 ~# cat sys_open.stp probe kernel.function(\"sys_open\").call&#123; printf(\"filename: %p(%s), flags: %d, mode: %x\\n\", pointer_arg(1), kernel_string(pointer_arg(1)), int_arg(2), int_arg(3));&#125;root@j9 ~# stap sys_open.stp filename: 0xc2081d2120(/proc/stat), flags: 524288, mode: 0filename: 0x7facec00e838(/root/opt/libexec/systemtap/stapio), flags: 0, mode: 1b6filename: 0x2219488(/var/log/auth.log), flags: 0, mode: 1b6filename: 0x7facec00e838(/root/opt/libexec/systemtap/stapio), flags: 0, mode: 1b6filename: 0x7fad10172c29(/etc/passwd), flags: 524288, mode: 1b6这两个函数的参数完全兼容，只是第二个参数命名不一样而已，可以像下面这么用：12345678#cat debug_tengine_5xx.stp probe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_finalize_request\").call, process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_special_response_handler\").call &#123; rc = int_arg(2) if (rc &gt;= 500) &#123; printf(\"rc: %d\\n\", rc) print_ubacktrace() &#125;&#125;3.7.5 获取全局变量有时候用$可以直接获取到全局变量，但有时候又获取不到，那可以试试@var：比如获取nginx的全局变量ngx_cycyle：123456789101112131415161718192021222324root@j9 ~# cat get_ngx_cycle.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_process_events_and_timers\").call &#123; printf(\"ngx_cycle-&gt;connections: %d\\n\", $ngx_cycle-&gt;connections) exit()&#125;root@j9 ~# stap get_ngx_cycle.stpsemantic error: while processing probe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_process_events_and_timers@src/event/ngx_event.c:225\").call from: process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_process_events_and_timers\").callsemantic error: unable to find local 'ngx_cycle', [man error::dwarf] dieoffset 0x73ca8 in /home/admin/tengine/bin/nginx, near pc 0x434152 in ngx_process_events_and_timers src/event/ngx_event.c (alternatives: $cycle, $delta, $timer, $flags)): identifier '$ngx_cycle' at get_ngx_cycle.stp:3:44 source: printf(\"ngx_cycle-&gt;connections: %d\\n\", $ngx_cycle-&gt;connections) ^Pass 2: analysis failed. [man error::pass2]root@j9 ~# cat get_ngx_cycle.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_process_events_and_timers\").call &#123; ngx_cycle = @var(\"ngx_cycle@src/core/ngx_cycle.c\") printf(\"ngx_cycle-&gt;connections: %d\\n\", ngx_cycle-&gt;connections) exit()&#125;root@j9 ~# stap get_ngx_cycle.stpngx_cycle-&gt;connections: 195073123.7.6 获取数据结构成员用法12345678910111213141516171819202122232425262728293031#cat get_http_uri.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_process_request\").call &#123; printf(\"r-&gt;uri.len: %d, r-&gt;uri.data: %p\\n\", $r-&gt;uri.len, $r-&gt;uri.data)&#125;#stap get_http_uri.stpWARNING: never-assigned local variable 'len' (similar: data): identifier 'len' at get_http_uri.stp:2:57 source: printf(\"r-&gt;uri.len: %d, r-&gt;uri.data: %p\\n\", $r-&gt;uri.len, $r-&gt;uri.data) ^WARNING: never-assigned local variable 'data' (similar: len): identifier 'data' at :2:70 source: printf(\"r-&gt;uri.len: %d, r-&gt;uri.data: %p\\n\", $r-&gt;uri.len, $r-&gt;uri.data) ^semantic error: invalid operator: operator '.' at :2:56 source: printf(\"r-&gt;uri.len: %d, r-&gt;uri.data: %p\\n\", $r-&gt;uri.len, $r-&gt;uri.data) ^semantic error: type mismatch: expected long but found string: operator '.' at :2:56 source: printf(\"r-&gt;uri.len: %d, r-&gt;uri.data: %p\\n\", $r-&gt;uri.len, $r-&gt;uri.data) ^Pass 2: analysis failed. [man error::pass2]#cat get_http_uri.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_process_request\").call &#123; printf(\"r-&gt;uri.len: %d, r-&gt;uri.data: %p\\n\", $r-&gt;uri-&gt;len, $r-&gt;uri-&gt;data)&#125;#stap get_http_uri.stpr-&gt;uri.len: 1, r-&gt;uri.data: 0x1276f94r-&gt;uri.len: 1, r-&gt;uri.data: 0x11d5fc4r-&gt;uri.len: 1, r-&gt;uri.data: 0x124fd24^C3.7.7 输出整个数据结构SystemTap有两个语法可以输出整个数据结构：在变量的后面加一个或者两个$即可，例子如下：1234567#cat get_r_pool.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_process_request\").call &#123; printf(\"$r-&gt;pool$: %s\\n$r-&gt;pool$$: %s\\n\", $r-&gt;pool$, $r-&gt;pool$$)&#125;#stap get_r_pool.stp$r-&gt;pool$: &#123;.d=&#123;...&#125;, .max=4016, .current=0x161acd0, .chain=0x0, .large=0x0, .cleanup=0x0, .log=0x161c690&#125;$r-&gt;pool$$: &#123;.d=&#123;.last=\"a\", .end=\"\", .next=0x1617650, .failed=0&#125;, .max=4016, .current=0x161acd0, .chain=0x0, .large=0x0, .cleanup=0x0, .log=0x161c690&#125;其中r-&gt;pool的结构如下：1234567891011121314151617181920typedef struct &#123; u_char *last; u_char *end; ngx_pool_t *next; ngx_uint_t failed;&#125; ngx_pool_data_t;struct ngx_pool_s &#123; ngx_pool_data_t d; size_t max; ngx_pool_t *current; ngx_chain_t *chain; ngx_pool_large_t *large; ngx_pool_cleanup_t *cleanup; ngx_log_t *log;#if (NGX_DEBUG_POOL) size_t size; ngx_pool_stat_t *stat;#endif&#125;;ngx_pool_s包含了结构ngx_pool_data_t。变量后面加和$的区别是后者展开了里面的结构而前者不展开，此用法只输出基本数据类型的值。3.7.8 输出字符串指针用户态使用：user_string、user_string_n内核态使用：kernel_string、kernel_string_n、user_string_quoted123456789#cat get_http_uri.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_process_request\").call &#123; printf(\"r-&gt;uri: %s\\nr-&gt;uri(n): %s\\n\", user_string($r-&gt;uri-&gt;data), user_string_n($r-&gt;uri-&gt;data, $r-&gt;uri-&gt;len))&#125;#stap get_http_uri.stpr-&gt;uri: /?id=1 HTTP/1.1User-Agentr-&gt;uri(n): /user_string_quoted是获取用户态传给内核的字符串，代码中一般有__user宏标记：123456789#cat sys_open.stpprobe kernel.function(\"sys_open\")&#123; printf(\"filename: %s\\n\", user_string_quoted(pointer_arg(1)));&#125;#stap sys_open.stp filename: \"/var/log/auth.log\"filename: \"/proc/stat\"filename: \"/proc/uptime\"3.7.9 指针类型转换SystemTap提供@cast来实现指针类型转换，比如可以将void *转成自己需要的类型123456789101112#cat get_c_fd.stp probe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_process_request_line\").call &#123; printf(\"c-&gt;fd: %d\\n\", @cast($rev-&gt;data, \"ngx_connection_t\")-&gt;fd)&#125;#stap get_c_fd.stp c-&gt;fd: 3c-&gt;fd: 28c-&gt;fd: 30c-&gt;fd: 32c-&gt;fd: 34^C3.7.10 定义某个类型的变量同样是用@cast，定义一个变量用来保存其转换后的地址即可，用法如下：1234567891011#cat get_c.stp probe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_process_request_line\").call &#123; c = &amp;@cast($rev-&gt;data, \"ngx_connection_t\") printf(\"c-&gt;fd: %d, c-&gt;requests: %d\\n\", c-&gt;fd, c-&gt;requests)&#125;#stap get_c.stp c-&gt;fd: 3, c-&gt;requests: 1c-&gt;fd: 28, c-&gt;requests: 1c-&gt;fd: 30, c-&gt;requests: 1^C3.7.11 多级指针用法123456789101112131415161718192021222324252627282930313233root@j9 ~# cat cc_multi_pointer.c#include &lt;stdio.h&gt;struct test &#123; int count;&#125;;int main(int argc, char *argv[])&#123; struct test t = &#123;.count = 5566&#125;; struct test *pt = &amp;t; struct test **ppt = &amp;pt; printf(\"t.count: %d, pt-&gt;count: %d, ppt-&gt;count: %d\\n\", t.count, pt-&gt;count, (*ppt)-&gt;count); return 0;&#125;root@j9 ~# gcc -Wall -g -o cc_multi_pointer ./cc_multi_pointer.croot@j9 ~# cat cc_multi_pointer.stpprobe process(\"./cc_multi_pointer\").statement(\"main@./cc_multi_pointer.c:13\")&#123; printf(\"$t-&gt;count: %d, $pt-&gt;count: %d, $ppt-&gt;count: %d\", $t-&gt;count, $pt-&gt;count, $ppt[0]-&gt;count);&#125;root@j9 ~# ./cc_multi_pointert.count: 5566, pt-&gt;count: 5566, ppt-&gt;count: 5566root@j9 ~# stap ./cc_multi_pointer.stp -c './cc_multi_pointer't.count: 5566, pt-&gt;count: 5566, ppt-&gt;count: 5566$t-&gt;count: 5566, $pt-&gt;count: 5566, $ppt-&gt;count: 5566简言之：通过[0]去解引用即可3.7.12 遍历C语言数组下面是在nginx处理请求关闭时遍历请求头的例子：123456789101112131415161718192021222324#cat debug_http_header.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_finalize_request\").call &#123; i = 0 headers_in_part = &amp;$r-&gt;headers_in-&gt;headers-&gt;part headers = &amp;@cast(headers_in_part-&gt;elts, \"ngx_table_elt_t\")[0] while (headers) &#123; if (i &gt;= headers_in_part-&gt;nelts) &#123; if (!headers_in_part-&gt;next) &#123; break &#125; headers_in_part = headers_in_part-&gt;next; headers = &amp;@cast(headers_in_part-&gt;elts, \"ngx_table_elt_t\")[0] i = 0 &#125; h = &amp;@cast(headers, \"ngx_table_elt_t\")[i] printf(\"%s: %s\\n\", user_string_n(h-&gt;key-&gt;data, h-&gt;key-&gt;len), user_string_n(h-&gt;value-&gt;data, h-&gt;value-&gt;len)) i += 1 &#125;&#125;#stap debug_http_header.stpUser-Agent: curl/7.29.0Host: 127.0.0.1:20090Accept: */*3.7.13 查看函数指针所指的函数名获取一个地址所对应的符号：用户态：usymname内核态：symname123456789#cat get_c_handler.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"ngx_http_process_request_line\").call &#123; c = &amp;@cast($rev-&gt;data, \"ngx_connection_t\") printf(\"c-&gt;read-&gt;handlers: %s, c-&gt;write-&gt;handler: %s\\n\", usymname(c-&gt;read-&gt;handler), usymname(c-&gt;write-&gt;handler))&#125;#stap get_c_handler.stpc-&gt;read-&gt;handlers: ngx_http_process_request_line, c-&gt;write-&gt;handler: ngx_http_empty_handler^C3.7.14 修改进程中的变量1234567891011121314151617181920212223242526272829303132333435363738root@j9 ~# cat stap_set_var.c -n 1 #include &lt;stdio.h&gt; 2 3 typedef struct policy &#123; 4 int id; 5 &#125; policy_t; 6 7 int main(int argc, char *argv[]) 8 &#123; 9 policy_t policy; 10 policy_t *p = &amp;policy; 11 policy_t **pp; 12 13 p-&gt;id = 111; 14 15 printf(\"before stap set, p-&gt;id: %d\\n\", p-&gt;id); 16 17 pp = &amp;p; 18 19 printf(\"after stap set, p-&gt;id: %d, (*pp)-&gt;id: %d\\n\", p-&gt;id, (*pp)-&gt;id); 20 21 return 0; 22 &#125;root@j9 ~# gcc -Wall -g -o ./stap_set_var ./stap_set_var.croot@j9 ~# cat stap_set_var.stpprobe process(\"./stap_set_var\").statement(\"main@./stap_set_var.c:17\")&#123; $p-&gt;id = 222; printf(\"$p$: %s\\n\", $p$)&#125;root@j9 ~# stap -g stap_set_var.stp -c ./stap_set_varbefore stap set, p-&gt;id: 111after stap set, p-&gt;id: 222, (*pp)-&gt;id: 222$p$: &#123;.id=222&#125;可以看出在第17行用SystemTap修改后的值在第19行就生效了。需要注意的是stap要加-g参数在guru模式下才能修改变量的值。3.7.15 跟踪进程执行流程thread_indent(n): 补充空格ppfunc(): 当前探测点所在的函数在call探测点调用thread_indent(4)补充4个空格，在return探测点调用thread_indent(-4)回退4个空格，效果如下：12345678910#cat trace_nginx.stpprobe process(\"/home/admin/tengine/bin/nginx\").function(\"*@src/http/ngx_http_*\").call&#123; printf(\"%s -&gt; %s\\n\", thread_indent(4), ppfunc());&#125;probe process(\"/home/admin/tengine/bin/nginx\").function(\"*@src/http/ngx_http_*\").return&#123; printf(\"%s &lt;- %s\\n\", thread_indent(-4), ppfunc());&#125;3.7.16 查看代码执行路径pp(): 输出当前被激活的探测点12345678910111213141516171819202122232425 #cat ngx_http_process_request.stpprobe process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:*\") &#123; printf(\"%s\\n\", pp())&#125;#stap ngx_http_process_request.stp process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2762\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2768\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2771\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2773\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2774\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2783\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2835\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2840\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2841\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2842\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2843\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2846\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2847\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2848\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2850\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2852\")process(\"/home/admin/tengine/bin/nginx\").statement(\"ngx_http_process_request@src/http/ngx_http_request.c:2853\")^C可以看出该函数哪些行被执行了3.7.17 巧用正则匹配过滤在排查问题时，可以利用一些正则匹配来获取自己想要的信息，比如下面是只收集*.j9.com的堆栈：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#cat debug_tengine_5xx.stp probe process(\"/home/admin/tengine/bin/t-coresystem-tengine-cdn\").function(\"ngx_http_finalize_request\").call &#123; rc = $rc if (rc &lt; 0) &#123; host = \"(null)\" if ($r-&gt;headers_in-&gt;server-&gt;len != 0) &#123; host = user_string_n($r-&gt;headers_in-&gt;server-&gt;data, $r-&gt;headers_in-&gt;server-&gt;len) &#125; else &#123; cscf = &amp;@cast($r-&gt;srv_conf, \"ngx_http_core_srv_conf_t\")[@var(\"ngx_http_core_module@src/http/ngx_http_core_module.c\")-&gt;ctx_index] if (cscf-&gt;server_name-&gt;len != 0) &#123; host = user_string_n(cscf-&gt;server_name-&gt;data, cscf-&gt;server_name-&gt;len) &#125; &#125; if (host =~ \".*\\.j9\\.com\") &#123; printf(\"rc: %d, host: %s\\n\", rc, host) print_ubacktrace() &#125; &#125; ss#stap debug_tengine_5xx.stpWARNING: Missing unwind data for module, rerun with 'stap -d /lib64/libc-2.12.so'rc: -4, host: www.j9.com 0x49af2e : ngx_http_finalize_request+0xe/0x480 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x492eab : ngx_http_core_content_phase+0x2b/0x130 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x48e74d : ngx_http_core_run_phases+0x3d/0x50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x514c3c : ngx_http_lua_socket_tcp_read+0x44c/0x590 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x513150 : ngx_http_lua_socket_tcp_handler+0x30/0x50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x475b96 : ngx_event_process_posted+0x36/0x40 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x47d4d8 : ngx_worker_process_cycle+0x138/0x260 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x47a38a : ngx_spawn_process+0x1ca/0x5e0 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x47c73c : ngx_start_worker_processes+0x7c/0x100 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x47db5f : ngx_master_process_cycle+0x3af/0x9b0 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x45a740 : main+0xa90/0xb50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x3623e1ecdd [/lib64/libc-2.12.so+0x1ecdd/0x38d000]rc: -4, host: cdn.j9.com 0x49af2e : ngx_http_finalize_request+0xe/0x480 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x492eab : ngx_http_core_content_phase+0x2b/0x130 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x48e74d : ngx_http_core_run_phases+0x3d/0x50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x514c3c : ngx_http_lua_socket_tcp_read+0x44c/0x590 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x513150 : ngx_http_lua_socket_tcp_handler+0x30/0x50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x475b96 : ngx_event_process_posted+0x36/0x40 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x47d4d8 : ngx_worker_process_cycle+0x138/0x260 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x47a38a : ngx_spawn_process+0x1ca/0x5e0 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x47c73c : ngx_start_worker_processes+0x7c/0x100 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x47db5f : ngx_master_process_cycle+0x3af/0x9b0 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x45a740 : main+0xa90/0xb50 [/home/admin/tengine/bin/t-coresystem-tengine-cdn] 0x3623e1ecdd [/lib64/libc-2.12.so+0x1ecdd/0x38d000]&#125;3.7.18 关联数组用法SystemTap的关联数组必须是全局变量，需要用global进行声明，其索引可以支持多达9项索引域,各域间以逗号隔开。支持 =, ++ 与 +=操作,其默认的初始值为0。例如：123456789101112131415161718192021222324252627282930313233root@j9 ~# cat stap_array.stp global readsprobe vfs.read &#123; reads[execname(), pid()] ++&#125;probe timer.s(3) &#123; foreach ([execname, pid] in reads) &#123; printf(\"%s(%d) : %d \\n\", execname, pid, reads[execname, pid]) &#125; print(\"============================\\n\") delete reads&#125;root@j9 ~# stap stap_array.stp stapio(18716) : 16 rsyslogd(770) : 1 docker(743) : 3 IFSWatch(5594) : 30 QThread(5594) : 6 AliYunDunUpdate(1057) : 4 sshd(15118) : 1 sshd(15191) : 1 ============================stapio(18716) : 16 sshd(15191) : 3 docker(743) : 3 IFSWatch(5594) : 30 sshd(15118) : 2 QThread(5594) : 12 AliYunDunUpdate(1057) : 8 ============================^Croot@j9 ~/systemtap#也可以用+、-进行排序：123456789101112131415161718192021222324252627282930313233root@j9 ~# cat stap_array.stpglobal readsprobe vfs.read &#123; reads[execname(), pid()] ++&#125;probe timer.s(3) &#123; foreach ([execname, pid+] in reads) &#123; printf(\"%s(%d) : %d \\n\", execname, pid, reads[execname, pid]) &#125; print(\"============================\\n\") delete reads&#125;root@j9 ~# stap stap_array.stp docker(743) : 3 rsyslogd(770) : 1 AliYunDunUpdate(1057) : 12 IFSWatch(5594) : 30 QThread(5594) : 12 sshd(15118) : 2 sshd(15191) : 2 stapio(19021) : 16 ============================docker(743) : 3 AliYunDunUpdate(1057) : 12 IFSWatch(5594) : 30 QThread(5594) : 6 sshd(15118) : 1 sshd(15191) : 19 stapio(19021) : 16 ============================^Croot@j9 ~#3.7.19 调试内存泄漏以及内存重复释放在return探测点，使用函数入参需要@entry123456789101112131415161718192021222324252627282930313233343536373839404142434445464748probe begin &#123; printf(\"=============begin============\\n\")&#125;//记录内存分配和释放的计数关联数组global g_mem_ref_tbl//记录内存分配和释放的调用堆栈关联数组，以内存地址作为keyglobal g_mem_bt_tblprobe process(\"/lib/x86_64-linux-gnu/libc.so.6\").function(\"__libc_malloc\").return, process(\"/lib/x86_64-linux-gnu/libc.so.6\").function(\"__libc_calloc\").return &#123; if (target() == pid()) &#123; if (g_mem_ref_tbl[$return] == 0) &#123; g_mem_ref_tbl[$return]++ g_mem_bt_tbl[$return] = sprint_ubacktrace() &#125; &#125;&#125;//$mem是__libc_free的参数probe process(\"/lib/x86_64-linux-gnu/libc.so.6\").function(\"__libc_free\").call &#123; if (target() == pid()) &#123; g_mem_ref_tbl[$mem]-- if (g_mem_ref_tbl[$mem] == 0) &#123; if ($mem != 0) &#123; //记录上次释放的调用堆栈 g_mem_bt_tbl[$mem] = sprint_ubacktrace() &#125; &#125; else if (g_mem_ref_tbl[$mem] &lt; 0 &amp;&amp; $mem != 0) &#123; //如果调用free已经失衡，那就出现了重复释放内存的问题，这里输出当前调用堆栈，以及这个地址上次释放的调用堆栈 printf(\"MMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n\") printf(\"g_mem_ref_tbl[%p]: %d\\n\", $mem, g_mem_ref_tbl[$mem]) print_ubacktrace() printf(\"last free backtrace:\\n%s\\n\", g_mem_bt_tbl[$mem]) printf(\"WWWWWWWWWWWWWWWWWWWWWWWWWWWW\\n\") &#125; &#125;&#125;probe end &#123; //最后输出产生泄漏的内存是在哪里分配的 printf(\"=============end============\\n\") foreach(mem in g_mem_ref_tbl) &#123; if (g_mem_ref_tbl[mem] &gt; 0) &#123; printf(\"%s\\n\", g_mem_bt_tbl[mem]) printf(\"--------------------------------\\n\") &#125; &#125;&#125;3.7.20 嵌入C代码在进程fork出子进程时打印出进程id和进程名:12345678910111213141516171819202122232425262728293031root@jusse ~/systemtap# cat copy_process.stpfunction getprocname:string(task:long)%&#123; struct task_struct *task = (struct task_struct *)STAP_ARG_task; snprintf(STAP_RETVALUE, MAXSTRINGLEN, \"pid: %d, comm: %s\", task-&gt;pid, task-&gt;comm);%&#125;function getprocid:long(task:long)%&#123; struct task_struct *task = (struct task_struct *)STAP_ARG_task; STAP_RETURN(task-&gt;pid);%&#125;probe kernel.function(\"copy_process\").return&#123; printf(\"copy_process return: %p, pid: %d, getprocname: %s, getprocid: %d\\n\", $return, $return-&gt;pid, getprocname($return), getprocid($return));&#125;root@jusse ~/systemtap# stap -g copy_process.stpcopy_process return: 0xffff880039f61800, pid: 12212, getprocname: pid: 12212, comm: bash, getprocid: 12212copy_process return: 0xffff880039f61800, pid: 12212, getprocname: pid: 12212, comm: bash, getprocid: 12212copy_process return: 0xffff880039f63000, pid: 12213, getprocname: pid: 12213, comm: cc_epoll, getprocid: 12213copy_process return: 0xffff880039f63000, pid: 12213, getprocname: pid: 12213, comm: cc_epoll, getprocid: 12213copy_process return: 0xffff8800081a9800, pid: 12214, getprocname: pid: 12214, comm: cc_epoll, getprocid: 12214copy_process return: 0xffff8800081a9800, pid: 12214, getprocname: pid: 12214, comm: cc_epoll, getprocid: 12214copy_process return: 0xffff8800004d8000, pid: 12215, getprocname: pid: 12215, comm: cc_epoll, getprocid: 12215copy_process return: 0xffff8800004d8000, pid: 12215, getprocname: pid: 12215, comm: cc_epoll, getprocid: 12215copy_process return: 0xffff880000564800, pid: 12216, getprocname: pid: 12216, comm: cc_epoll, getprocid: 12216copy_process return: 0xffff880000564800, pid: 12216, getprocname: pid: 12216, comm: cc_epoll, getprocid: 12216copy_process return: 0xffff880000566000, pid: 12217, getprocname: pid: 12217, comm: cc_epoll, getprocid: 12217copy_process return: 0xffff880000566000, pid: 12217, getprocname: pid: 12217, comm: cc_epoll, getprocid: 12217有三个需要注意的地方：1）、SystemTap脚本里面嵌入C语言代码要在每个大括号前加%前缀，是%{…… %} 而不是%{ …… }%；2）、获取脚本函数参数要用STAP_ARG_前缀；3）、一般long等返回值用STAP_RETURN，而string类型返回值要用snprintf、strncat等方式把字符串复制到STAP_RETVALUE里面。3.7.21 调试内核模块这小节就不细讲了，这篇博客 (http://blog.chinaunix.net/uid-14528823-id-4726046.html) 写得很详细，这里只copy两个关键点过来记录一下：要调试自己的内核模块，需要注意的有两个关键点：1)、使用SystemTap调试内核模块，探测点的编写格式示例为：module(“ext3”).function(“ext3_*”)2)、需要将自己的模块cp到/lib/modules/uname -r/extra目录中，否则找不到符号，如果/lib/modules/uname -r/目录下没有extra这个目录，自己mkdir一下就可以。3.7.22 一些错误提示及解决办法错误提示1：12ERROR: MAXACTION exceeded near keyword at debug_connection.stp:86:9ERROR: MAXACTION exceeded near operator '-&gt;' at debug_connection.stp:84:30解决办法：加上stap参数：-DMAXACTION=102400，如果还报这种类型的错误，只需把102400调成更大的值即可。错误提示2：1WARNING: Number of errors: 0, skipped probes: 82解决办法：加上-DMAXSKIPPED=102400和-DSTP_NO_OVERLOAD参数还有一些可以去掉限制的宏：MAXSTRINGLEN：这个宏会影响sprintf的buffer大小，默认为512字节。MAXTRYLOCK：对全局变量进行try lock操作的次数，超过则次数还拿不到锁则放弃和跳过该探测点，默认值为1000.全局变量多的时候可以把这个宏开大一点。3.7.23 传递参数3.7.24 常用函数本节来介绍systemtap中常用的一些函数tid()：当前线程ID。uid()：当前用户ID。cpu()：当前CPU编号。ctime()：当前UNIX epoch秒数。pp()：当前探测点的描述字符串exit(): 执行一次后退出。execname()：当前运行的进程名称。probefunc()：探测点函数名称。target()：在stap使用-c command或者-x process命令时，target()能拿到进程的pid。name()：返回系统调用的名称字符串，仅能在syscall类型的探针处理函数中使用。thread_indent(delta)：它可以输出当前probe所处的可执行程序名称、线程id、函数执行的相对时间和执行的次数（通过空格的数量）信息，它的返回值就是一个字符串。参数delta是在每次调用时增加或移除的空白数量。@defined和@choose_defined由于版本变化，有一些变量可能在新版本中不存在了，此时可以使用@define来检查变量是否存在：12345probe vm.pagefault = kernel.function(\"__handle_mm_fault@mm/memory.c\") ?, kernel.function(\"handle_mm_fault@mm/memory.c\") ?&#123; write_access = (@defined($flags) ? $flags &amp; FAULT_FLAG_WRITE : $write_access)&#125;@entry在.return探针中，有一个特殊的操作符@entry，用于存储该探针的入口处的表达式的值，可以使用这个操作符，完成比如计算探针函数执行时间计算等工作，比如：1234567global sloth = 50 probe vfs.open.return &#123; time = gettimeofday_us()-@entry(gettimeofday_us()) if (time &gt;= sloth) printf(\"%s[%d] %d %s\\n\", execname(), tid(), time, pathname)&#125;这个脚本在vfs.open.return探针处理函数中，通过@entry操作符，计算完成vfs.open操作的时间差，如果超过设置的阈值50就打印相关信息。-G命令行参数，可以设置全局变量VAR的值为VAL，相应地就可以作为开关来控制脚本的行为，比如：1234567891011// sudo stap G-params.stp -G flag=1// flag has setglobal flag=0probe begin &#123; if (flag == 0) &#123; printf(&quot;flag not set\\n&quot;) &#125; else &#123; printf(&quot;flag has set\\n&quot;) &#125;&#125;3.7.25 异步事件常见的异步事件是begin、end、never、timers。timers用于定义定时器探测点，常见的格式timer.s(1)来定义每秒触发的探测点。never定义的探测点不会被调用到，很多时候加这个探测点只是为了检查一些语法错误。","categories":[],"tags":[{"name":"systemtap","slug":"systemtap","permalink":"https://weeweetan.github.io/tags/systemtap/"}]},{"title":"Nginx的http模块代码分析","slug":"Nginx的http模块代码分析","date":"2021-10-02T11:29:02.000Z","updated":"2024-03-04T14:45:02.258Z","comments":true,"path":"2021/10/02/Nginx的http模块代码分析/","link":"","permalink":"https://weeweetan.github.io/2021/10/02/Nginx的http模块代码分析/","excerpt":"","text":"1、代码框架http模块主要代码放在ngx_http.c这个文件中，接下来我们就来分析下相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf);static ngx_int_t ngx_http_init_headers_in_hash(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf);static ngx_int_t ngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf);static ngx_int_t ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf, ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt);static ngx_int_t ngx_http_add_address(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf, ngx_http_conf_port_t *port, ngx_http_listen_opt_t *lsopt);static ngx_int_t ngx_http_add_server(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf, ngx_http_conf_addr_t *addr);static char *ngx_http_merge_servers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf, ngx_http_module_t *module, ngx_uint_t ctx_index);static char *ngx_http_merge_locations(ngx_conf_t *cf, ngx_queue_t *locations, void **loc_conf, ngx_http_module_t *module, ngx_uint_t ctx_index);static ngx_int_t ngx_http_init_locations(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf, ngx_http_core_loc_conf_t *pclcf);static ngx_int_t ngx_http_init_static_location_trees(ngx_conf_t *cf, ngx_http_core_loc_conf_t *pclcf);static ngx_int_t ngx_http_cmp_locations(const ngx_queue_t *one, const ngx_queue_t *two);static ngx_int_t ngx_http_join_exact_locations(ngx_conf_t *cf, ngx_queue_t *locations);static void ngx_http_create_locations_list(ngx_queue_t *locations, ngx_queue_t *q);static ngx_http_location_tree_node_t * ngx_http_create_locations_tree(ngx_conf_t *cf, ngx_queue_t *locations, size_t prefix);static ngx_int_t ngx_http_optimize_servers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf, ngx_array_t *ports);static ngx_int_t ngx_http_server_names(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf, ngx_http_conf_addr_t *addr);static ngx_int_t ngx_http_cmp_conf_addrs(const void *one, const void *two);static int ngx_libc_cdecl ngx_http_cmp_dns_wildcards(const void *one, const void *two);static ngx_int_t ngx_http_init_listening(ngx_conf_t *cf, ngx_http_conf_port_t *port);static ngx_listening_t *ngx_http_add_listening(ngx_conf_t *cf, ngx_http_conf_addr_t *addr);static ngx_int_t ngx_http_add_addrs(ngx_conf_t *cf, ngx_http_port_t *hport, ngx_http_conf_addr_t *addr);#if (NGX_HAVE_INET6)static ngx_int_t ngx_http_add_addrs6(ngx_conf_t *cf, ngx_http_port_t *hport, ngx_http_conf_addr_t *addr);#endif在ngx_http.c文件最前面这部分代码全部是函数声明，接下来看下http模块配置，指令设置、函数指针以及模块结构初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ngx_uint_t ngx_http_max_module;ngx_http_output_header_filter_pt ngx_http_top_header_filter;ngx_http_output_body_filter_pt ngx_http_top_body_filter;ngx_http_request_body_filter_pt ngx_http_top_request_body_filter;ngx_str_t ngx_http_html_default_types[] = &#123; ngx_string(\"text/html\"), ngx_null_string&#125;;// http指令定义static ngx_command_t ngx_http_commands[] = &#123; &#123; ngx_string(\"http\"), NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS, ngx_http_block, 0, 0, NULL &#125;, ngx_null_command&#125;;//核心模块上下文static ngx_core_module_t ngx_http_module_ctx = &#123; ngx_string(\"http\"), NULL, NULL&#125;;//http模块定义ngx_module_t ngx_http_module = &#123; NGX_MODULE_V1, &amp;ngx_http_module_ctx, /* module context */ ngx_http_commands, /* module directives */ NGX_CORE_MODULE, /* module type */ NULL, /* init master */ NULL, /* init module */ NULL, /* init process */ NULL, /* init thread */ NULL, /* exit thread */ NULL, /* exit process */ NULL, /* exit master */ NGX_MODULE_V1_PADDING&#125;;接下来看下http块解析函数，ngx_http_block函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245static char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; char *rv; ngx_uint_t mi, m, s; ngx_conf_t pcf; ngx_http_module_t *module; ngx_http_conf_ctx_t *ctx; ngx_http_core_loc_conf_t *clcf; ngx_http_core_srv_conf_t **cscfp; ngx_http_core_main_conf_t *cmcf; // 判断是否重复配置 if (*(ngx_http_conf_ctx_t **) conf) &#123; return \"is duplicate\"; &#125; /* the main http context */ // 申请保存上下文的内存 ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; *(ngx_http_conf_ctx_t **) conf = ctx; /* count the number of the http modules and set up their indices */ ngx_http_max_module = ngx_count_modules(cf-&gt;cycle, NGX_HTTP_MODULE); /* the http main_conf context, it is the same in the all http contexts */ ctx-&gt;main_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;main_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; /* * the http null srv_conf context, it is used to merge * the server&#123;&#125;s' srv_conf's */ ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;srv_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; /* * the http null loc_conf context, it is used to merge * the server&#123;&#125;s' loc_conf's */ ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;loc_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; /* * create the main_conf's, the null srv_conf's, and the null loc_conf's * of the all http modules */ for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; // 跳过非http模块 if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index; // 调用每个模块创建main级别conf的函数指针 if (module-&gt;create_main_conf) &#123; ctx-&gt;main_conf[mi] = module-&gt;create_main_conf(cf); if (ctx-&gt;main_conf[mi] == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; // 调用每个模块创建server级别conf的函数指针 if (module-&gt;create_srv_conf) &#123; ctx-&gt;srv_conf[mi] = module-&gt;create_srv_conf(cf); if (ctx-&gt;srv_conf[mi] == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; // 调用每个模块创建location级别conf的函数指针 if (module-&gt;create_loc_conf) &#123; ctx-&gt;loc_conf[mi] = module-&gt;create_loc_conf(cf); if (ctx-&gt;loc_conf[mi] == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; &#125; // 保存cf，在解析完配置后会还原 pcf = *cf; // 保存http级别conf cf-&gt;ctx = ctx; for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; // 跳过非http模块 if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; //调用每个模块preconfiguration函数指针，在解析配置前需要做的 if (module-&gt;preconfiguration) &#123; if (module-&gt;preconfiguration(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; &#125; /* parse inside the http&#123;&#125; block */ cf-&gt;module_type = NGX_HTTP_MODULE; cf-&gt;cmd_type = NGX_HTTP_MAIN_CONF; // 开始解析http块里面的配置 rv = ngx_conf_parse(cf, NULL); if (rv != NGX_CONF_OK) &#123; goto failed; &#125; /* * init http&#123;&#125; main_conf's, merge the server&#123;&#125;s' srv_conf's * and its location&#123;&#125;s' loc_conf's */ // 取http main级别的conf cmcf = ctx-&gt;main_conf[ngx_http_core_module.ctx_index]; cscfp = cmcf-&gt;servers.elts; // 调用每个http模块初始化main级别配置的函数 for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; // 跳过非http模块 if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; mi = cf-&gt;cycle-&gt;modules[m]-&gt;ctx_index; /* init http&#123;&#125; main_conf's */ // 调用每个模块init_main_conf函数指针 if (module-&gt;init_main_conf) &#123; rv = module-&gt;init_main_conf(cf, ctx-&gt;main_conf[mi]); if (rv != NGX_CONF_OK) &#123; goto failed; &#125; &#125; // 合并server级别及location级别配置 rv = ngx_http_merge_servers(cf, cmcf, module, mi); if (rv != NGX_CONF_OK) &#123; goto failed; &#125; &#125; /* create location trees */ // 构造http请求location匹配树 for (s = 0; s &lt; cmcf-&gt;servers.nelts; s++) &#123; clcf = cscfp[s]-&gt;ctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; // 构造静态location匹配树 if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; // 初始化各个阶段的array if (ngx_http_init_phases(cf, cmcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; // 初始化http请求头headers if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; // 处理每个http模块postconfiguration for (m = 0; cf-&gt;cycle-&gt;modules[m]; m++) &#123; if (cf-&gt;cycle-&gt;modules[m]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[m]-&gt;ctx; //调用每个模块postconfiguration函数指针，用于处理配置解析完成后的操作 if (module-&gt;postconfiguration) &#123; if (module-&gt;postconfiguration(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; &#125; // 初始化http变量 if (ngx_http_variables_init_vars(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; /* * http&#123;&#125;'s cf-&gt;ctx was needed while the configuration merging * and in postconfiguration process */ // 恢复cf *cf = pcf; // 初始化http各个阶段handler if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; /* optimize the lists of ports, addresses and server names */ // 处理相同端口以及server_name if (ngx_http_optimize_servers(cf, cmcf, cmcf-&gt;ports) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK;failed: // 恢复cf *cf = pcf; // 返回结果 return rv;&#125;接下来分析ngx_http_optimize_servers函数，此函数用于处理IP+Port相同，不同server_name的情况123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static ngx_int_tngx_http_optimize_servers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf, ngx_array_t *ports)&#123; ngx_uint_t p, a; ngx_http_conf_port_t *port; ngx_http_conf_addr_t *addr; // 如果没有配置端口，则返回 if (ports == NULL) &#123; return NGX_OK; &#125; // 遍历已经配置的port列表， port = ports-&gt;elts; for (p = 0; p &lt; ports-&gt;nelts; p++) &#123; // 将同一个port下挂的addr进行排序 ngx_sort(port[p].addrs.elts, (size_t) port[p].addrs.nelts, sizeof(ngx_http_conf_addr_t), ngx_http_cmp_conf_addrs); /* * check whether all name-based servers have the same * configuration as a default server for given address:port */ // 如果一个addr下有多个server块，则处理server_name addr = port[p].addrs.elts; for (a = 0; a &lt; port[p].addrs.nelts; a++) &#123; if (addr[a].servers.nelts &gt; 1#if (NGX_PCRE) || addr[a].default_server-&gt;captures#endif ) &#123; if (ngx_http_server_names(cf, cmcf, &amp;addr[a]) != NGX_OK) &#123; return NGX_ERROR; &#125; &#125; &#125; // 处理listen，从cycle-&gt;listening分配元素 if (ngx_http_init_listening(cf, &amp;port[p]) != NGX_OK) &#123; return NGX_ERROR; &#125; &#125; return NGX_OK;&#125;接下来分析ngx_http_server_names函数，这个函数的功能是server_name进行hash处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165static ngx_int_tngx_http_server_names(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf, ngx_http_conf_addr_t *addr)&#123; ngx_int_t rc; ngx_uint_t n, s; ngx_hash_init_t hash; ngx_hash_keys_arrays_t ha; ngx_http_server_name_t *name; ngx_http_core_srv_conf_t **cscfp;#if (NGX_PCRE) ngx_uint_t regex, i; regex = 0;#endif // 初始化hash key数组 ngx_memzero(&amp;ha, sizeof(ngx_hash_keys_arrays_t)); // 创建初始化hash table所需的内存池 ha.temp_pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf-&gt;log); if (ha.temp_pool == NULL) &#123; return NGX_ERROR; &#125; ha.pool = cf-&gt;pool; // 初始化hash key if (ngx_hash_keys_array_init(&amp;ha, NGX_HASH_LARGE) != NGX_OK) &#123; goto failed; &#125; cscfp = addr-&gt;servers.elts; // 遍历此地址下的所有server块 for (s = 0; s &lt; addr-&gt;servers.nelts; s++) &#123; name = cscfp[s]-&gt;server_names.elts; for (n = 0; n &lt; cscfp[s]-&gt;server_names.nelts; n++) &#123;#if (NGX_PCRE) if (name[n].regex) &#123; regex++; continue; &#125;#endif // 将server_name添加到key中 rc = ngx_hash_add_key(&amp;ha, &amp;name[n].name, name[n].server, NGX_HASH_WILDCARD_KEY); if (rc == NGX_ERROR) &#123; return NGX_ERROR; &#125; if (rc == NGX_DECLINED) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, \"invalid server name or wildcard \\\"%V\\\" on %V\", &amp;name[n].name, &amp;addr-&gt;opt.addr_text); return NGX_ERROR; &#125; // server_name出现冲突 if (rc == NGX_BUSY) &#123; ngx_log_error(NGX_LOG_WARN, cf-&gt;log, 0, \"conflicting server name \\\"%V\\\" on %V, ignored\", &amp;name[n].name, &amp;addr-&gt;opt.addr_text); &#125; &#125; &#125; // 对hash表赋初值 hash.key = ngx_hash_key_lc; hash.max_size = cmcf-&gt;server_names_hash_max_size; hash.bucket_size = cmcf-&gt;server_names_hash_bucket_size; hash.name = \"server_names_hash\"; hash.pool = cf-&gt;pool; if (ha.keys.nelts) &#123; hash.hash = &amp;addr-&gt;hash; hash.temp_pool = NULL; if (ngx_hash_init(&amp;hash, ha.keys.elts, ha.keys.nelts) != NGX_OK) &#123; goto failed; &#125; &#125; // 前缀匹配 if (ha.dns_wc_head.nelts) &#123; ngx_qsort(ha.dns_wc_head.elts, (size_t) ha.dns_wc_head.nelts, sizeof(ngx_hash_key_t), ngx_http_cmp_dns_wildcards); hash.hash = NULL; hash.temp_pool = ha.temp_pool; if (ngx_hash_wildcard_init(&amp;hash, ha.dns_wc_head.elts, ha.dns_wc_head.nelts) != NGX_OK) &#123; goto failed; &#125; addr-&gt;wc_head = (ngx_hash_wildcard_t *) hash.hash; &#125; // 后缀匹配 if (ha.dns_wc_tail.nelts) &#123; ngx_qsort(ha.dns_wc_tail.elts, (size_t) ha.dns_wc_tail.nelts, sizeof(ngx_hash_key_t), ngx_http_cmp_dns_wildcards); hash.hash = NULL; hash.temp_pool = ha.temp_pool; if (ngx_hash_wildcard_init(&amp;hash, ha.dns_wc_tail.elts, ha.dns_wc_tail.nelts) != NGX_OK) &#123; goto failed; &#125; addr-&gt;wc_tail = (ngx_hash_wildcard_t *) hash.hash; &#125; ngx_destroy_pool(ha.temp_pool); // 处理正则#if (NGX_PCRE) if (regex == 0) &#123; return NGX_OK; &#125; addr-&gt;nregex = regex; addr-&gt;regex = ngx_palloc(cf-&gt;pool, regex * sizeof(ngx_http_server_name_t)); if (addr-&gt;regex == NULL) &#123; return NGX_ERROR; &#125; i = 0; for (s = 0; s &lt; addr-&gt;servers.nelts; s++) &#123; name = cscfp[s]-&gt;server_names.elts; // 遍历server_name，对regex进行处理 for (n = 0; n &lt; cscfp[s]-&gt;server_names.nelts; n++) &#123; if (name[n].regex) &#123; addr-&gt;regex[i++] = name[n]; &#125; &#125; &#125;#endif return NGX_OK;failed: // 释放temp_pool ngx_destroy_pool(ha.temp_pool); return NGX_ERROR;&#125;接下来分析ngx_http_init_listening函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static ngx_int_tngx_http_init_listening(ngx_conf_t *cf, ngx_http_conf_port_t *port)&#123; ngx_uint_t i, last, bind_wildcard; ngx_listening_t *ls; ngx_http_port_t *hport; ngx_http_conf_addr_t *addr; addr = port-&gt;addrs.elts; last = port-&gt;addrs.nelts; /* * If there is a binding to an \"*:port\" then we need to bind() to * the \"*:port\" only and ignore other implicit bindings. The bindings * have been already sorted: explicit bindings are on the start, then * implicit bindings go, and wildcard binding is in the end. */ if (addr[last - 1].opt.wildcard) &#123; addr[last - 1].opt.bind = 1; bind_wildcard = 1; &#125; else &#123; bind_wildcard = 0; &#125; i = 0; while (i &lt; last) &#123; if (bind_wildcard &amp;&amp; !addr[i].opt.bind) &#123; i++; continue; &#125; // 从ngx_cycle-&gt;listening中push一个ls，跟socket相关的都保存在这里面 ls = ngx_http_add_listening(cf, &amp;addr[i]); if (ls == NULL) &#123; return NGX_ERROR; &#125; // 分配保存地址的内存，在ngx_init_connection中使用 hport = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_port_t)); if (hport == NULL) &#123; return NGX_ERROR; &#125; ls-&gt;servers = hport; hport-&gt;naddrs = i + 1; switch (ls-&gt;sockaddr-&gt;sa_family) &#123;#if (NGX_HAVE_INET6) case AF_INET6: if (ngx_http_add_addrs6(cf, hport, addr) != NGX_OK) &#123; return NGX_ERROR; &#125; break;#endif default: /* AF_INET */ // 将addr中的内容复制到hport中 if (ngx_http_add_addrs(cf, hport, addr) != NGX_OK) &#123; return NGX_ERROR; &#125; break; &#125; addr++; last--; &#125; return NGX_OK;&#125;接下来看看ngx_http_add_addrs函数的实现，ngx_http_add_addrs6类似123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static ngx_int_tngx_http_add_addrs(ngx_conf_t *cf, ngx_http_port_t *hport, ngx_http_conf_addr_t *addr)&#123; ngx_uint_t i; ngx_http_in_addr_t *addrs; struct sockaddr_in *sin; ngx_http_virtual_names_t *vn; // 申请必要内存，naddrs就是外面计算的这个端口下的ip个数 hport-&gt;addrs = ngx_pcalloc(cf-&gt;pool, hport-&gt;naddrs * sizeof(ngx_http_in_addr_t)); if (hport-&gt;addrs == NULL) &#123; return NGX_ERROR; &#125; addrs = hport-&gt;addrs; for (i = 0; i &lt; hport-&gt;naddrs; i++) &#123; sin = (struct sockaddr_in *) addr[i].opt.sockaddr; addrs[i].addr = sin-&gt;sin_addr.s_addr; addrs[i].conf.default_server = addr[i].default_server;#if (NGX_HTTP_SSL) addrs[i].conf.ssl = addr[i].opt.ssl;#endif#if (NGX_HTTP_V2) addrs[i].conf.http2 = addr[i].opt.http2;#endif addrs[i].conf.proxy_protocol = addr[i].opt.proxy_protocol; // 如果匹配server_name所需的hash桶为空，则不进行下一步操作 if (addr[i].hash.buckets == NULL &amp;&amp; (addr[i].wc_head == NULL || addr[i].wc_head-&gt;hash.buckets == NULL) &amp;&amp; (addr[i].wc_tail == NULL || addr[i].wc_tail-&gt;hash.buckets == NULL)#if (NGX_PCRE) &amp;&amp; addr[i].nregex == 0#endif ) &#123; continue; &#125; // 申请保存server_name匹配所需内存 vn = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_virtual_names_t)); if (vn == NULL) &#123; return NGX_ERROR; &#125; addrs[i].conf.virtual_names = vn; // 保存server_name匹配所需的hash值 vn-&gt;names.hash = addr[i].hash; vn-&gt;names.wc_head = addr[i].wc_head; vn-&gt;names.wc_tail = addr[i].wc_tail;#if (NGX_PCRE) vn-&gt;nregex = addr[i].nregex; vn-&gt;regex = addr[i].regex;#endif &#125; return NGX_OK;&#125;接下来看看函数的实现1","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的http_core模块","slug":"Nginx的http-core模块","date":"2021-05-09T13:06:24.000Z","updated":"2023-06-28T14:45:12.710Z","comments":true,"path":"2021/05/09/Nginx的http-core模块/","link":"","permalink":"https://weeweetan.github.io/2021/05/09/Nginx的http-core模块/","excerpt":"","text":"1、相关配置核心模块配置如下123456789server &#123; listen 80; location / &#123; root html; index index.html; &#125;&#125;以上是http模块最核心的配置，一条listen指令，一条location指令，能够监听80端口，提供简单的web服务。2、相关代码首先看下解析server指令的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155static char *ngx_http_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)&#123; char *rv; void *mconf; size_t len; u_char *p; ngx_uint_t i; ngx_conf_t pcf; ngx_http_module_t *module; struct sockaddr_in *sin; ngx_http_conf_ctx_t *ctx, *http_ctx; ngx_http_listen_opt_t lsopt; ngx_http_core_srv_conf_t *cscf, **cscfp; ngx_http_core_main_conf_t *cmcf; // 首先分配上下文内存 ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; // 保存http模块main级别的conf http_ctx = cf-&gt;ctx; ctx-&gt;main_conf = http_ctx-&gt;main_conf; /* the server&#123;&#125;'s srv_conf */ // 预分配保存server级别的内存 ctx-&gt;srv_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;srv_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; /* the server&#123;&#125;'s loc_conf */ // 预分配location级别的内存 ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;loc_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; for (i = 0; cf-&gt;cycle-&gt;modules[i]; i++) &#123; if (cf-&gt;cycle-&gt;modules[i]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[i]-&gt;ctx; // 调用每个模块create_srv_conf函数指针，创建server级别conf if (module-&gt;create_srv_conf) &#123; mconf = module-&gt;create_srv_conf(cf); if (mconf == NULL) &#123; return NGX_CONF_ERROR; &#125; // 使用模块索引保存创建的server级别conf ctx-&gt;srv_conf[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index] = mconf; &#125; // 调用每个模块create_loc_conf函数指针，创建location级别conf if (module-&gt;create_loc_conf) &#123; mconf = module-&gt;create_loc_conf(cf); if (mconf == NULL) &#123; return NGX_CONF_ERROR; &#125; // 使用模块索引保存创建的location级别conf ctx-&gt;loc_conf[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index] = mconf; &#125; &#125; /* the server configuration context */ cscf = ctx-&gt;srv_conf[ngx_http_core_module.ctx_index]; cscf-&gt;ctx = ctx; //获取http的主配置 cmcf = ctx-&gt;main_conf[ngx_http_core_module.ctx_index]; // 创建servers数组 cscfp = ngx_array_push(&amp;cmcf-&gt;servers); if (cscfp == NULL) &#123; return NGX_CONF_ERROR; &#125; //保存cscfp *cscfp = cscf; /* parse inside server&#123;&#125; */ pcf = *cf; cf-&gt;ctx = ctx; cf-&gt;cmd_type = NGX_HTTP_SRV_CONF; // 开始解析server块配置 rv = ngx_conf_parse(cf, NULL); // 还原cf *cf = pcf; // 处理没有监听端口的情况, 默认80 if (rv == NGX_CONF_OK &amp;&amp; !cscf-&gt;listen) &#123; ngx_memzero(&amp;lsopt, sizeof(ngx_http_listen_opt_t)); p = ngx_pcalloc(cf-&gt;pool, sizeof(struct sockaddr_in)); if (p == NULL) &#123; return NGX_CONF_ERROR; &#125; lsopt.sockaddr = (struct sockaddr *) p; sin = (struct sockaddr_in *) p; sin-&gt;sin_family = AF_INET;#if (NGX_WIN32) sin-&gt;sin_port = htons(80);#else sin-&gt;sin_port = htons((getuid() == 0) ? 80 : 8000);#endif sin-&gt;sin_addr.s_addr = INADDR_ANY; lsopt.socklen = sizeof(struct sockaddr_in); lsopt.backlog = NGX_LISTEN_BACKLOG; lsopt.rcvbuf = -1; lsopt.sndbuf = -1;#if (NGX_HAVE_SETFIB) lsopt.setfib = -1;#endif#if (NGX_HAVE_TCP_FASTOPEN) lsopt.fastopen = -1;#endif lsopt.wildcard = 1; len = NGX_INET_ADDRSTRLEN + sizeof(\":65535\") - 1; p = ngx_pnalloc(cf-&gt;pool, len); if (p == NULL) &#123; return NGX_CONF_ERROR; &#125; lsopt.addr_text.data = p; lsopt.addr_text.len = ngx_sock_ntop(lsopt.sockaddr, lsopt.socklen, p, len, 1); // 添加端口到listening列表 if (ngx_http_add_listen(cf, cscf, &amp;lsopt) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; return rv;&#125;接下来看看解析listen指令的函数, ngx_http_core_listen的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376static char *ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_srv_conf_t *cscf = conf; ngx_str_t *value, size; ngx_url_t u; ngx_uint_t n; ngx_http_listen_opt_t lsopt; cscf-&gt;listen = 1; value = cf-&gt;args-&gt;elts; // URL结构体内存空间置零 ngx_memzero(&amp;u, sizeof(ngx_url_t)); u.url = value[1]; u.listen = 1; u.default_port = 80; // 解析listen指令后的ip+port if (ngx_parse_url(cf-&gt;pool, &amp;u) != NGX_OK) &#123; if (u.err) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"%s in \\\"%V\\\" of the \\\"listen\\\" directive\", u.err, &amp;u.url); &#125; return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;lsopt, sizeof(ngx_http_listen_opt_t)); lsopt.backlog = NGX_LISTEN_BACKLOG; lsopt.rcvbuf = -1; lsopt.sndbuf = -1;#if (NGX_HAVE_SETFIB) lsopt.setfib = -1;#endif#if (NGX_HAVE_TCP_FASTOPEN) lsopt.fastopen = -1;#endif#if (NGX_HAVE_INET6) lsopt.ipv6only = 1;#endif // 开始解析listen指令后的参数，第一个参数是listen，第二个参数是IP端口，所以n从2开始 for (n = 2; n &lt; cf-&gt;args-&gt;nelts; n++) &#123; // 解析default server参数，并设置标志位 if (ngx_strcmp(value[n].data, \"default_server\") == 0 || ngx_strcmp(value[n].data, \"default\") == 0) &#123; lsopt.default_server = 1; continue; &#125; // 解析bind参数，并设置标志位 if (ngx_strcmp(value[n].data, \"bind\") == 0) &#123; lsopt.set = 1; lsopt.bind = 1; continue; &#125;#if (NGX_HAVE_SETFIB) if (ngx_strncmp(value[n].data, \"setfib=\", 7) == 0) &#123; lsopt.setfib = ngx_atoi(value[n].data + 7, value[n].len - 7); lsopt.set = 1; lsopt.bind = 1; if (lsopt.setfib == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid setfib \\\"%V\\\"\", &amp;value[n]); return NGX_CONF_ERROR; &#125; continue; &#125;#endif#if (NGX_HAVE_TCP_FASTOPEN) // 解析fastopen参数，设置标志位和值 if (ngx_strncmp(value[n].data, \"fastopen=\", 9) == 0) &#123; lsopt.fastopen = ngx_atoi(value[n].data + 9, value[n].len - 9); lsopt.set = 1; lsopt.bind = 1; if (lsopt.fastopen == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid fastopen \\\"%V\\\"\", &amp;value[n]); return NGX_CONF_ERROR; &#125; continue; &#125;#endif // 解析backlog参数，设置标志位和值 if (ngx_strncmp(value[n].data, \"backlog=\", 8) == 0) &#123; lsopt.backlog = ngx_atoi(value[n].data + 8, value[n].len - 8); lsopt.set = 1; lsopt.bind = 1; if (lsopt.backlog == NGX_ERROR || lsopt.backlog == 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid backlog \\\"%V\\\"\", &amp;value[n]); return NGX_CONF_ERROR; &#125; continue; &#125; // recv buf参数，设置标志位和值 if (ngx_strncmp(value[n].data, \"rcvbuf=\", 7) == 0) &#123; size.len = value[n].len - 7; size.data = value[n].data + 7; lsopt.rcvbuf = ngx_parse_size(&amp;size); lsopt.set = 1; lsopt.bind = 1; if (lsopt.rcvbuf == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid rcvbuf \\\"%V\\\"\", &amp;value[n]); return NGX_CONF_ERROR; &#125; continue; &#125; // send buf参数，设置标志位和值 if (ngx_strncmp(value[n].data, \"sndbuf=\", 7) == 0) &#123; size.len = value[n].len - 7; size.data = value[n].data + 7; lsopt.sndbuf = ngx_parse_size(&amp;size); lsopt.set = 1; lsopt.bind = 1; if (lsopt.sndbuf == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid sndbuf \\\"%V\\\"\", &amp;value[n]); return NGX_CONF_ERROR; &#125; continue; &#125; // 解析accept_filter参数，设置标志位 if (ngx_strncmp(value[n].data, \"accept_filter=\", 14) == 0) &#123;#if (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined SO_ACCEPTFILTER) lsopt.accept_filter = (char *) &amp;value[n].data[14]; lsopt.set = 1; lsopt.bind = 1;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"accept filters \\\"%V\\\" are not supported \" \"on this platform, ignored\", &amp;value[n]);#endif continue; &#125; // deferred 参数 if (ngx_strcmp(value[n].data, \"deferred\") == 0) &#123;#if (NGX_HAVE_DEFERRED_ACCEPT &amp;&amp; defined TCP_DEFER_ACCEPT) lsopt.deferred_accept = 1; lsopt.set = 1; lsopt.bind = 1;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"the deferred accept is not supported \" \"on this platform, ignored\");#endif continue; &#125; // 解析ipv6参数，设置标志位 if (ngx_strncmp(value[n].data, \"ipv6only=o\", 10) == 0) &#123;#if (NGX_HAVE_INET6 &amp;&amp; defined IPV6_V6ONLY) if (ngx_strcmp(&amp;value[n].data[10], \"n\") == 0) &#123; lsopt.ipv6only = 1; &#125; else if (ngx_strcmp(&amp;value[n].data[10], \"ff\") == 0) &#123; lsopt.ipv6only = 0; &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid ipv6only flags \\\"%s\\\"\", &amp;value[n].data[9]); return NGX_CONF_ERROR; &#125; lsopt.set = 1; lsopt.bind = 1; continue;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"ipv6only is not supported \" \"on this platform\"); return NGX_CONF_ERROR;#endif &#125; // reuseport 参数，设置标志位 if (ngx_strcmp(value[n].data, \"reuseport\") == 0) &#123;#if (NGX_HAVE_REUSEPORT) lsopt.reuseport = 1; lsopt.set = 1; lsopt.bind = 1;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"reuseport is not supported \" \"on this platform, ignored\");#endif continue; &#125; // 解析ssl参数，设置标志位 if (ngx_strcmp(value[n].data, \"ssl\") == 0) &#123;#if (NGX_HTTP_SSL) lsopt.ssl = 1; continue;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"the \\\"ssl\\\" parameter requires \" \"ngx_http_ssl_module\"); return NGX_CONF_ERROR;#endif &#125; // 解析http2参数，设置标志位 if (ngx_strcmp(value[n].data, \"http2\") == 0) &#123;#if (NGX_HTTP_V2) lsopt.http2 = 1; continue;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"the \\\"http2\\\" parameter requires \" \"ngx_http_v2_module\"); return NGX_CONF_ERROR;#endif &#125; // 解析spdy参数 if (ngx_strcmp(value[n].data, \"spdy\") == 0) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, \"invalid parameter \\\"spdy\\\": \" \"ngx_http_spdy_module was superseded \" \"by ngx_http_v2_module\"); continue; &#125; // 解析so_keepalive，设置标志位 if (ngx_strncmp(value[n].data, \"so_keepalive=\", 13) == 0) &#123; if (ngx_strcmp(&amp;value[n].data[13], \"on\") == 0) &#123; lsopt.so_keepalive = 1; &#125; else if (ngx_strcmp(&amp;value[n].data[13], \"off\") == 0) &#123; lsopt.so_keepalive = 2; &#125; else &#123;#if (NGX_HAVE_KEEPALIVE_TUNABLE) u_char *p, *end; ngx_str_t s; end = value[n].data + value[n].len; s.data = value[n].data + 13; p = ngx_strlchr(s.data, end, ':'); if (p == NULL) &#123; p = end; &#125; if (p &gt; s.data) &#123; s.len = p - s.data; lsopt.tcp_keepidle = ngx_parse_time(&amp;s, 1); if (lsopt.tcp_keepidle == (time_t) NGX_ERROR) &#123; goto invalid_so_keepalive; &#125; &#125; s.data = (p &lt; end) ? (p + 1) : end; p = ngx_strlchr(s.data, end, ':'); if (p == NULL) &#123; p = end; &#125; if (p &gt; s.data) &#123; s.len = p - s.data; lsopt.tcp_keepintvl = ngx_parse_time(&amp;s, 1); if (lsopt.tcp_keepintvl == (time_t) NGX_ERROR) &#123; goto invalid_so_keepalive; &#125; &#125; s.data = (p &lt; end) ? (p + 1) : end; if (s.data &lt; end) &#123; s.len = end - s.data; lsopt.tcp_keepcnt = ngx_atoi(s.data, s.len); if (lsopt.tcp_keepcnt == NGX_ERROR) &#123; goto invalid_so_keepalive; &#125; &#125; if (lsopt.tcp_keepidle == 0 &amp;&amp; lsopt.tcp_keepintvl == 0 &amp;&amp; lsopt.tcp_keepcnt == 0) &#123; goto invalid_so_keepalive; &#125; lsopt.so_keepalive = 1;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"the \\\"so_keepalive\\\" parameter accepts \" \"only \\\"on\\\" or \\\"off\\\" on this platform\"); return NGX_CONF_ERROR;#endif &#125; lsopt.set = 1; lsopt.bind = 1; continue;#if (NGX_HAVE_KEEPALIVE_TUNABLE) invalid_so_keepalive: ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid so_keepalive value: \\\"%s\\\"\", &amp;value[n].data[13]); return NGX_CONF_ERROR;#endif &#125; // 解析pp协议参数，开启pp协议标志位 if (ngx_strcmp(value[n].data, \"proxy_protocol\") == 0) &#123; lsopt.proxy_protocol = 1; continue; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\", &amp;value[n]); return NGX_CONF_ERROR; &#125; // 处理监听端口 for (n = 0; n &lt; u.naddrs; n++) &#123; lsopt.sockaddr = u.addrs[n].sockaddr; lsopt.socklen = u.addrs[n].socklen; lsopt.addr_text = u.addrs[n].name; // 获取通配符关键字 lsopt.wildcard = ngx_inet_wildcard(lsopt.sockaddr); // 将端口放入全局端口列表中 if (ngx_http_add_listen(cf, cscf, &amp;lsopt) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; return NGX_CONF_OK;&#125;接下来看看解析location指令的函数, ngx_http_core_location的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207static char *ngx_http_core_location(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)&#123; char *rv; u_char *mod; size_t len; ngx_str_t *value, *name; ngx_uint_t i; ngx_conf_t save; ngx_http_module_t *module; ngx_http_conf_ctx_t *ctx, *pctx; ngx_http_core_loc_conf_t *clcf, *pclcf; // 首先申请保存配置的内存 ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; // 设置main级别和server级别配置 pctx = cf-&gt;ctx; ctx-&gt;main_conf = pctx-&gt;main_conf; ctx-&gt;srv_conf = pctx-&gt;srv_conf; ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;loc_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; // 遍历http模块，调用创建location级别配置函数 for (i = 0; cf-&gt;cycle-&gt;modules[i]; i++) &#123; // 跳过非http模块 if (cf-&gt;cycle-&gt;modules[i]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = cf-&gt;cycle-&gt;modules[i]-&gt;ctx; if (module-&gt;create_loc_conf) &#123; ctx-&gt;loc_conf[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index] = module-&gt;create_loc_conf(cf); if (ctx-&gt;loc_conf[cf-&gt;cycle-&gt;modules[i]-&gt;ctx_index] == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; &#125; // 取出core模块的location级别配置 clcf = ctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; clcf-&gt;loc_conf = ctx-&gt;loc_conf; value = cf-&gt;args-&gt;elts; // 处理location指令后的参数，比如/ ~ = 以及其他正则表达式 if (cf-&gt;args-&gt;nelts == 3) &#123; len = value[1].len; mod = value[1].data; name = &amp;value[2]; if (len == 1 &amp;&amp; mod[0] == &apos;=&apos;) &#123; clcf-&gt;name = *name; clcf-&gt;exact_match = 1; &#125; else if (len == 2 &amp;&amp; mod[0] == &apos;^&apos; &amp;&amp; mod[1] == &apos;~&apos;) &#123; clcf-&gt;name = *name; clcf-&gt;noregex = 1; &#125; else if (len == 1 &amp;&amp; mod[0] == &apos;~&apos;) &#123; if (ngx_http_core_regex_location(cf, clcf, name, 0) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; else if (len == 2 &amp;&amp; mod[0] == &apos;~&apos; &amp;&amp; mod[1] == &apos;*&apos;) &#123; if (ngx_http_core_regex_location(cf, clcf, name, 1) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid location modifier \\&quot;%V\\&quot;&quot;, &amp;value[1]); return NGX_CONF_ERROR; &#125; &#125; else &#123; name = &amp;value[1]; if (name-&gt;data[0] == &apos;=&apos;) &#123; clcf-&gt;name.len = name-&gt;len - 1; clcf-&gt;name.data = name-&gt;data + 1; clcf-&gt;exact_match = 1; &#125; else if (name-&gt;data[0] == &apos;^&apos; &amp;&amp; name-&gt;data[1] == &apos;~&apos;) &#123; clcf-&gt;name.len = name-&gt;len - 2; clcf-&gt;name.data = name-&gt;data + 2; clcf-&gt;noregex = 1; &#125; else if (name-&gt;data[0] == &apos;~&apos;) &#123; name-&gt;len--; name-&gt;data++; if (name-&gt;data[0] == &apos;*&apos;) &#123; name-&gt;len--; name-&gt;data++; // 处理正则表达式 if (ngx_http_core_regex_location(cf, clcf, name, 1) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; else &#123; if (ngx_http_core_regex_location(cf, clcf, name, 0) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; &#125; else &#123; // 保存clcf的name clcf-&gt;name = *name; if (name-&gt;data[0] == &apos;@&apos;) &#123; clcf-&gt;named = 1; &#125; &#125; &#125; // 设置location级别的配置 pclcf = pctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; // 判断是否微location类型配置 if (cf-&gt;cmd_type == NGX_HTTP_LOC_CONF) &#123; /* nested location */#if 0 clcf-&gt;prev_location = pclcf;#endif if (pclcf-&gt;exact_match) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;location \\&quot;%V\\&quot; cannot be inside &quot; &quot;the exact location \\&quot;%V\\&quot;&quot;, &amp;clcf-&gt;name, &amp;pclcf-&gt;name); return NGX_CONF_ERROR; &#125; if (pclcf-&gt;named) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;location \\&quot;%V\\&quot; cannot be inside &quot; &quot;the named location \\&quot;%V\\&quot;&quot;, &amp;clcf-&gt;name, &amp;pclcf-&gt;name); return NGX_CONF_ERROR; &#125; if (clcf-&gt;named) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;named location \\&quot;%V\\&quot; can be &quot; &quot;on the server level only&quot;, &amp;clcf-&gt;name); return NGX_CONF_ERROR; &#125; len = pclcf-&gt;name.len;#if (NGX_PCRE) if (clcf-&gt;regex == NULL &amp;&amp; ngx_filename_cmp(clcf-&gt;name.data, pclcf-&gt;name.data, len) != 0)#else if (ngx_filename_cmp(clcf-&gt;name.data, pclcf-&gt;name.data, len) != 0)#endif &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;location \\&quot;%V\\&quot; is outside location \\&quot;%V\\&quot;&quot;, &amp;clcf-&gt;name, &amp;pclcf-&gt;name); return NGX_CONF_ERROR; &#125; &#125; // 添加location if (ngx_http_add_location(cf, &amp;pclcf-&gt;locations, clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; // 保持cf结构体 save = *cf; cf-&gt;ctx = ctx; cf-&gt;cmd_type = NGX_HTTP_LOC_CONF; // 解析location里面的指令 rv = ngx_conf_parse(cf, NULL); // 恢复原来的配置 *cf = save; return rv;&#125;接下来看看root指令解析函数，ngx_http_core_root的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106static char *ngx_http_core_root(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *clcf = conf; ngx_str_t *value; ngx_int_t alias; ngx_uint_t n; ngx_http_script_compile_t sc; alias = (cmd-&gt;name.len == sizeof(&quot;alias&quot;) - 1) ? 1 : 0; if (clcf-&gt;root.data) &#123; if ((clcf-&gt;alias != 0) == alias) &#123; return &quot;is duplicate&quot;; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;\\&quot;%V\\&quot; directive is duplicate, &quot; &quot;\\&quot;%s\\&quot; directive was specified earlier&quot;, &amp;cmd-&gt;name, clcf-&gt;alias ? &quot;alias&quot; : &quot;root&quot;); return NGX_CONF_ERROR; &#125; if (clcf-&gt;named &amp;&amp; alias) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;the \\&quot;alias\\&quot; directive cannot be used &quot; &quot;inside the named location&quot;); return NGX_CONF_ERROR; &#125; value = cf-&gt;args-&gt;elts; // 处理第一个参数 if (ngx_strstr(value[1].data, &quot;$document_root&quot;) || ngx_strstr(value[1].data, &quot;$&#123;document_root&#125;&quot;)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;the $document_root variable cannot be used &quot; &quot;in the \\&quot;%V\\&quot; directive&quot;, &amp;cmd-&gt;name); return NGX_CONF_ERROR; &#125; if (ngx_strstr(value[1].data, &quot;$realpath_root&quot;) || ngx_strstr(value[1].data, &quot;$&#123;realpath_root&#125;&quot;)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;the $realpath_root variable cannot be used &quot; &quot;in the \\&quot;%V\\&quot; directive&quot;, &amp;cmd-&gt;name); return NGX_CONF_ERROR; &#125; clcf-&gt;alias = alias ? clcf-&gt;name.len : 0; clcf-&gt;root = value[1]; if (!alias &amp;&amp; clcf-&gt;root.len &gt; 0 &amp;&amp; clcf-&gt;root.data[clcf-&gt;root.len - 1] == &apos;/&apos;) &#123; clcf-&gt;root.len--; &#125; if (clcf-&gt;root.data[0] != &apos;$&apos;) &#123; if (ngx_conf_full_name(cf-&gt;cycle, &amp;clcf-&gt;root, 0) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; // 统计变量数量 n = ngx_http_script_variables_count(&amp;clcf-&gt;root); // 结构体置空 ngx_memzero(&amp;sc, sizeof(ngx_http_script_compile_t)); sc.variables = n;#if (NGX_PCRE) if (alias &amp;&amp; clcf-&gt;regex) &#123; clcf-&gt;alias = NGX_MAX_SIZE_T_VALUE; n = 1; &#125;#endif //处理变量 if (n) &#123; sc.cf = cf; sc.source = &amp;clcf-&gt;root; sc.lengths = &amp;clcf-&gt;root_lengths; sc.values = &amp;clcf-&gt;root_values; sc.complete_lengths = 1; sc.complete_values = 1; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; return NGX_CONF_OK;&#125;接下来看看type指令解析函数, ngx_http_core_type的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static char *ngx_http_core_type(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)&#123; ngx_http_core_loc_conf_t *clcf = conf; ngx_str_t *value, *content_type, *old; ngx_uint_t i, n, hash; ngx_hash_key_t *type; value = cf-&gt;args-&gt;elts; // 解析第一个参数，判断是否为include if (ngx_strcmp(value[0].data, &quot;include&quot;) == 0) &#123; if (cf-&gt;args-&gt;nelts != 2) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid number of arguments&quot; &quot; in \\&quot;include\\&quot; directive&quot;); return NGX_CONF_ERROR; &#125; return ngx_conf_include(cf, dummy, conf); &#125; //申请保存content_type的内存 content_type = ngx_palloc(cf-&gt;pool, sizeof(ngx_str_t)); if (content_type == NULL) &#123; return NGX_CONF_ERROR; &#125; // 取content_type的值 *content_type = value[0]; for (i = 1; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; hash = ngx_hash_strlow(value[i].data, value[i].data, value[i].len); type = clcf-&gt;types-&gt;elts; for (n = 0; n &lt; clcf-&gt;types-&gt;nelts; n++) &#123; if (ngx_strcmp(value[i].data, type[n].key.data) == 0) &#123; old = type[n].value; type[n].value = content_type; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;duplicate extension \\&quot;%V\\&quot;, &quot; &quot;content type: \\&quot;%V\\&quot;, &quot; &quot;previous content type: \\&quot;%V\\&quot;&quot;, &amp;value[i], content_type, old); goto next; &#125; &#125; // 从types中取出一个元素 type = ngx_array_push(clcf-&gt;types); if (type == NULL) &#123; return NGX_CONF_ERROR; &#125; //保存 type-&gt;key = value[i]; type-&gt;key_hash = hash; type-&gt;value = content_type; next: continue; &#125; return NGX_CONF_OK;&#125;接下来看看server_name指令的解析函数, ngx_http_core_server_name的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111static char *ngx_http_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_srv_conf_t *cscf = conf; u_char ch; ngx_str_t *value; ngx_uint_t i; ngx_http_server_name_t *sn; // 取参数 value = cf-&gt;args-&gt;elts; // 遍历参数个数 for (i = 1; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; ch = value[i].data[0]; // 判断是否为通配符 if ((ch == &apos;*&apos; &amp;&amp; (value[i].len &lt; 3 || value[i].data[1] != &apos;.&apos;)) || (ch == &apos;.&apos; &amp;&amp; value[i].len &lt; 2)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;server name \\&quot;%V\\&quot; is invalid&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; // 判断server_name中是否含有/ if (ngx_strchr(value[i].data, &apos;/&apos;)) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;server name \\&quot;%V\\&quot; has suspicious symbols&quot;, &amp;value[i]); &#125; // 取一个server_name的元素 sn = ngx_array_push(&amp;cscf-&gt;server_names); if (sn == NULL) &#123; return NGX_CONF_ERROR; &#125;#if (NGX_PCRE) sn-&gt;regex = NULL;#endif // 保存server块配置结构体 sn-&gt;server = cscf; // 判断server_name参数是否为主机名称，如果是，则使用cycle-&gt;hostname，否则server_name的值就是value的值 if (ngx_strcasecmp(value[i].data, (u_char *) &quot;$hostname&quot;) == 0) &#123; sn-&gt;name = cf-&gt;cycle-&gt;hostname; &#125; else &#123; sn-&gt;name = value[i]; &#125; // 处理server_name转小写 if (value[i].data[0] != &apos;~&apos;) &#123; ngx_strlow(sn-&gt;name.data, sn-&gt;name.data, sn-&gt;name.len); continue; &#125;#if (NGX_PCRE) // 处理正则表达式 &#123; u_char *p; ngx_regex_compile_t rc; u_char errstr[NGX_MAX_CONF_ERRSTR]; if (value[i].len == 1) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;empty regex in server name \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; // 跳过第一个符号 value[i].len--; value[i].data++; ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t)); rc.pattern = value[i]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; for (p = value[i].data; p &lt; value[i].data + value[i].len; p++) &#123; if (*p &gt;= &apos;A&apos; &amp;&amp; *p &lt;= &apos;Z&apos;) &#123; rc.options = NGX_REGEX_CASELESS; break; &#125; &#125; // 编译正则表达式 sn-&gt;regex = ngx_http_regex_compile(cf, &amp;rc); if (sn-&gt;regex == NULL) &#123; return NGX_CONF_ERROR; &#125; sn-&gt;name = value[i]; cscf-&gt;captures = (rc.captures &gt; 0); &#125;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;using regex \\&quot;%V\\&quot; &quot; &quot;requires PCRE library&quot;, &amp;value[i]); return NGX_CONF_ERROR;#endif &#125; return NGX_CONF_OK;&#125;接下来看看error_page指令的解析函数, ngx_http_core_error_page的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119ngx_http_core_error_page(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_core_loc_conf_t *clcf = conf; u_char *p; ngx_int_t overwrite; ngx_str_t *value, uri, args; ngx_uint_t i, n; ngx_http_err_page_t *err; ngx_http_complex_value_t cv; ngx_http_compile_complex_value_t ccv; if (clcf-&gt;error_pages == NULL) &#123; clcf-&gt;error_pages = ngx_array_create(cf-&gt;pool, 4, sizeof(ngx_http_err_page_t)); if (clcf-&gt;error_pages == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; value = cf-&gt;args-&gt;elts; i = cf-&gt;args-&gt;nelts - 2; // 解析重定向的code if (value[i].data[0] == '=') &#123; if (i == 1) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid value \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; if (value[i].len &gt; 1) &#123; overwrite = ngx_atoi(&amp;value[i].data[1], value[i].len - 1); if (overwrite == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid value \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; &#125; else &#123; overwrite = 0; &#125; n = 2; &#125; else &#123; overwrite = -1; n = 1; &#125; uri = value[cf-&gt;args-&gt;nelts - 1]; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;uri; ccv.complex_value = &amp;cv; // 解析uri变量 if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; ngx_str_null(&amp;args); // 解析uri及参数 if (cv.lengths == NULL &amp;&amp; uri.len &amp;&amp; uri.data[0] == '/') &#123; //搜索查询参数起点 p = (u_char *) ngx_strchr(uri.data, '?'); if (p) &#123; cv.value.len = p - uri.data; cv.value.data = uri.data; p++; args.len = (uri.data + uri.len) - p; args.data = p; &#125; &#125; // 开始从第一个参数解析需要重定向的code for (i = 1; i &lt; cf-&gt;args-&gt;nelts - n; i++) &#123; err = ngx_array_push(clcf-&gt;error_pages); if (err == NULL) &#123; return NGX_CONF_ERROR; &#125; // 解析数字code err-&gt;status = ngx_atoi(value[i].data, value[i].len); // 如果解析出错或者是499，则直接返回错误 if (err-&gt;status == NGX_ERROR || err-&gt;status == 499) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid value \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; // status范围300-599之间 if (err-&gt;status &lt; 300 || err-&gt;status &gt; 599) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"value \\\"%V\\\" must be between 300 and 599\", &amp;value[i]); return NGX_CONF_ERROR; &#125; err-&gt;overwrite = overwrite; if (overwrite == -1) &#123; switch (err-&gt;status) &#123; case NGX_HTTP_TO_HTTPS: case NGX_HTTPS_CERT_ERROR: case NGX_HTTPS_NO_CERT: case NGX_HTTP_REQUEST_HEADER_TOO_LARGE: err-&gt;overwrite = NGX_HTTP_BAD_REQUEST; &#125; &#125; err-&gt;value = cv; err-&gt;args = args; &#125; return NGX_CONF_OK;&#125;error_page主要用于内部重定向，在special response的时候处理相关逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111ngx_int_tngx_http_special_response_handler(ngx_http_request_t *r, ngx_int_t error)&#123; ngx_uint_t i, err; ngx_http_err_page_t *err_page; ngx_http_core_loc_conf_t *clcf; ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http special response: %i, \\\"%V?%V\\\"\", error, &amp;r-&gt;uri, &amp;r-&gt;args); r-&gt;err_status = error; if (r-&gt;keepalive) &#123; switch (error) &#123; case NGX_HTTP_BAD_REQUEST: case NGX_HTTP_REQUEST_ENTITY_TOO_LARGE: case NGX_HTTP_REQUEST_URI_TOO_LARGE: case NGX_HTTP_TO_HTTPS: case NGX_HTTPS_CERT_ERROR: case NGX_HTTPS_NO_CERT: case NGX_HTTP_INTERNAL_SERVER_ERROR: case NGX_HTTP_NOT_IMPLEMENTED: r-&gt;keepalive = 0; &#125; &#125; if (r-&gt;lingering_close) &#123; switch (error) &#123; case NGX_HTTP_BAD_REQUEST: case NGX_HTTP_TO_HTTPS: case NGX_HTTPS_CERT_ERROR: case NGX_HTTPS_NO_CERT: r-&gt;lingering_close = 0; &#125; &#125; // content-length置为0 r-&gt;headers_out.content_type.len = 0; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); // 这里对error_page以及uri_changes判断 if (!r-&gt;error_page &amp;&amp; clcf-&gt;error_pages &amp;&amp; r-&gt;uri_changes != 0) &#123; if (clcf-&gt;recursive_error_pages == 0) &#123; r-&gt;error_page = 1; &#125; err_page = clcf-&gt;error_pages-&gt;elts; // 找到对应code for (i = 0; i &lt; clcf-&gt;error_pages-&gt;nelts; i++) &#123; if (err_page[i].status == error) &#123; // 直接调用error_page逻辑 return ngx_http_send_error_page(r, &amp;err_page[i]); &#125; &#125; &#125; r-&gt;expect_tested = 1; if (ngx_http_discard_request_body(r) != NGX_OK) &#123; r-&gt;keepalive = 0; &#125; if (clcf-&gt;msie_refresh &amp;&amp; r-&gt;headers_in.msie &amp;&amp; (error == NGX_HTTP_MOVED_PERMANENTLY || error == NGX_HTTP_MOVED_TEMPORARILY)) &#123; return ngx_http_send_refresh(r); &#125; if (error == NGX_HTTP_CREATED) &#123; /* 201 */ err = 0; &#125; else if (error == NGX_HTTP_NO_CONTENT) &#123; /* 204 */ err = 0; &#125; else if (error &gt;= NGX_HTTP_MOVED_PERMANENTLY &amp;&amp; error &lt; NGX_HTTP_LAST_3XX) &#123; /* 3XX */ err = error - NGX_HTTP_MOVED_PERMANENTLY + NGX_HTTP_OFF_3XX; &#125; else if (error &gt;= NGX_HTTP_BAD_REQUEST &amp;&amp; error &lt; NGX_HTTP_LAST_4XX) &#123; /* 4XX */ err = error - NGX_HTTP_BAD_REQUEST + NGX_HTTP_OFF_4XX; &#125; else if (error &gt;= NGX_HTTP_NGINX_CODES &amp;&amp; error &lt; NGX_HTTP_LAST_5XX) &#123; /* 49X, 5XX */ err = error - NGX_HTTP_NGINX_CODES + NGX_HTTP_OFF_5XX; switch (error) &#123; case NGX_HTTP_TO_HTTPS: case NGX_HTTPS_CERT_ERROR: case NGX_HTTPS_NO_CERT: case NGX_HTTP_REQUEST_HEADER_TOO_LARGE: r-&gt;err_status = NGX_HTTP_BAD_REQUEST; &#125; &#125; else &#123; /* unknown code, zero body */ err = 0; &#125; return ngx_http_send_special_response(r, clcf, err);&#125;接下来看下ngx_http_send_error_page的函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static ngx_int_tngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)&#123; ngx_int_t overwrite; ngx_str_t uri, args; ngx_table_elt_t *location; ngx_http_core_loc_conf_t *clcf; overwrite = err_page-&gt;overwrite; if (overwrite &amp;&amp; overwrite != NGX_HTTP_OK) &#123; r-&gt;expect_tested = 1; &#125; // 如果配置了code，则将error_code置为配置的code if (overwrite &gt;= 0) &#123; r-&gt;err_status = overwrite; &#125; // 处理url中的变量 if (ngx_http_complex_value(r, &amp;err_page-&gt;value, &amp;uri) != NGX_OK) &#123; return NGX_ERROR; &#125; // 如果url是/开始 if (uri.len &amp;&amp; uri.data[0] == '/') &#123; if (err_page-&gt;value.lengths) &#123; ngx_http_split_args(r, &amp;uri, &amp;args); &#125; else &#123; args = err_page-&gt;args; &#125; if (r-&gt;method != NGX_HTTP_HEAD) &#123; r-&gt;method = NGX_HTTP_GET; r-&gt;method_name = ngx_http_core_get_method; &#125; return ngx_http_internal_redirect(r, &amp;uri, &amp;args); &#125; // 跳转到name的location if (uri.len &amp;&amp; uri.data[0] == '@') &#123; return ngx_http_named_location(r, &amp;uri); &#125; r-&gt;expect_tested = 1; if (ngx_http_discard_request_body(r) != NGX_OK) &#123; r-&gt;keepalive = 0; &#125; // 从headers中取一个元素，用作重定向 location = ngx_list_push(&amp;r-&gt;headers_out.headers); if (location == NULL) &#123; return NGX_ERROR; &#125; if (overwrite != NGX_HTTP_MOVED_PERMANENTLY &amp;&amp; overwrite != NGX_HTTP_MOVED_TEMPORARILY &amp;&amp; overwrite != NGX_HTTP_SEE_OTHER &amp;&amp; overwrite != NGX_HTTP_TEMPORARY_REDIRECT &amp;&amp; overwrite != NGX_HTTP_PERMANENT_REDIRECT) &#123; r-&gt;err_status = NGX_HTTP_MOVED_TEMPORARILY; &#125; location-&gt;hash = 1; ngx_str_set(&amp;location-&gt;key, \"Location\"); location-&gt;value = uri; ngx_http_clear_location(r); r-&gt;headers_out.location = location; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); if (clcf-&gt;msie_refresh &amp;&amp; r-&gt;headers_in.msie) &#123; return ngx_http_send_refresh(r); &#125; return ngx_http_send_special_response(r, clcf, r-&gt;err_status - NGX_HTTP_MOVED_PERMANENTLY + NGX_HTTP_OFF_3XX);&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"vxlan学习笔记","slug":"vxlan学习笔记","date":"2021-04-10T14:05:41.000Z","updated":"2021-04-29T14:02:30.501Z","comments":true,"path":"2021/04/10/vxlan学习笔记/","link":"","permalink":"https://weeweetan.github.io/2021/04/10/vxlan学习笔记/","excerpt":"","text":"1. 报文格式具体参照RFC73480 1 2 30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1Outer Ethernet Header:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Outer Destination MAC Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Outer Destination MAC Address | Outer Source MAC Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Outer Source MAC Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|OptnlEthtype = C-Tag 802.1Q | Outer.VLAN Tag Information |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Ethertype = 0x0800 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Outer IPv4 Header:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version| IHL |Type of Service| Total Length |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Identification |Flags| Fragment Offset |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Time to Live |Protocl=17(UDP)| Header Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Outer Source IPv4 Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Outer Destination IPv4 Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Outer UDP Header:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Source Port | Dest Port = VXLAN Port |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| UDP Length | UDP Checksum |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+VXLAN Header:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|R|R|R|R|I|R|R|R| Reserved |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| VXLAN Network Identifier (VNI) | Reserved |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Inner Ethernet Header:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Inner Destination MAC Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Inner Destination MAC Address | Inner Source MAC Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Inner Source MAC Address |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|OptnlEthtype = C-Tag 802.1Q | Inner.VLAN Tag Information |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Payload:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| Ethertype of Original Payload | |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ || Original Ethernet Payload || ||(Note that the original Ethernet Frame’s FCS is not included) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Frame Check Sequence:+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| New FCS (Frame Check Sequence) for Outer Ethernet Frame |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+2. 字段说明Outer MAC Header：封装外层以太头，14字节，如果有VLAN TAG则为18字节。其中，源MAC地址（Outer Source MAC Address）为源VM所属VTEP的MAC地址，目的MAC地址（Outer Destination MAC Address）为到达目的VTEP的路径上下一跳设备的MAC地址。类型字段为0x0800，指示内层封装的是IP报文。Outer IP Header：封装外层IP头，20字节。其中，源IP地址（Outer Source IP Address）为源VM所属VTEP的IP地址，目的IP地址（Outer Destination IP Address）为目的VM所属VTEP的IP地址。协议字段为0x11，指示内层封装的是UDP报文。UDP Header：UDP报文头，8字节。其中，UDP目的端口号（UDP Destination Port）固定为4789，指示内层封装报文为VXLAN报文。UDP源端口号（UDP Source Port）为随机任意值，可以用于VTEP之间多路径负载分担的计算。VXLAN Header：VXLAN协议新定义的VXLAN头，8字节。Flags：8 bit，RRRRIRRR。”I”位为1时，表示VXLAN头中的VXLAN ID有效；为0，表示VXLAN ID无效。”R”位保留未用，设置为0。VXLAN ID（VNI）：24 bit，用于标识一个单独的VXLAN网络。Reserved：分别为24 bit和8 bit。保留位。Original L2 Frame：原始以太网报文。","categories":[],"tags":[{"name":"vxlan","slug":"vxlan","permalink":"https://weeweetan.github.io/tags/vxlan/"}]},{"title":"FFmpeg学习笔记","slug":"FFmpeg学习笔记","date":"2020-11-14T09:37:03.000Z","updated":"2021-04-09T14:27:28.830Z","comments":true,"path":"2020/11/14/FFmpeg学习笔记/","link":"","permalink":"https://weeweetan.github.io/2020/11/14/FFmpeg学习笔记/","excerpt":"","text":"1、组件1.1、avcodec：编解码（最重要的库）1.2、avdevice：各种设备的输入输出1.3、avfilter：滤镜特效处理1.4、avformat：封装格式处理1.5、avutil：工具库（大部分库都需要这个库的支持）1.6、postproc：后加工1.7、swresample：音频采样数据格式转换1.8、swscale：视频像素数据格式转换2、命令行工具2.1、ffmpegfmpeg是用于转码的应用程序，常用命令可用ffmpeg -h显示2.2、ffplayffplay用 SDL和FFmpeg库开发的一个简单的媒体播放器，支持格式众多，可支持udp、rtp、hls、rtsp等2.3、ffprobe查看多媒体文件信息的模块，此模块可以用来查看多媒体文件格式以及编码。2.4、ffserver基于HTTP、RTSP用于实时广播的多媒体服务器.也支持时间平移","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://weeweetan.github.io/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://weeweetan.github.io/tags/FFmpeg/"}]},{"title":"Nginx的共享内存详解","slug":"Nginx的共享内存详解","date":"2020-05-25T12:05:11.000Z","updated":"2020-08-11T11:41:49.819Z","comments":true,"path":"2020/05/25/Nginx的共享内存详解/","link":"","permalink":"https://weeweetan.github.io/2020/05/25/Nginx的共享内存详解/","excerpt":"","text":"1. 简述1.1 应用介绍nginx使用共享内存的模块有ngx_http_file_cache_module、ngx_http_limit_conn_module、ngx_http_limit_req_module等模块。无一例外，这几个模块都是使用nginx实现的红黑树，基于共享内存来保存他们所需要的数据。2 源码详解2.1 首先来看看相关结构体定义123456789101112131415161718192021222324252627282930313233343536373839404142434445typedef struct ngx_slab_page_s ngx_slab_page_t;struct ngx_slab_page_s &#123; uintptr_t slab; ngx_slab_page_t *next; //下一个page页 uintptr_t prev; //上一个page页&#125;;// slab状态结构体typedef struct &#123; ngx_uint_t total; ngx_uint_t used; ngx_uint_t reqs; ngx_uint_t fails;&#125; ngx_slab_stat_t;typedef struct &#123; ngx_shmtx_sh_t lock; //mutex锁 size_t min_size; //设定的最小内存块长度； size_t min_shift; //ngx_init_zone_pool中默认为3 ngx_slab_page_t *pages; //每一页对应一个ngx_slab_page_t页描述结构体，所有的ngx_slab_page_t存放在连续的内存中构成数组，而pages就是数组首地址 ngx_slab_page_t *last; //最后页面地址 ngx_slab_page_t free; //所有的空闲页组成一个链表挂在free成员上 ngx_slab_stat_t *stats; ngx_uint_t pfree; // 剩余页数 u_char *start; //第一页的首地址 u_char *end; //指向这段共享内存的尾部 ngx_shmtx_t mutex; //Nginx封装的互斥锁 u_char *log_ctx; // slab操作失败时会记录日志，为区别是哪个slab共享内存出错，可以在slab中分配一段内存存放描述的字符串，然后再用log_ctx指向这个字符串 u_char zero; // 表示空字符串防止出错 unsigned log_nomem:1; void *data; //slab的模块自由使用，slab管理内存时不会用到它 void *addr; //指向所属的ngx_shm_zone_t里的ngx_shm_t成员的addr成员，一般用于指示一段共享内存块的起始位置&#125; ngx_slab_pool_t;2.2 相关函数及其介绍主要涉及到共享内存的初始化，加锁申请，不加锁申请，加锁释放，不加锁释放等函数。首先来看下初始化的两个函数ngx_slab_sizes_init、ngx_slab_init，ngx_slab_sizes_init函数使用操作系统内存页初始化slab_max_size。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485voidngx_slab_sizes_init(void)&#123; ngx_uint_t n; ngx_slab_max_size = ngx_pagesize / 2; ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t)); for (n = ngx_slab_exact_size; n &gt;&gt;= 1; ngx_slab_exact_shift++) &#123; /* void */ &#125;&#125;voidngx_slab_init(ngx_slab_pool_t *pool)&#123; u_char *p; size_t size; ngx_int_t m; ngx_uint_t i, n, pages; ngx_slab_page_t *slots, *page; //最小分配的空间是8byte pool-&gt;min_size = (size_t) 1 &lt;&lt; pool-&gt;min_shift; slots = ngx_slab_slots(pool); p = (u_char *) slots; size = pool-&gt;end - p; ngx_slab_junk(p, size); n = ngx_pagesize_shift - pool-&gt;min_shift; for (i = 0; i &lt; n; i++) &#123; /* only \"next\" is used in list head */ slots[i].slab = 0; slots[i].next = &amp;slots[i]; slots[i].prev = 0; &#125; //跳过上面那些slab page p += n * sizeof(ngx_slab_page_t); pool-&gt;stats = (ngx_slab_stat_t *) p; ngx_memzero(pool-&gt;stats, n * sizeof(ngx_slab_stat_t)); p += n * sizeof(ngx_slab_stat_t); size -= n * (sizeof(ngx_slab_page_t) + sizeof(ngx_slab_stat_t)); pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t))); pool-&gt;pages = (ngx_slab_page_t *) p; ngx_memzero(pool-&gt;pages, pages * sizeof(ngx_slab_page_t)); page = pool-&gt;pages; /* only \"next\" is used in list head */ //初始化free，free.next是下次分配页时候的入口 pool-&gt;free.slab = 0; pool-&gt;free.next = page; pool-&gt;free.prev = 0; //更新第一个slab page的状态，这儿slab成员记录了整个缓存区的页数目 page-&gt;slab = pages; page-&gt;next = &amp;pool-&gt;free; page-&gt;prev = (uintptr_t) &amp;pool-&gt;free; //实际缓存区(页)的开头，对齐 //因为对齐的原因,使得m_page数组和数据区域之间可能有些内存无法使用 pool-&gt;start = ngx_align_ptr(p + pages * sizeof(ngx_slab_page_t), ngx_pagesize); m = pages - (pool-&gt;end - pool-&gt;start) / ngx_pagesize; if (m &gt; 0) &#123; pages -= m; page-&gt;slab = pages; &#125; //跳过pages * sizeof(ngx_slab_page_t) pool-&gt;last = pool-&gt;pages + pages; pool-&gt;pfree = pages; pool-&gt;log_nomem = 1; pool-&gt;log_ctx = &amp;pool-&gt;zero; pool-&gt;zero = '\\0';&#125;接下来看看申请内存的相关函数ngx_slab_alloc、ngx_slab_alloc_locked、ngx_slab_calloc、ngx_slab_calloc_locked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338void *ngx_slab_alloc(ngx_slab_pool_t *pool, size_t size)&#123; void *p; //由于是共享内存，所以在进程间需要用锁来保持同步 ngx_shmtx_lock(&amp;pool-&gt;mutex); p = ngx_slab_alloc_locked(pool, size); ngx_shmtx_unlock(&amp;pool-&gt;mutex); return p;&#125;void *ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size)&#123; size_t s; uintptr_t p, m, mask, *bitmap; ngx_uint_t i, n, slot, shift, map; ngx_slab_page_t *page, *prev, *slots; if (size &gt; ngx_slab_max_size) &#123; ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;log, 0, \"slab alloc: %uz\", size); page = ngx_slab_alloc_pages(pool, (size &gt;&gt; ngx_pagesize_shift) + ((size % ngx_pagesize) ? 1 : 0)); if (page) &#123; p = ngx_slab_page_addr(pool, page); &#125; else &#123; p = 0; &#125; goto done; &#125; if (size &gt; pool-&gt;min_size) &#123; shift = 1; for (s = size - 1; s &gt;&gt;= 1; shift++) &#123; /* void */ &#125; slot = shift - pool-&gt;min_shift; &#125; else &#123; shift = pool-&gt;min_shift; slot = 0; &#125; pool-&gt;stats[slot].reqs++; ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;log, 0, \"slab alloc: %uz slot: %ui\", size, slot); slots = ngx_slab_slots(pool); page = slots[slot].next; if (page-&gt;next != page) &#123; if (shift &lt; ngx_slab_exact_shift) &#123; bitmap = (uintptr_t *) ngx_slab_page_addr(pool, page); map = (ngx_pagesize &gt;&gt; shift) / (8 * sizeof(uintptr_t)); for (n = 0; n &lt; map; n++) &#123; if (bitmap[n] != NGX_SLAB_BUSY) &#123; for (m = 1, i = 0; m; m &lt;&lt;= 1, i++) &#123; if (bitmap[n] &amp; m) &#123; continue; &#125; bitmap[n] |= m; i = (n * 8 * sizeof(uintptr_t) + i) &lt;&lt; shift; p = (uintptr_t) bitmap + i; pool-&gt;stats[slot].used++; if (bitmap[n] == NGX_SLAB_BUSY) &#123; for (n = n + 1; n &lt; map; n++) &#123; if (bitmap[n] != NGX_SLAB_BUSY) &#123; goto done; &#125; &#125; prev = ngx_slab_page_prev(page); prev-&gt;next = page-&gt;next; page-&gt;next-&gt;prev = page-&gt;prev; page-&gt;next = NULL; page-&gt;prev = NGX_SLAB_SMALL; &#125; goto done; &#125; &#125; &#125; &#125; else if (shift == ngx_slab_exact_shift) &#123; for (m = 1, i = 0; m; m &lt;&lt;= 1, i++) &#123; if (page-&gt;slab &amp; m) &#123; continue; &#125; page-&gt;slab |= m; if (page-&gt;slab == NGX_SLAB_BUSY) &#123; prev = ngx_slab_page_prev(page); prev-&gt;next = page-&gt;next; page-&gt;next-&gt;prev = page-&gt;prev; page-&gt;next = NULL; page-&gt;prev = NGX_SLAB_EXACT; &#125; p = ngx_slab_page_addr(pool, page) + (i &lt;&lt; shift); pool-&gt;stats[slot].used++; goto done; &#125; &#125; else &#123; /* shift &gt; ngx_slab_exact_shift */ mask = ((uintptr_t) 1 &lt;&lt; (ngx_pagesize &gt;&gt; shift)) - 1; mask &lt;&lt;= NGX_SLAB_MAP_SHIFT; for (m = (uintptr_t) 1 &lt;&lt; NGX_SLAB_MAP_SHIFT, i = 0; m &amp; mask; m &lt;&lt;= 1, i++) &#123; if (page-&gt;slab &amp; m) &#123; continue; &#125; page-&gt;slab |= m; if ((page-&gt;slab &amp; NGX_SLAB_MAP_MASK) == mask) &#123; prev = ngx_slab_page_prev(page); prev-&gt;next = page-&gt;next; page-&gt;next-&gt;prev = page-&gt;prev; page-&gt;next = NULL; page-&gt;prev = NGX_SLAB_BIG; &#125; p = ngx_slab_page_addr(pool, page) + (i &lt;&lt; shift); pool-&gt;stats[slot].used++; goto done; &#125; &#125; ngx_slab_error(pool, NGX_LOG_ALERT, \"ngx_slab_alloc(): page is busy\"); ngx_debug_point(); &#125; //分出一页加入到m_slot数组对应元素中 page = ngx_slab_alloc_pages(pool, 1); if (page) &#123; if (shift &lt; ngx_slab_exact_shift) &#123; bitmap = (uintptr_t *) ngx_slab_page_addr(pool, page); n = (ngx_pagesize &gt;&gt; shift) / ((1 &lt;&lt; shift) * 8); if (n == 0) &#123; n = 1; &#125; /* \"n\" elements for bitmap, plus one requested */ for (i = 0; i &lt; (n + 1) / (8 * sizeof(uintptr_t)); i++) &#123; bitmap[i] = NGX_SLAB_BUSY; &#125; m = ((uintptr_t) 1 &lt;&lt; ((n + 1) % (8 * sizeof(uintptr_t)))) - 1; bitmap[i] = m; map = (ngx_pagesize &gt;&gt; shift) / (8 * sizeof(uintptr_t)); for (i = i + 1; i &lt; map; i++) &#123; bitmap[i] = 0; &#125; page-&gt;slab = shift; page-&gt;next = &amp;slots[slot]; page-&gt;prev = (uintptr_t) &amp;slots[slot] | NGX_SLAB_SMALL; slots[slot].next = page; pool-&gt;stats[slot].total += (ngx_pagesize &gt;&gt; shift) - n; p = ngx_slab_page_addr(pool, page) + (n &lt;&lt; shift); pool-&gt;stats[slot].used++; goto done; &#125; else if (shift == ngx_slab_exact_shift) &#123; page-&gt;slab = 1; page-&gt;next = &amp;slots[slot]; page-&gt;prev = (uintptr_t) &amp;slots[slot] | NGX_SLAB_EXACT; slots[slot].next = page; pool-&gt;stats[slot].total += 8 * sizeof(uintptr_t); p = ngx_slab_page_addr(pool, page); pool-&gt;stats[slot].used++; goto done; &#125; else &#123; /* shift &gt; ngx_slab_exact_shift */ page-&gt;slab = ((uintptr_t) 1 &lt;&lt; NGX_SLAB_MAP_SHIFT) | shift; page-&gt;next = &amp;slots[slot]; page-&gt;prev = (uintptr_t) &amp;slots[slot] | NGX_SLAB_BIG; slots[slot].next = page; pool-&gt;stats[slot].total += ngx_pagesize &gt;&gt; shift; p = ngx_slab_page_addr(pool, page); pool-&gt;stats[slot].used++; goto done; &#125; &#125; p = 0; pool-&gt;stats[slot].fails++;done: ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;log, 0, \"slab alloc: %p\", (void *) p); return (void *) p;&#125;/* 由于是共享内存，所以在进程间需要用锁来保持同步 */void *ngx_slab_calloc(ngx_slab_pool_t *pool, size_t size)&#123; void *p; ngx_shmtx_lock(&amp;pool-&gt;mutex); p = ngx_slab_calloc_locked(pool, size); ngx_shmtx_unlock(&amp;pool-&gt;mutex); return p;&#125;void *ngx_slab_calloc_locked(ngx_slab_pool_t *pool, size_t size)&#123; void *p; p = ngx_slab_alloc_locked(pool, size); if (p) &#123; ngx_memzero(p, size); &#125; return p;&#125;static ngx_slab_page_t *ngx_slab_alloc_pages(ngx_slab_pool_t *pool, ngx_uint_t pages)&#123; ngx_slab_page_t *page, *p; //初始化的时候pool-&gt;free.next默认指向第一个pool-&gt;pages //从pool-&gt;free.next开始，每次取(slab page) page = page-&gt;next for (page = pool-&gt;free.next; page != &amp;pool-&gt;free; page = page-&gt;next) &#123; if (page-&gt;slab &gt;= pages) &#123; if (page-&gt;slab &gt; pages) &#123; page[page-&gt;slab - 1].prev = (uintptr_t) &amp;page[pages]; page[pages].slab = page-&gt;slab - pages; page[pages].next = page-&gt;next; page[pages].prev = page-&gt;prev; p = (ngx_slab_page_t *) page-&gt;prev; p-&gt;next = &amp;page[pages]; page-&gt;next-&gt;prev = (uintptr_t) &amp;page[pages]; &#125; else &#123;//page页不够用了，则free的next和prev都指向自己 p = (ngx_slab_page_t *) page-&gt;prev; p-&gt;next = page-&gt;next; page-&gt;next-&gt;prev = page-&gt;prev; &#125; //NGX_SLAB_PAGE_START标记page是分配的pages个页的第一个页，并在第一个页page中记录出其后连续的pages个页是一起分配的 page-&gt;slab = pages | NGX_SLAB_PAGE_START; page-&gt;next = NULL; page-&gt;prev = NGX_SLAB_PAGE; pool-&gt;pfree -= pages; //pages为1。则直接返回该page if (--pages == 0) &#123; return page; &#125; for (p = page + 1; pages; pages--) &#123; //如果分配的页数pages&gt;1，更新后面page slab的slab成员为NGX_SLAB_PAGE_BUSY p-&gt;slab = NGX_SLAB_PAGE_BUSY; p-&gt;next = NULL; p-&gt;prev = NGX_SLAB_PAGE; p++; &#125; return page; &#125; &#125; if (pool-&gt;log_nomem) &#123; ngx_slab_error(pool, NGX_LOG_CRIT, \"ngx_slab_alloc() failed: no memory\"); &#125; return NULL;&#125;最后来看看释放内存相关函数ngx_slab_free、ngx_slab_free_locked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228voidngx_slab_free(ngx_slab_pool_t *pool, void *p)&#123; ngx_shmtx_lock(&amp;pool-&gt;mutex); ngx_slab_free_locked(pool, p); ngx_shmtx_unlock(&amp;pool-&gt;mutex);&#125;voidngx_slab_free_locked(ngx_slab_pool_t *pool, void *p)&#123; size_t size; uintptr_t slab, m, *bitmap; ngx_uint_t i, n, type, slot, shift, map; ngx_slab_page_t *slots, *page; ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;log, 0, \"slab free: %p\", p); if ((u_char *) p &lt; pool-&gt;start || (u_char *) p &gt; pool-&gt;end) &#123; ngx_slab_error(pool, NGX_LOG_ALERT, \"ngx_slab_free(): outside of pool\"); goto fail; &#125; //根据p找到需要释放的m_page元素 n = ((u_char *) p - pool-&gt;start) &gt;&gt; ngx_pagesize_shift; page = &amp;pool-&gt;pages[n]; //如果分配的时候一次性分配多个page，则第一个page的slab指定本次一次性分配了多少个页page slab = page-&gt;slab; type = ngx_slab_page_type(page); switch (type) &#123; case NGX_SLAB_SMALL: shift = slab &amp; NGX_SLAB_SHIFT_MASK; size = (size_t) 1 &lt;&lt; shift; if ((uintptr_t) p &amp; (size - 1)) &#123; goto wrong_chunk; &#125; n = ((uintptr_t) p &amp; (ngx_pagesize - 1)) &gt;&gt; shift; m = (uintptr_t) 1 &lt;&lt; (n % (8 * sizeof(uintptr_t))); n /= 8 * sizeof(uintptr_t); bitmap = (uintptr_t *) ((uintptr_t) p &amp; ~((uintptr_t) ngx_pagesize - 1)); if (bitmap[n] &amp; m) &#123; slot = shift - pool-&gt;min_shift; if (page-&gt;next == NULL) &#123; slots = ngx_slab_slots(pool); page-&gt;next = slots[slot].next; slots[slot].next = page; page-&gt;prev = (uintptr_t) &amp;slots[slot] | NGX_SLAB_SMALL; page-&gt;next-&gt;prev = (uintptr_t) page | NGX_SLAB_SMALL; &#125; bitmap[n] &amp;= ~m; n = (ngx_pagesize &gt;&gt; shift) / ((1 &lt;&lt; shift) * 8); if (n == 0) &#123; n = 1; &#125; i = n / (8 * sizeof(uintptr_t)); m = ((uintptr_t) 1 &lt;&lt; (n % (8 * sizeof(uintptr_t)))) - 1; if (bitmap[i] &amp; ~m) &#123; goto done; &#125; map = (ngx_pagesize &gt;&gt; shift) / (8 * sizeof(uintptr_t)); for (i = i + 1; i &lt; map; i++) &#123; if (bitmap[i]) &#123; goto done; &#125; &#125; ngx_slab_free_pages(pool, page, 1); pool-&gt;stats[slot].total -= (ngx_pagesize &gt;&gt; shift) - n; goto done; &#125; goto chunk_already_free; case NGX_SLAB_EXACT: m = (uintptr_t) 1 &lt;&lt; (((uintptr_t) p &amp; (ngx_pagesize - 1)) &gt;&gt; ngx_slab_exact_shift); size = ngx_slab_exact_size; if ((uintptr_t) p &amp; (size - 1)) &#123; goto wrong_chunk; &#125; //slab(位图)中对应的位为1 if (slab &amp; m) &#123; slot = ngx_slab_exact_shift - pool-&gt;min_shift; if (slab == NGX_SLAB_BUSY) &#123; slots = ngx_slab_slots(pool); page-&gt;next = slots[slot].next; slots[slot].next = page; page-&gt;prev = (uintptr_t) &amp;slots[slot] | NGX_SLAB_EXACT; page-&gt;next-&gt;prev = (uintptr_t) page | NGX_SLAB_EXACT; &#125; page-&gt;slab &amp;= ~m; if (page-&gt;slab) &#123; goto done; &#125; ngx_slab_free_pages(pool, page, 1); pool-&gt;stats[slot].total -= 8 * sizeof(uintptr_t); goto done; &#125; goto chunk_already_free; case NGX_SLAB_BIG: //slab的高16位是slot块的位图,低16位用于存储slot块大小的偏移 shift = slab &amp; NGX_SLAB_SHIFT_MASK; size = (size_t) 1 &lt;&lt; shift; if ((uintptr_t) p &amp; (size - 1)) &#123; goto wrong_chunk; &#125; m = (uintptr_t) 1 &lt;&lt; ((((uintptr_t) p &amp; (ngx_pagesize - 1)) &gt;&gt; shift) + NGX_SLAB_MAP_SHIFT); //该slab块确实正在被使用 if (slab &amp; m) &#123; slot = shift - pool-&gt;min_shift; if (page-&gt;next == NULL) &#123; slots = ngx_slab_slots(pool); page-&gt;next = slots[slot].next; slots[slot].next = page; page-&gt;prev = (uintptr_t) &amp;slots[slot] | NGX_SLAB_BIG; page-&gt;next-&gt;prev = (uintptr_t) page | NGX_SLAB_BIG; &#125; page-&gt;slab &amp;= ~m; if (page-&gt;slab &amp; NGX_SLAB_MAP_MASK) &#123; goto done; &#125; //如果page页中所有slab块都不在使用就将该页面链入free中 ngx_slab_free_pages(pool, page, 1); pool-&gt;stats[slot].total -= ngx_pagesize &gt;&gt; shift; goto done; &#125; goto chunk_already_free; //用户归还整个页面 case NGX_SLAB_PAGE: if ((uintptr_t) p &amp; (ngx_pagesize - 1)) &#123; goto wrong_chunk; &#125; if (!(slab &amp; NGX_SLAB_PAGE_START)) &#123; ngx_slab_error(pool, NGX_LOG_ALERT, \"ngx_slab_free(): page is already free\"); goto fail; &#125; if (slab == NGX_SLAB_PAGE_BUSY) &#123; ngx_slab_error(pool, NGX_LOG_ALERT, \"ngx_slab_free(): pointer to wrong page\"); goto fail; &#125; //计算归还page的个数 size = slab &amp; ~NGX_SLAB_PAGE_START; //归还页面 ngx_slab_free_pages(pool, page, size); ngx_slab_junk(p, size &lt;&lt; ngx_pagesize_shift); return; &#125; /* not reached */ return;done: pool-&gt;stats[slot].used--; ngx_slab_junk(p, size); return;wrong_chunk: ngx_slab_error(pool, NGX_LOG_ALERT, \"ngx_slab_free(): pointer to wrong chunk\"); goto fail;chunk_already_free: ngx_slab_error(pool, NGX_LOG_ALERT, \"ngx_slab_free(): chunk is already free\");fail: return;&#125;3 总结以上就是slab相关函数实现，nginx的slab共享内存借鉴了linux内核的内存管理的实现。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx限流模块详解","slug":"Nginx限流模块详解","date":"2020-04-15T14:54:37.000Z","updated":"2021-06-05T14:20:15.119Z","comments":true,"path":"2020/04/15/Nginx限流模块详解/","link":"","permalink":"https://weeweetan.github.io/2020/04/15/Nginx限流模块详解/","excerpt":"","text":"1.相关指令123Syntax: limit_conn_zone key zone=name:size;Default: —Context: http此指令设置限流所需共享内存的名称和size，key指定限流的标志，比如$binary_remote_addr。12345Syntax: limit_conn zone number;Default: —Context: http, server, location此指令指定共享内存名以及限制多少连接，比如limit_conn_zone指令key设置为$binary_remote_addr，zone设置为limit_zone，那么来自于$binary_remote_addr的连接超过number，nginx直接给客户端响应503。2.源码解析2.1 配置解析函数首先来看下limit_conn_zone指令的解析函数ngx_http_limit_conn_zone，这个函数的功能主要是解析共享内存的name和size，然后使用这两个值作为参数调用ngx_shared_memory_add函数，将共享内存添加到nginx共享内存管理模块中，设置共享内存的data以及初始化函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100static char *ngx_http_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; u_char *p; ssize_t size; ngx_str_t *value, name, s; ngx_uint_t i; ngx_shm_zone_t *shm_zone; ngx_http_limit_conn_ctx_t *ctx; ngx_http_compile_complex_value_t ccv; value = cf-&gt;args-&gt;elts; ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_limit_conn_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = &amp;ctx-&gt;key; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; size = 0; name.len = 0; for (i = 2; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; if (ngx_strncmp(value[i].data, \"zone=\", 5) == 0) &#123; name.data = value[i].data + 5; p = (u_char *) ngx_strchr(name.data, ':'); if (p == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid zone size \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; name.len = p - name.data; s.data = p + 1; s.len = value[i].data + value[i].len - s.data; size = ngx_parse_size(&amp;s); if (size == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid zone size \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; if (size &lt; (ssize_t) (8 * ngx_pagesize)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"zone \\\"%V\\\" is too small\", &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; if (name.len == 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"\\\"%V\\\" must have \\\"zone\\\" parameter\", &amp;cmd-&gt;name); return NGX_CONF_ERROR; &#125; shm_zone = ngx_shared_memory_add(cf, &amp;name, size, &amp;ngx_http_limit_conn_module); if (shm_zone == NULL) &#123; return NGX_CONF_ERROR; &#125; if (shm_zone-&gt;data) &#123; ctx = shm_zone-&gt;data; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"%V \\\"%V\\\" is already bound to key \\\"%V\\\"\", &amp;cmd-&gt;name, &amp;name, &amp;ctx-&gt;key.value); return NGX_CONF_ERROR; &#125; shm_zone-&gt;init = ngx_http_limit_conn_init_zone; shm_zone-&gt;data = ctx; return NGX_CONF_OK;&#125;接下来看下limit_conn指令解析函数ngx_http_limit_conn，这个函数主要是保存配置的共享内存名以及限制连接的个数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static char *ngx_http_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_shm_zone_t *shm_zone; ngx_http_limit_conn_conf_t *lccf = conf; ngx_http_limit_conn_limit_t *limit, *limits; ngx_str_t *value; ngx_int_t n; ngx_uint_t i; value = cf-&gt;args-&gt;elts; shm_zone = ngx_shared_memory_add(cf, &amp;value[1], 0, &amp;ngx_http_limit_conn_module); if (shm_zone == NULL) &#123; return NGX_CONF_ERROR; &#125; limits = lccf-&gt;limits.elts; if (limits == NULL) &#123; if (ngx_array_init(&amp;lccf-&gt;limits, cf-&gt;pool, 1, sizeof(ngx_http_limit_conn_limit_t)) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; for (i = 0; i &lt; lccf-&gt;limits.nelts; i++) &#123; if (shm_zone == limits[i].shm_zone) &#123; return \"is duplicate\"; &#125; &#125; // 解析配置种被限制的连接数 n = ngx_atoi(value[2].data, value[2].len); if (n &lt;= 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid number of connections \\\"%V\\\"\", &amp;value[2]); return NGX_CONF_ERROR; &#125; if (n &gt; 65535) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"connection limit must be less 65536\"); return NGX_CONF_ERROR; &#125; limit = ngx_array_push(&amp;lccf-&gt;limits); if (limit == NULL) &#123; return NGX_CONF_ERROR; &#125; limit-&gt;conn = n; limit-&gt;shm_zone = shm_zone; return NGX_CONF_OK;&#125;接下来就来看下nginx是如何实现限流的，这个功能由ngx_http_limit_conn_handler实现，主要功能就是统计各个进程与key对应的连接数，超过则返回503，在统计各个进程数据的时候使用了共享内存。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117static ngx_int_tngx_http_limit_conn_handler(ngx_http_request_t *r)&#123; size_t n; uint32_t hash; ngx_str_t key; ngx_uint_t i; ngx_slab_pool_t *shpool; ngx_rbtree_node_t *node; ngx_pool_cleanup_t *cln; ngx_http_limit_conn_ctx_t *ctx; ngx_http_limit_conn_node_t *lc; ngx_http_limit_conn_conf_t *lccf; ngx_http_limit_conn_limit_t *limits; ngx_http_limit_conn_cleanup_t *lccln; if (r-&gt;main-&gt;limit_conn_set) &#123; return NGX_DECLINED; &#125; lccf = ngx_http_get_module_loc_conf(r, ngx_http_limit_conn_module); limits = lccf-&gt;limits.elts; for (i = 0; i &lt; lccf-&gt;limits.nelts; i++) &#123; ctx = limits[i].shm_zone-&gt;data; //获取limit_conn_zone指令后key的值 if (ngx_http_complex_value(r, &amp;ctx-&gt;key, &amp;key) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; if (key.len == 0) &#123; continue; &#125; if (key.len &gt; 255) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"the value of the \\\"%V\\\" key \" \"is more than 255 bytes: \\\"%V\\\"\", &amp;ctx-&gt;key.value, &amp;key); continue; &#125; r-&gt;main-&gt;limit_conn_set = 1; //对key进行crc计算，用于在红黑树中查找结点 hash = ngx_crc32_short(key.data, key.len); shpool = (ngx_slab_pool_t *) limits[i].shm_zone-&gt;shm.addr; ngx_shmtx_lock(&amp;shpool-&gt;mutex); // 查找符合要求的结点 node = ngx_http_limit_conn_lookup(ctx-&gt;rbtree, &amp;key, hash); // 没有找到对应的结点，将此次请求插入到红黑树中 if (node == NULL) &#123; //计算结点所需内存 n = offsetof(ngx_rbtree_node_t, color) + offsetof(ngx_http_limit_conn_node_t, data) + key.len; // 申请结点内存 node = ngx_slab_alloc_locked(shpool, n); if (node == NULL) &#123; ngx_shmtx_unlock(&amp;shpool-&gt;mutex); ngx_http_limit_conn_cleanup_all(r-&gt;pool); return lccf-&gt;status_code; &#125; lc = (ngx_http_limit_conn_node_t *) &amp;node-&gt;color; // 赋值key，用于下次请求到来查询 node-&gt;key = hash; lc-&gt;len = (u_char) key.len; lc-&gt;conn = 1; ngx_memcpy(lc-&gt;data, key.data, key.len); ngx_rbtree_insert(ctx-&gt;rbtree, node); &#125; else &#123; lc = (ngx_http_limit_conn_node_t *) &amp;node-&gt;color; // 判断key标记的connections是否超过配置，如果超过则返回错误码 if ((ngx_uint_t) lc-&gt;conn &gt;= limits[i].conn) &#123; ngx_shmtx_unlock(&amp;shpool-&gt;mutex); ngx_log_error(lccf-&gt;log_level, r-&gt;connection-&gt;log, 0, \"limiting connections by zone \\\"%V\\\"\", &amp;limits[i].shm_zone-&gt;shm.name); ngx_http_limit_conn_cleanup_all(r-&gt;pool); return lccf-&gt;status_code; &#125; //连接数量+1 lc-&gt;conn++; &#125; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"limit conn: %08Xi %d\", node-&gt;key, lc-&gt;conn); ngx_shmtx_unlock(&amp;shpool-&gt;mutex); //注册内存池清理函数 cln = ngx_pool_cleanup_add(r-&gt;pool, sizeof(ngx_http_limit_conn_cleanup_t)); if (cln == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; // 绑定内存清理函数 cln-&gt;handler = ngx_http_limit_conn_cleanup; lccln = cln-&gt;data; lccln-&gt;shm_zone = limits[i].shm_zone; lccln-&gt;node = node; &#125; return NGX_DECLINED;&#125;结点插入函数，限流模块是将每个连接都存进一颗红黑树中，nginx提供一个默认的插入函数，限流模块自己实现了一个插入函数。3. 总结以上就是nginx限流模块的基本实现，其他限制请求数的模块类似。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"GDB调试技巧","slug":"GDB调试技巧","date":"2020-02-26T11:24:12.000Z","updated":"2023-05-18T15:38:50.610Z","comments":true,"path":"2020/02/26/GDB调试技巧/","link":"","permalink":"https://weeweetan.github.io/2020/02/26/GDB调试技巧/","excerpt":"","text":"1 预备工作1.1 添加编译参数1gcc -g只有在编译的时候添加了-g这个参数，才能够使用gdb进行调试。可以使用-O0，避免某些变量被优化2 调试过程2.1 调试新进程gdb 程序名称2.2 调试已有进程使用命令 gdb attach pid，跟踪现有进程，也可使用gdb -p pid, 输入bt，直接查看当前进程运行到哪里2.3 常用命令单步调式 s，全称step，意味着每个函数都会进入单步调试 n, 全称next，不会进入函数打印变量 p, 全称print，可以打印各种变量的值，打印二进制 p/t xxx继续进程 c, 全称continue，设置好断点后，继续运行，直到发生断点设置断点 b, 全称breakpoint，可设置函数断点也可以设置代码行号断点打印堆栈 bt, 全称backtrace, 打印当前函数调用栈退出当前函数栈 finish, 当使用s命令进入到某个函数后，可以使用finish指令退出当前函数设置命令行参数 set args, 若函数需要argv，args，可以使用此命令设置跳转到指定调用栈 f (0…N), 后面跟随栈层，伴随bt命令使用，首先使用bt参看当前函数调用栈，然后使用f命令查看对应栈的信息显示隐藏字符串set print elements 0，字符串过长的情况下使用p打印会以…结束，无法完整显示，使用此命令可以显示完全条件断点 b point if condition，条件满足才会触发中断监控某个值 watch，值改变就会触发中断，也可监控某个内存地址，watch *(内存地址)，适用于跟踪一些全局的结构体指针。跳转到指定行 until 行号，对于跳出循环很有用格式化打印printf fmt, var，类似于C语言的库函数 printf “%s”, str打印错误号: p errno设置变量set $awhile循环以end结束layout src, 加载源码info local, 打印当前帧所有局部变量p ‘a.c’::xx,打印其他文件的全局变量p *a@123, 打印以a开始的123字节，需要配合10使用info args，打印函数入参r，运行程序3 总结以上就是gdb调试常用命令，大多数场景都能应用。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"https://weeweetan.github.io/tags/GDB/"}]},{"title":"Nginx缓存清理","slug":"Nginx缓存清理","date":"2019-10-27T13:56:19.000Z","updated":"2020-11-13T11:47:58.998Z","comments":true,"path":"2019/10/27/Nginx缓存清理/","link":"","permalink":"https://weeweetan.github.io/2019/10/27/Nginx缓存清理/","excerpt":"","text":"1、相关配置123proxy_cache_path /dev/sda1/data inactive=60m max_size=10G;proxy_cache_path指令的inactive参数和max_size参数用来维护缓存队列大小2、源码解析首先来看看配置解析函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323char *ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; char *confp = conf; off_t max_size; u_char *last, *p; time_t inactive; ssize_t size; ngx_str_t s, name, *value; ngx_int_t loader_files, manager_files; ngx_msec_t loader_sleep, manager_sleep, loader_threshold, manager_threshold; ngx_uint_t i, n, use_temp_path; ngx_array_t *caches; ngx_http_file_cache_t *cache, **ce; cache = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_file_cache_t)); if (cache == NULL) &#123; return NGX_CONF_ERROR; &#125; cache-&gt;path = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_path_t)); if (cache-&gt;path == NULL) &#123; return NGX_CONF_ERROR; &#125; use_temp_path = 1; inactive = 600; loader_files = 100; loader_sleep = 50; loader_threshold = 200; manager_files = 100; manager_sleep = 50; manager_threshold = 200; name.len = 0; size = 0; max_size = NGX_MAX_OFF_T_VALUE; value = cf-&gt;args-&gt;elts; //指定路径名称 cache-&gt;path-&gt;name = value[1]; if (cache-&gt;path-&gt;name.data[cache-&gt;path-&gt;name.len - 1] == &apos;/&apos;) &#123; cache-&gt;path-&gt;name.len--; &#125; if (ngx_conf_full_name(cf-&gt;cycle, &amp;cache-&gt;path-&gt;name, 0) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; //解析proxy_cache_path指令后的参数 for (i = 2; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; //解析目录层级参数 if (ngx_strncmp(value[i].data, &quot;levels=&quot;, 7) == 0) &#123; p = value[i].data + 7; last = value[i].data + value[i].len; for (n = 0; n &lt; NGX_MAX_PATH_LEVEL &amp;&amp; p &lt; last; n++) &#123; if (*p &gt; &apos;0&apos; &amp;&amp; *p &lt; &apos;3&apos;) &#123; cache-&gt;path-&gt;level[n] = *p++ - &apos;0&apos;; cache-&gt;path-&gt;len += cache-&gt;path-&gt;level[n] + 1; if (p == last) &#123; break; &#125; if (*p++ == &apos;:&apos; &amp;&amp; n &lt; NGX_MAX_PATH_LEVEL - 1 &amp;&amp; p &lt; last) &#123; continue; &#125; goto invalid_levels; &#125; goto invalid_levels; &#125; if (cache-&gt;path-&gt;len &lt; 10 + NGX_MAX_PATH_LEVEL) &#123; continue; &#125; invalid_levels: ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid \\&quot;levels\\&quot; \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; if (ngx_strncmp(value[i].data, &quot;use_temp_path=&quot;, 14) == 0) &#123; if (ngx_strcmp(&amp;value[i].data[14], &quot;on&quot;) == 0) &#123; use_temp_path = 1; &#125; else if (ngx_strcmp(&amp;value[i].data[14], &quot;off&quot;) == 0) &#123; use_temp_path = 0; &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid use_temp_path value \\&quot;%V\\&quot;, &quot; &quot;it must be \\&quot;on\\&quot; or \\&quot;off\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; //解析共享内存名称参数 if (ngx_strncmp(value[i].data, &quot;keys_zone=&quot;, 10) == 0) &#123; name.data = value[i].data + 10; p = (u_char *) ngx_strchr(name.data, &apos;:&apos;); if (p == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid keys zone size \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; name.len = p - name.data; s.data = p + 1; s.len = value[i].data + value[i].len - s.data; size = ngx_parse_size(&amp;s); if (size == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid keys zone size \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; if (size &lt; (ssize_t) (2 * ngx_pagesize)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;keys zone \\&quot;%V\\&quot; is too small&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; //解析缓存分片活跃时间 if (ngx_strncmp(value[i].data, &quot;inactive=&quot;, 9) == 0) &#123; s.len = value[i].len - 9; s.data = value[i].data + 9; inactive = ngx_parse_time(&amp;s, 1); if (inactive == (time_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid inactive value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; //解析配置的目录最大能保存多少缓存分片 if (ngx_strncmp(value[i].data, &quot;max_size=&quot;, 9) == 0) &#123; s.len = value[i].len - 9; s.data = value[i].data + 9; max_size = ngx_parse_offset(&amp;s); if (max_size &lt; 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid max_size value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; //解析缓存加载进程暂停阈值 if (ngx_strncmp(value[i].data, &quot;loader_files=&quot;, 13) == 0) &#123; loader_files = ngx_atoi(value[i].data + 13, value[i].len - 13); if (loader_files == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid loader_files value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; //解析缓存加载进程暂停时间 if (ngx_strncmp(value[i].data, &quot;loader_sleep=&quot;, 13) == 0) &#123; s.len = value[i].len - 13; s.data = value[i].data + 13; loader_sleep = ngx_parse_time(&amp;s, 0); if (loader_sleep == (ngx_msec_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid loader_sleep value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;loader_threshold=&quot;, 17) == 0) &#123; s.len = value[i].len - 17; s.data = value[i].data + 17; loader_threshold = ngx_parse_time(&amp;s, 0); if (loader_threshold == (ngx_msec_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid loader_threshold value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; //解析缓存管理进程暂停阈值 if (ngx_strncmp(value[i].data, &quot;manager_files=&quot;, 14) == 0) &#123; manager_files = ngx_atoi(value[i].data + 14, value[i].len - 14); if (manager_files == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid manager_files value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; //manager进程达到阈值后的睡眠时间 if (ngx_strncmp(value[i].data, &quot;manager_sleep=&quot;, 14) == 0) &#123; s.len = value[i].len - 14; s.data = value[i].data + 14; manager_sleep = ngx_parse_time(&amp;s, 0); if (manager_sleep == (ngx_msec_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid manager_sleep value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;manager_threshold=&quot;, 18) == 0) &#123; s.len = value[i].len - 18; s.data = value[i].data + 18; manager_threshold = ngx_parse_time(&amp;s, 0); if (manager_threshold == (ngx_msec_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid manager_threshold value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid parameter \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; if (name.len == 0 || size == 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;\\&quot;%V\\&quot; must have \\&quot;keys_zone\\&quot; parameter&quot;, &amp;cmd-&gt;name); return NGX_CONF_ERROR; &#125; //设置loader跟manager进程的回调函数 cache-&gt;path-&gt;manager = ngx_http_file_cache_manager; cache-&gt;path-&gt;loader = ngx_http_file_cache_loader; cache-&gt;path-&gt;data = cache; cache-&gt;path-&gt;conf_file = cf-&gt;conf_file-&gt;file.name.data; cache-&gt;path-&gt;line = cf-&gt;conf_file-&gt;line; cache-&gt;loader_files = loader_files; cache-&gt;loader_sleep = loader_sleep; cache-&gt;loader_threshold = loader_threshold; cache-&gt;manager_files = manager_files; cache-&gt;manager_sleep = manager_sleep; cache-&gt;manager_threshold = manager_threshold; //将缓存路径添加到全局管理 if (ngx_add_path(cf, &amp;cache-&gt;path) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; //添加共享内存名称 cache-&gt;shm_zone = ngx_shared_memory_add(cf, &amp;name, size, cmd-&gt;post); if (cache-&gt;shm_zone == NULL) &#123; return NGX_CONF_ERROR; &#125; if (cache-&gt;shm_zone-&gt;data) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;duplicate zone \\&quot;%V\\&quot;&quot;, &amp;name); return NGX_CONF_ERROR; &#125; //设置共享内存初始化函数指针 cache-&gt;shm_zone-&gt;init = ngx_http_file_cache_init; cache-&gt;shm_zone-&gt;data = cache; cache-&gt;use_temp_path = use_temp_path; cache-&gt;inactive = inactive; cache-&gt;max_size = max_size; caches = (ngx_array_t *) (confp + cmd-&gt;offset); //保存cache结构体 ce = ngx_array_push(caches); if (ce == NULL) &#123; return NGX_CONF_ERROR; &#125; *ce = cache; return NGX_CONF_OK;&#125;上述代码中我们只关注inactive，max_size参数解析、cache-&gt;path相关成员赋值以及loader和manager相关的赋值代码，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546cache-&gt;path-&gt;manager = ngx_http_file_cache_manager;cache-&gt;path-&gt;loader = ngx_http_file_cache_loader;cache-&gt;path-&gt;data = cache;cache-&gt;path-&gt;conf_file = cf-&gt;conf_file-&gt;file.name.data;cache-&gt;path-&gt;line = cf-&gt;conf_file-&gt;line;cache-&gt;loader_files = loader_files;cache-&gt;loader_sleep = loader_sleep;cache-&gt;loader_threshold = loader_threshold;cache-&gt;manager_files = manager_files;cache-&gt;manager_sleep = manager_sleep;cache-&gt;manager_threshold = manager_threshold;if (ngx_add_path(cf, &amp;cache-&gt;path) != NGX_OK) &#123; return NGX_CONF_ERROR;&#125;//添加共享内存名称cache-&gt;shm_zone = ngx_shared_memory_add(cf, &amp;name, size, cmd-&gt;post);if (cache-&gt;shm_zone == NULL) &#123; return NGX_CONF_ERROR;&#125;if (cache-&gt;shm_zone-&gt;data) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;duplicate zone \\&quot;%V\\&quot;&quot;, &amp;name); return NGX_CONF_ERROR;&#125;//设置共享内存初始化函数cache-&gt;shm_zone-&gt;init = ngx_http_file_cache_init;cache-&gt;shm_zone-&gt;data = cache;cache-&gt;use_temp_path = use_temp_path;cache-&gt;inactive = inactive;cache-&gt;max_size = max_size;//保存cachecaches = (ngx_array_t *) (confp + cmd-&gt;offset);ce = ngx_array_push(caches);if (ce == NULL) &#123; return NGX_CONF_ERROR;&#125;*ce = cache;path结构体初始化完成之后，ngx_add_path函数将配置的路径添加到nginx全局路径管理器后，配置解析完成之后会统一管理，接下来我们来看看几个跟目录相关的回调函数。12345ngx_http_file_cache_manager//加载本地已有缓存函数ngx_http_file_cache_loader首先来看看ngx_http_file_cache_manager函数的具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static ngx_msec_tngx_http_file_cache_manager(void *data)&#123; ngx_http_file_cache_t *cache = data; off_t size; time_t wait; ngx_msec_t elapsed, next; ngx_uint_t count, watermark; cache-&gt;last = ngx_current_msec; cache-&gt;files = 0; //查找过期缓存结点 next = (ngx_msec_t) ngx_http_file_cache_expire(cache) * 1000; if (next == 0) &#123; next = cache-&gt;manager_sleep; goto done; &#125; for ( ;; ) &#123; ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); size = cache-&gt;sh-&gt;size; count = cache-&gt;sh-&gt;count; watermark = cache-&gt;sh-&gt;watermark; ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); ngx_log_debug3(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;log, 0, &quot;http file cache size: %O c:%ui w:%i&quot;, size, count, (ngx_int_t) watermark); if (size &lt; cache-&gt;max_size &amp;&amp; count &lt; watermark) &#123; break; &#125; //处理缓存目录已经满了的情况 wait = ngx_http_file_cache_forced_expire(cache); if (wait &gt; 0) &#123; next = (ngx_msec_t) wait * 1000; break; &#125; if (ngx_quit || ngx_terminate) &#123; break; &#125; if (++cache-&gt;files &gt;= cache-&gt;manager_files) &#123; next = cache-&gt;manager_sleep; break; &#125; ngx_time_update(); elapsed = ngx_abs((ngx_msec_int_t) (ngx_current_msec - cache-&gt;last)); if (elapsed &gt;= cache-&gt;manager_threshold) &#123; next = cache-&gt;manager_sleep; break; &#125; &#125;done: elapsed = ngx_abs((ngx_msec_int_t) (ngx_current_msec - cache-&gt;last)); ngx_log_debug3(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;log, 0, &quot;http file cache manager: %ui e:%M n:%M&quot;, cache-&gt;files, elapsed, next); return next;&#125;这个函数主要的功能就是遍历缓存结点数，找出过期结点，并删除，接下来看看ngx_http_file_cache_loader函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 static voidngx_http_file_cache_loader(void *data)&#123; ngx_http_file_cache_t *cache = data; ngx_tree_ctx_t tree; if (!cache-&gt;sh-&gt;cold || cache-&gt;sh-&gt;loading) &#123; return; &#125; if (!ngx_atomic_cmp_set(&amp;cache-&gt;sh-&gt;loading, 0, ngx_pid)) &#123; return; &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;log, 0, &quot;http file cache loader&quot;); //设置遍历目录时所需的函数指针 tree.init_handler = NULL; //遍历目录时，遇到文件处理函数 tree.file_handler = ngx_http_file_cache_manage_file; //遍历目录时，遇到文件处理函数 tree.pre_tree_handler = ngx_http_file_cache_manage_directory; tree.post_tree_handler = ngx_http_file_cache_noop; //缓存目录中有不符合规则的缓存文件，会删除文件 tree.spec_handler = ngx_http_file_cache_delete_file; tree.data = cache; tree.alloc = 0; tree.log = ngx_cycle-&gt;log; cache-&gt;last = ngx_current_msec; cache-&gt;files = 0; //遍历配置路径下所有文件 if (ngx_walk_tree(&amp;tree, &amp;cache-&gt;path-&gt;name) == NGX_ABORT) &#123; cache-&gt;sh-&gt;loading = 0; return; &#125; cache-&gt;sh-&gt;cold = 0; cache-&gt;sh-&gt;loading = 0; ngx_log_error(NGX_LOG_NOTICE, ngx_cycle-&gt;log, 0, &quot;http file cache: %V %.3fM, bsize: %uz&quot;, &amp;cache-&gt;path-&gt;name, ((double) cache-&gt;sh-&gt;size * cache-&gt;bsize) / (1024 * 1024), cache-&gt;bsize);&#125;&gt;6. 此函数功能就是绑定回调函数，然后遍历配置的目录，根据目录中不同的对象调用不同的回调函数 3、总结以上就是nginx缓存管理的主要代码，总的来说就是在解析配置时设置ngx_path_t结构体的回调函数，cache_manager进程定时启动扫描LRU队列，删除过期结点","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的return模块","slug":"Nginx的return模块","date":"2019-10-12T06:05:34.000Z","updated":"2021-05-29T14:39:16.013Z","comments":true,"path":"2019/10/12/Nginx的return模块/","link":"","permalink":"https://weeweetan.github.io/2019/10/12/Nginx的return模块/","excerpt":"","text":"1 相关配置return模块配置指令如下：1return value;详细用法参考nginx官方文档2 源码解析2.1 首先看看指令解析函数，这个函数的主要功能就是把return指令后面的文本以nginx变量的形式保存，绑定此阶段的处理函数。12345678910111213141516171819202122232425262728293031static char *ngx_stream_return(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_stream_return_srv_conf_t *rscf = conf; ngx_str_t *value; ngx_stream_core_srv_conf_t *cscf; ngx_stream_compile_complex_value_t ccv; if (rscf-&gt;text.value.data) &#123; return \"is duplicate\"; &#125; value = cf-&gt;args-&gt;elts; ngx_memzero(&amp;ccv, sizeof(ngx_stream_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = &amp;rscf-&gt;text; if (ngx_stream_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; cscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_core_module); cscf-&gt;handler = ngx_stream_return_handler; return NGX_CONF_OK;&#125;2.2 在上一步设置好处理函数后，nginx运行到此阶段就会调用ngx_stream_return_handler函数，并给客户端响应1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static voidngx_stream_return_handler(ngx_stream_session_t *s)&#123; ngx_str_t text; ngx_buf_t *b; ngx_connection_t *c; ngx_stream_return_ctx_t *ctx; ngx_stream_return_srv_conf_t *rscf; c = s-&gt;connection; c-&gt;log-&gt;action = \"returning text\"; rscf = ngx_stream_get_module_srv_conf(s, ngx_stream_return_module); // 获取变量值 if (ngx_stream_complex_value(s, &amp;rscf-&gt;text, &amp;text) != NGX_OK) &#123; ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR); return; &#125; ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c-&gt;log, 0, \"stream return text: \\\"%V\\\"\", &amp;text); if (text.len == 0) &#123; ngx_stream_finalize_session(s, NGX_STREAM_OK); return; &#125; // 分配上下文内存 ctx = ngx_pcalloc(c-&gt;pool, sizeof(ngx_stream_return_ctx_t)); if (ctx == NULL) &#123; ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR); return; &#125; // 设置模块上下文 ngx_stream_set_ctx(s, ctx, ngx_stream_return_module); b = ngx_calloc_buf(c-&gt;pool); if (b == NULL) &#123; ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR); return; &#125; b-&gt;memory = 1; b-&gt;pos = text.data; b-&gt;last = text.data + text.len; b-&gt;last_buf = 1; ctx-&gt;out = ngx_alloc_chain_link(c-&gt;pool); if (ctx-&gt;out == NULL) &#123; ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR); return; &#125; // 挂载输出buf ctx-&gt;out-&gt;buf = b; ctx-&gt;out-&gt;next = NULL; // 设置写回调函数 c-&gt;write-&gt;handler = ngx_stream_return_write_handler; // 调用写回调函数 ngx_stream_return_write_handler(c-&gt;write);&#125;ngx_stream_return_handler函数首先解析出return指令后面的字符串值，然后为当前模块的ngx_stream_return_ctx_t申请内存，主要用来挂载发送数据的chain，再为发送数据的chain以及buf申请内存，设置写事件的handler，最后发送响应到客户端。3 总结return模块属于stream模块，在stream模块中处于第4阶段，所以需要绑定handler函数，将return指令后的变量或者纯文本响应给客户端。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的geo模块","slug":"Nginx的geo模块","date":"2019-10-12T01:26:55.000Z","updated":"2019-12-20T12:45:20.028Z","comments":true,"path":"2019/10/12/Nginx的geo模块/","link":"","permalink":"https://weeweetan.github.io/2019/10/12/Nginx的geo模块/","excerpt":"","text":"1、相关配置geo模块配置指令如下：12345geo $remote_addr $var &#123; &#125;详细用法参考nginx官方文档2、源码详解2.1 首先来看看geo指令配置解析函数，这个函数的主要功能就是解析geo指令之后的变量，然后再调用ngx_http_geo解析{}中的内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187static char *ngx_http_geo_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; char *rv; size_t len; ngx_str_t *value, name; ngx_uint_t i; ngx_conf_t save; ngx_pool_t *pool; ngx_array_t *a; ngx_http_variable_t *var; ngx_http_geo_ctx_t *geo; ngx_http_geo_conf_ctx_t ctx;#if (NGX_HAVE_INET6) static struct in6_addr zero;#endif value = cf-&gt;args-&gt;elts; geo = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_geo_ctx_t)); if (geo == NULL) &#123; return NGX_CONF_ERROR; &#125; name = value[1]; if (name.data[0] != '$') &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;name); return NGX_CONF_ERROR; &#125; name.len--; name.data++; if (cf-&gt;args-&gt;nelts == 3) &#123; geo-&gt;index = ngx_http_get_variable_index(cf, &amp;name); if (geo-&gt;index == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125; name = value[2]; if (name.data[0] != '$') &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;name); return NGX_CONF_ERROR; &#125; name.len--; name.data++; &#125; else &#123; geo-&gt;index = -1; &#125; var = ngx_http_add_variable(cf, &amp;name, NGX_HTTP_VAR_CHANGEABLE); if (var == NULL) &#123; return NGX_CONF_ERROR; &#125; pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf-&gt;log); if (pool == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;ctx, sizeof(ngx_http_geo_conf_ctx_t)); ctx.temp_pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf-&gt;log); if (ctx.temp_pool == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_rbtree_init(&amp;ctx.rbtree, &amp;ctx.sentinel, ngx_str_rbtree_insert_value); ctx.pool = cf-&gt;pool; ctx.data_size = sizeof(ngx_http_geo_header_t) + sizeof(ngx_http_variable_value_t) + 0x10000 * sizeof(ngx_http_geo_range_t *); ctx.allow_binary_include = 1; save = *cf; cf-&gt;pool = pool; cf-&gt;ctx = &amp;ctx; cf-&gt;handler = ngx_http_geo; cf-&gt;handler_conf = conf; rv = ngx_conf_parse(cf, NULL); *cf = save; geo-&gt;proxies = ctx.proxies; geo-&gt;proxy_recursive = ctx.proxy_recursive; if (ctx.ranges) &#123; if (ctx.high.low &amp;&amp; !ctx.binary_include) &#123; for (i = 0; i &lt; 0x10000; i++) &#123; a = (ngx_array_t *) ctx.high.low[i]; if (a == NULL || a-&gt;nelts == 0) &#123; continue; &#125; len = a-&gt;nelts * sizeof(ngx_http_geo_range_t); ctx.high.low[i] = ngx_palloc(cf-&gt;pool, len + sizeof(void *)); if (ctx.high.low[i] == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memcpy(ctx.high.low[i], a-&gt;elts, len); ctx.high.low[i][a-&gt;nelts].value = NULL; ctx.data_size += len + sizeof(void *); &#125; if (ctx.allow_binary_include &amp;&amp; !ctx.outside_entries &amp;&amp; ctx.entries &gt; 100000 &amp;&amp; ctx.includes == 1) &#123; ngx_http_geo_create_binary_base(&amp;ctx); &#125; &#125; if (ctx.high.default_value == NULL) &#123; ctx.high.default_value = &amp;ngx_http_variable_null_value; &#125; geo-&gt;u.high = ctx.high; var-&gt;get_handler = ngx_http_geo_range_variable; var-&gt;data = (uintptr_t) geo; ngx_destroy_pool(ctx.temp_pool); ngx_destroy_pool(pool); &#125; else &#123; if (ctx.tree == NULL) &#123; ctx.tree = ngx_radix_tree_create(cf-&gt;pool, -1); if (ctx.tree == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; geo-&gt;u.trees.tree = ctx.tree;#if (NGX_HAVE_INET6) if (ctx.tree6 == NULL) &#123; ctx.tree6 = ngx_radix_tree_create(cf-&gt;pool, -1); if (ctx.tree6 == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; geo-&gt;u.trees.tree6 = ctx.tree6;#endif var-&gt;get_handler = ngx_http_geo_cidr_variable; var-&gt;data = (uintptr_t) geo; ngx_destroy_pool(ctx.temp_pool); ngx_destroy_pool(pool); if (ngx_radix32tree_insert(ctx.tree, 0, 0, (uintptr_t) &amp;ngx_http_variable_null_value) == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125; /* NGX_BUSY is okay (default was set explicitly) */#if (NGX_HAVE_INET6) if (ngx_radix128tree_insert(ctx.tree6, zero.s6_addr, zero.s6_addr, (uintptr_t) &amp;ngx_http_variable_null_value) == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125;#endif &#125; return rv;&#125;2.2 ngx_http_geo解析{}中的内容，处理ranges等指令和IP地址段或者CIDR地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static char *ngx_http_geo(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)&#123; char *rv; ngx_str_t *value; ngx_cidr_t cidr; ngx_http_geo_conf_ctx_t *ctx; ctx = cf-&gt;ctx; value = cf-&gt;args-&gt;elts; if (cf-&gt;args-&gt;nelts == 1) &#123; if (ngx_strcmp(value[0].data, \"ranges\") == 0) &#123; if (ctx-&gt;tree#if (NGX_HAVE_INET6) || ctx-&gt;tree6#endif ) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"the \\\"ranges\\\" directive must be \" \"the first directive inside \\\"geo\\\" block\"); goto failed; &#125; ctx-&gt;ranges = 1; rv = NGX_CONF_OK; goto done; &#125; else if (ngx_strcmp(value[0].data, \"proxy_recursive\") == 0) &#123; ctx-&gt;proxy_recursive = 1; rv = NGX_CONF_OK; goto done; &#125; &#125; if (cf-&gt;args-&gt;nelts != 2) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid number of the geo parameters\"); goto failed; &#125; if (ngx_strcmp(value[0].data, \"include\") == 0) &#123; rv = ngx_http_geo_include(cf, ctx, &amp;value[1]); goto done; &#125; else if (ngx_strcmp(value[0].data, \"proxy\") == 0) &#123; if (ngx_http_geo_cidr_value(cf, &amp;value[1], &amp;cidr) != NGX_OK) &#123; goto failed; &#125; rv = ngx_http_geo_add_proxy(cf, ctx, &amp;cidr); goto done; &#125; if (ctx-&gt;ranges) &#123; rv = ngx_http_geo_range(cf, ctx, value); &#125; else &#123; rv = ngx_http_geo_cidr(cf, ctx, value); &#125;done: ngx_reset_pool(cf-&gt;pool); return rv;failed: ngx_reset_pool(cf-&gt;pool); return NGX_CONF_ERROR;&#125;2.3 处理range地址，调用ngx_http_geo_range函数实现，接下来看看这个函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110static char *ngx_http_geo_range(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx, ngx_str_t *value)&#123; u_char *p, *last; in_addr_t start, end; ngx_str_t *net; ngx_uint_t del; if (ngx_strcmp(value[0].data, &quot;default&quot;) == 0) &#123; if (ctx-&gt;high.default_value) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;duplicate default geo range value: \\&quot;%V\\&quot;, old value: \\&quot;%v\\&quot;&quot;, &amp;value[1], ctx-&gt;high.default_value); &#125; ctx-&gt;high.default_value = ngx_http_geo_value(cf, ctx, &amp;value[1]); if (ctx-&gt;high.default_value == NULL) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK; &#125; if (ctx-&gt;binary_include) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;binary geo range base \\&quot;%s\\&quot; cannot be mixed with usual entries&quot;, ctx-&gt;include_name.data); return NGX_CONF_ERROR; &#125; if (ctx-&gt;high.low == NULL) &#123; ctx-&gt;high.low = ngx_pcalloc(ctx-&gt;pool, 0x10000 * sizeof(ngx_http_geo_range_t *)); if (ctx-&gt;high.low == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; ctx-&gt;entries++; ctx-&gt;outside_entries = 1; if (ngx_strcmp(value[0].data, &quot;delete&quot;) == 0) &#123; net = &amp;value[1]; del = 1; &#125; else &#123; net = &amp;value[0]; del = 0; &#125; last = net-&gt;data + net-&gt;len; p = ngx_strlchr(net-&gt;data, last, &apos;-&apos;); if (p == NULL) &#123; goto invalid; &#125; start = ngx_inet_addr(net-&gt;data, p - net-&gt;data); if (start == INADDR_NONE) &#123; goto invalid; &#125; start = ntohl(start); p++; end = ngx_inet_addr(p, last - p); if (end == INADDR_NONE) &#123; goto invalid; &#125; end = ntohl(end); if (start &gt; end) &#123; goto invalid; &#125; if (del) &#123; if (ngx_http_geo_delete_range(cf, ctx, start, end)) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;no address range \\&quot;%V\\&quot; to delete&quot;, net); &#125; return NGX_CONF_OK; &#125; ctx-&gt;value = ngx_http_geo_value(cf, ctx, &amp;value[1]); if (ctx-&gt;value == NULL) &#123; return NGX_CONF_ERROR; &#125; ctx-&gt;net = net; return ngx_http_geo_add_range(cf, ctx, start, end);invalid: ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid range \\&quot;%V\\&quot;&quot;, net); return NGX_CONF_ERROR;&#125;2.4 处理CIDR地址，调用ngx_http_geo_cidr函数实现，接下来看看这个函数的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static char *ngx_http_geo_cidr(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx, ngx_str_t *value)&#123; char *rv; ngx_int_t rc, del; ngx_str_t *net; ngx_cidr_t cidr; if (ctx-&gt;tree == NULL) &#123; ctx-&gt;tree = ngx_radix_tree_create(ctx-&gt;pool, -1); if (ctx-&gt;tree == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125;#if (NGX_HAVE_INET6) if (ctx-&gt;tree6 == NULL) &#123; ctx-&gt;tree6 = ngx_radix_tree_create(ctx-&gt;pool, -1); if (ctx-&gt;tree6 == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125;#endif if (ngx_strcmp(value[0].data, &quot;default&quot;) == 0) &#123; cidr.family = AF_INET; cidr.u.in.addr = 0; cidr.u.in.mask = 0; rv = ngx_http_geo_cidr_add(cf, ctx, &amp;cidr, &amp;value[1], &amp;value[0]); if (rv != NGX_CONF_OK) &#123; return rv; &#125;#if (NGX_HAVE_INET6) cidr.family = AF_INET6; ngx_memzero(&amp;cidr.u.in6, sizeof(ngx_in6_cidr_t)); rv = ngx_http_geo_cidr_add(cf, ctx, &amp;cidr, &amp;value[1], &amp;value[0]); if (rv != NGX_CONF_OK) &#123; return rv; &#125;#endif return NGX_CONF_OK; &#125; if (ngx_strcmp(value[0].data, &quot;delete&quot;) == 0) &#123; net = &amp;value[1]; del = 1; &#125; else &#123; net = &amp;value[0]; del = 0; &#125; if (ngx_http_geo_cidr_value(cf, net, &amp;cidr) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (cidr.family == AF_INET) &#123; cidr.u.in.addr = ntohl(cidr.u.in.addr); cidr.u.in.mask = ntohl(cidr.u.in.mask); &#125; if (del) &#123; switch (cidr.family) &#123;#if (NGX_HAVE_INET6) case AF_INET6: rc = ngx_radix128tree_delete(ctx-&gt;tree6, cidr.u.in6.addr.s6_addr, cidr.u.in6.mask.s6_addr); break;#endif default: /* AF_INET */ rc = ngx_radix32tree_delete(ctx-&gt;tree, cidr.u.in.addr, cidr.u.in.mask); break; &#125; if (rc != NGX_OK) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;no network \\&quot;%V\\&quot; to delete&quot;, net); &#125; return NGX_CONF_OK; &#125; return ngx_http_geo_cidr_add(cf, ctx, &amp;cidr, &amp;value[1], net);&#125;2.5 获取解析好的变量值，调用ngx_http_geo_range_variable函数实现，接下来看看这个函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081static ngx_int_tngx_http_geo_range_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)&#123; ngx_http_geo_ctx_t *ctx = (ngx_http_geo_ctx_t *) data; in_addr_t inaddr; ngx_addr_t addr; ngx_uint_t n; struct sockaddr_in *sin; ngx_http_geo_range_t *range;#if (NGX_HAVE_INET6) u_char *p; struct in6_addr *inaddr6;#endif *v = *ctx-&gt;u.high.default_value; if (ngx_http_geo_addr(r, ctx, &amp;addr) == NGX_OK) &#123; switch (addr.sockaddr-&gt;sa_family) &#123;#if (NGX_HAVE_INET6) case AF_INET6: inaddr6 = &amp;((struct sockaddr_in6 *) addr.sockaddr)-&gt;sin6_addr; if (IN6_IS_ADDR_V4MAPPED(inaddr6)) &#123; p = inaddr6-&gt;s6_addr; inaddr = p[12] &lt;&lt; 24; inaddr += p[13] &lt;&lt; 16; inaddr += p[14] &lt;&lt; 8; inaddr += p[15]; &#125; else &#123; inaddr = INADDR_NONE; &#125; break;#endif#if (NGX_HAVE_UNIX_DOMAIN) case AF_UNIX: inaddr = INADDR_NONE; break;#endif default: /* AF_INET */ sin = (struct sockaddr_in *) addr.sockaddr; inaddr = ntohl(sin-&gt;sin_addr.s_addr); break; &#125; &#125; else &#123; inaddr = INADDR_NONE; &#125; if (ctx-&gt;u.high.low) &#123; range = ctx-&gt;u.high.low[inaddr &gt;&gt; 16]; if (range) &#123; n = inaddr &amp; 0xffff; do &#123; if (n &gt;= (ngx_uint_t) range-&gt;start &amp;&amp; n &lt;= (ngx_uint_t) range-&gt;end) &#123; *v = *range-&gt;value; break; &#125; &#125; while ((++range)-&gt;value); &#125; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;http geo: %v&quot;, v); return NGX_OK;&#125;3、总结以上就是整个geo模块的核心，stream下的geo模块实现方式类似。s","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的map模块","slug":"Nginx的map模块","date":"2019-10-12T01:25:27.000Z","updated":"2021-05-24T13:50:05.498Z","comments":true,"path":"2019/10/12/Nginx的map模块/","link":"","permalink":"https://weeweetan.github.io/2019/10/12/Nginx的map模块/","excerpt":"","text":"1、相关配置geo模块配置指令如下：12345map $var1 $var2 &#123; &#125;详细用法参考nginx官方文档,此模块的功能是将$var1通过{}中的匹配条件生成$var2的值，支持正则表达式。2、代码详解2.1、首先来看看配置解析函数，负责解析map指令后的两个变量，并设置获取变量值的函数指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199static char *ngx_http_map_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_map_conf_t *mcf = conf; char *rv; ngx_str_t *value, name; ngx_conf_t save; ngx_pool_t *pool; ngx_hash_init_t hash; ngx_http_map_ctx_t *map; ngx_http_variable_t *var; ngx_http_map_conf_ctx_t ctx; ngx_http_compile_complex_value_t ccv; //设置hash桶最大值 if (mcf-&gt;hash_max_size == NGX_CONF_UNSET_UINT) &#123; mcf-&gt;hash_max_size = 2048; &#125; if (mcf-&gt;hash_bucket_size == NGX_CONF_UNSET_UINT) &#123; mcf-&gt;hash_bucket_size = ngx_cacheline_size; &#125; else &#123; mcf-&gt;hash_bucket_size = ngx_align(mcf-&gt;hash_bucket_size, ngx_cacheline_size); &#125; map = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_map_ctx_t)); if (map == NULL) &#123; return NGX_CONF_ERROR; &#125; value = cf-&gt;args-&gt;elts; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = &amp;map-&gt;value; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; //解析第二个变量 name = value[2]; if (name.data[0] != '$') &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;name); return NGX_CONF_ERROR; &#125; //保存$符号后面的字符串 name.len--; name.data++; // 把变量名添加到全局变量中 var = ngx_http_add_variable(cf, &amp;name, NGX_HTTP_VAR_CHANGEABLE); if (var == NULL) &#123; return NGX_CONF_ERROR; &#125; //设置获取此变量值的handler var-&gt;get_handler = ngx_http_map_variable; var-&gt;data = (uintptr_t) map; pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf-&gt;log); if (pool == NULL) &#123; return NGX_CONF_ERROR; &#125; ctx.keys.pool = cf-&gt;pool; ctx.keys.temp_pool = pool; if (ngx_hash_keys_array_init(&amp;ctx.keys, NGX_HASH_LARGE) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; ctx.values_hash = ngx_pcalloc(pool, sizeof(ngx_array_t) * ctx.keys.hsize); if (ctx.values_hash == NULL) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; // 初始化正则表达式#if (NGX_PCRE) if (ngx_array_init(&amp;ctx.regexes, cf-&gt;pool, 2, sizeof(ngx_http_map_regex_t)) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125;#endif ctx.default_value = NULL; ctx.cf = &amp;save; ctx.hostnames = 0; ctx.no_cacheable = 0; save = *cf; cf-&gt;pool = pool; cf-&gt;ctx = &amp;ctx; cf-&gt;handler = ngx_http_map; cf-&gt;handler_conf = conf; rv = ngx_conf_parse(cf, NULL); *cf = save; if (rv != NGX_CONF_OK) &#123; ngx_destroy_pool(pool); return rv; &#125; if (ctx.no_cacheable) &#123; var-&gt;flags |= NGX_HTTP_VAR_NOCACHEABLE; &#125; map-&gt;default_value = ctx.default_value ? ctx.default_value: &amp;ngx_http_variable_null_value; map-&gt;hostnames = ctx.hostnames; hash.key = ngx_hash_key_lc; hash.max_size = mcf-&gt;hash_max_size; hash.bucket_size = mcf-&gt;hash_bucket_size; hash.name = \"map_hash\"; hash.pool = cf-&gt;pool; if (ctx.keys.keys.nelts) &#123; hash.hash = &amp;map-&gt;map.hash.hash; hash.temp_pool = NULL; if (ngx_hash_init(&amp;hash, ctx.keys.keys.elts, ctx.keys.keys.nelts) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; &#125; if (ctx.keys.dns_wc_head.nelts) &#123; ngx_qsort(ctx.keys.dns_wc_head.elts, (size_t) ctx.keys.dns_wc_head.nelts, sizeof(ngx_hash_key_t), ngx_http_map_cmp_dns_wildcards); hash.hash = NULL; hash.temp_pool = pool; if (ngx_hash_wildcard_init(&amp;hash, ctx.keys.dns_wc_head.elts, ctx.keys.dns_wc_head.nelts) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; map-&gt;map.hash.wc_head = (ngx_hash_wildcard_t *) hash.hash; &#125; if (ctx.keys.dns_wc_tail.nelts) &#123; ngx_qsort(ctx.keys.dns_wc_tail.elts, (size_t) ctx.keys.dns_wc_tail.nelts, sizeof(ngx_hash_key_t), ngx_http_map_cmp_dns_wildcards); hash.hash = NULL; hash.temp_pool = pool; if (ngx_hash_wildcard_init(&amp;hash, ctx.keys.dns_wc_tail.elts, ctx.keys.dns_wc_tail.nelts) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; map-&gt;map.hash.wc_tail = (ngx_hash_wildcard_t *) hash.hash; &#125;#if (NGX_PCRE) if (ctx.regexes.nelts) &#123; map-&gt;map.regex = ctx.regexes.elts; map-&gt;map.nregex = ctx.regexes.nelts; &#125;#endif ngx_destroy_pool(pool); return rv;&#125;2.2、解析map块中的内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210static char *ngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)&#123; u_char *data; size_t len; ngx_int_t rv; ngx_str_t *value, v; ngx_uint_t i, key; ngx_http_map_conf_ctx_t *ctx; ngx_http_complex_value_t cv, *cvp; ngx_http_variable_value_t *var, **vp; ngx_http_compile_complex_value_t ccv; ctx = cf-&gt;ctx; value = cf-&gt;args-&gt;elts; if (cf-&gt;args-&gt;nelts == 1 &amp;&amp; ngx_strcmp(value[0].data, \"hostnames\") == 0) &#123; ctx-&gt;hostnames = 1; return NGX_CONF_OK; &#125; if (cf-&gt;args-&gt;nelts == 1 &amp;&amp; ngx_strcmp(value[0].data, \"volatile\") == 0) &#123; ctx-&gt;no_cacheable = 1; return NGX_CONF_OK; &#125; if (cf-&gt;args-&gt;nelts != 2) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid number of the map parameters\"); return NGX_CONF_ERROR; &#125; if (ngx_strcmp(value[0].data, \"include\") == 0) &#123; return ngx_conf_include(cf, dummy, conf); &#125; key = 0; for (i = 0; i &lt; value[1].len; i++) &#123; key = ngx_hash(key, value[1].data[i]); &#125; key %= ctx-&gt;keys.hsize; vp = ctx-&gt;values_hash[key].elts; if (vp) &#123; for (i = 0; i &lt; ctx-&gt;values_hash[key].nelts; i++) &#123; if (vp[i]-&gt;valid) &#123; data = vp[i]-&gt;data; len = vp[i]-&gt;len; &#125; else &#123; cvp = (ngx_http_complex_value_t *) vp[i]-&gt;data; data = cvp-&gt;value.data; len = cvp-&gt;value.len; &#125; if (value[1].len != len) &#123; continue; &#125; if (ngx_strncmp(value[1].data, data, len) == 0) &#123; var = vp[i]; goto found; &#125; &#125; &#125; else &#123; if (ngx_array_init(&amp;ctx-&gt;values_hash[key], cf-&gt;pool, 4, sizeof(ngx_http_variable_value_t *)) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; var = ngx_palloc(ctx-&gt;keys.pool, sizeof(ngx_http_variable_value_t)); if (var == NULL) &#123; return NGX_CONF_ERROR; &#125; v.len = value[1].len; v.data = ngx_pstrdup(ctx-&gt;keys.pool, &amp;value[1]); if (v.data == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = ctx-&gt;cf; ccv.value = &amp;v; ccv.complex_value = &amp;cv; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (cv.lengths != NULL) &#123; cvp = ngx_palloc(ctx-&gt;keys.pool, sizeof(ngx_http_complex_value_t)); if (cvp == NULL) &#123; return NGX_CONF_ERROR; &#125; *cvp = cv; var-&gt;len = 0; var-&gt;data = (u_char *) cvp; var-&gt;valid = 0; &#125; else &#123; var-&gt;len = v.len; var-&gt;data = v.data; var-&gt;valid = 1; &#125; var-&gt;no_cacheable = 0; var-&gt;not_found = 0; vp = ngx_array_push(&amp;ctx-&gt;values_hash[key]); if (vp == NULL) &#123; return NGX_CONF_ERROR; &#125; *vp = var;found: if (ngx_strcmp(value[0].data, \"default\") == 0) &#123; if (ctx-&gt;default_value) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"duplicate default map parameter\"); return NGX_CONF_ERROR; &#125; ctx-&gt;default_value = var; return NGX_CONF_OK; &#125;#if (NGX_PCRE) if (value[0].len &amp;&amp; value[0].data[0] == '~') &#123; ngx_regex_compile_t rc; ngx_http_map_regex_t *regex; u_char errstr[NGX_MAX_CONF_ERRSTR]; regex = ngx_array_push(&amp;ctx-&gt;regexes); if (regex == NULL) &#123; return NGX_CONF_ERROR; &#125; value[0].len--; value[0].data++; ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t)); if (value[0].data[0] == '*') &#123; value[0].len--; value[0].data++; rc.options = NGX_REGEX_CASELESS; &#125; rc.pattern = value[0]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; regex-&gt;regex = ngx_http_regex_compile(ctx-&gt;cf, &amp;rc); if (regex-&gt;regex == NULL) &#123; return NGX_CONF_ERROR; &#125; regex-&gt;value = var; return NGX_CONF_OK; &#125;#endif if (value[0].len &amp;&amp; value[0].data[0] == '\\\\') &#123; value[0].len--; value[0].data++; &#125; rv = ngx_hash_add_key(&amp;ctx-&gt;keys, &amp;value[0], var, (ctx-&gt;hostnames) ? NGX_HASH_WILDCARD_KEY : 0); if (rv == NGX_OK) &#123; return NGX_CONF_OK; &#125; if (rv == NGX_DECLINED) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid hostname or wildcard \\\"%V\\\"\", &amp;value[0]); &#125; if (rv == NGX_BUSY) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"conflicting parameter \\\"%V\\\"\", &amp;value[0]); &#125; return NGX_CONF_ERROR;&#125;s3、总结map模块生成的变量遵循nginx的变量规则，获取变量值的方式也与nginx其他变量类似","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx变量详解","slug":"Nginx变量详解","date":"2019-10-12T01:19:08.000Z","updated":"2022-09-13T13:50:23.274Z","comments":true,"path":"2019/10/12/Nginx变量详解/","link":"","permalink":"https://weeweetan.github.io/2019/10/12/Nginx变量详解/","excerpt":"","text":"1、源码解析1.1 变量分类nginx变量分为两种，一种是nginx内置变量，可以通过官方网站查询到的含义，另外一种则是在nginx配置文件中通过set指令设置的变量，首先来看一下nginx的内置变量实现方式。1.1.1 nginx内置变量首先看看定义内置变量的结构体12345678struct ngx_http_variable_s &#123; ngx_str_t name; /* must be first to build the hash */ ngx_http_set_variable_pt set_handler; ngx_http_get_variable_pt get_handler; uintptr_t data; ngx_uint_t flags; ngx_uint_t index;&#125;;上面这个结构体中，name代表变量名称，比如$request_uri,$args等，set_handler暂时没有使用到，get_handler获取变量值，data一般表示为变量值来自于这里，flags表示此变量遵循的一些规则，比如NGX_HTTP_VAR_CHANGEABLE，index表示此变量在整个nginx变量系统中的索引。接下来就是将变量添加到nginx的变量系统中了，这里以http模块的核心变量为例进行说明。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879ngx_http_variable_t *ngx_http_add_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)&#123; ngx_int_t rc; ngx_uint_t i; ngx_hash_key_t *key; ngx_http_variable_t *v; ngx_http_core_main_conf_t *cmcf; if (name-&gt;len == 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"$\\\"\"); return NULL; &#125; // 前缀变量，例如http_,arg_ 等 if (flags &amp; NGX_HTTP_VAR_PREFIX) &#123; return ngx_http_add_prefix_variable(cf, name, flags); &#125; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); key = cmcf-&gt;variables_keys-&gt;keys.elts; for (i = 0; i &lt; cmcf-&gt;variables_keys-&gt;keys.nelts; i++) &#123; if (name-&gt;len != key[i].key.len || ngx_strncasecmp(name-&gt;data, key[i].key.data, name-&gt;len) != 0) &#123; continue; &#125; v = key[i].value; if (!(v-&gt;flags &amp; NGX_HTTP_VAR_CHANGEABLE)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"the duplicate \\\"%V\\\" variable\", name); return NULL; &#125; if (!(flags &amp; NGX_HTTP_VAR_WEAK)) &#123; v-&gt;flags &amp;= ~NGX_HTTP_VAR_WEAK; &#125; return v; &#125; v = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_variable_t)); if (v == NULL) &#123; return NULL; &#125; v-&gt;name.len = name-&gt;len; v-&gt;name.data = ngx_pnalloc(cf-&gt;pool, name-&gt;len); if (v-&gt;name.data == NULL) &#123; return NULL; &#125; ngx_strlow(v-&gt;name.data, name-&gt;data, name-&gt;len); v-&gt;set_handler = NULL; v-&gt;get_handler = NULL; v-&gt;data = 0; v-&gt;flags = flags; v-&gt;index = 0; rc = ngx_hash_add_key(cmcf-&gt;variables_keys, &amp;v-&gt;name, v, 0); if (rc == NGX_ERROR) &#123; return NULL; &#125; if (rc == NGX_BUSY) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"conflicting variable name \\\"%V\\\"\", name); return NULL; &#125; return v;&#125;这个函数的作用就是将定义的变量添加到http核心配置中，为获取变量的值做好准备，其他变量类似。接下来就是如何获取变量值了，http的日志模块提供了一个很好的范本。接下来看看ngx_http_variables_init_vars函数的实现，这个函数的主要功能是设置变量的get_handler，从各个模块初始化的变量key中寻找123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114ngx_int_tngx_http_variables_init_vars(ngx_conf_t *cf)&#123; size_t len; ngx_uint_t i, n; ngx_hash_key_t *key; ngx_hash_init_t hash; ngx_http_variable_t *v, *av, *pv; ngx_http_core_main_conf_t *cmcf; /* set the handlers for the indexed http variables */ cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); v = cmcf-&gt;variables.elts; pv = cmcf-&gt;prefix_variables.elts; key = cmcf-&gt;variables_keys-&gt;keys.elts; // cmcf-&gt;variable变量是配置文件中使用的变量 for (i = 0; i &lt; cmcf-&gt;variables.nelts; i++) &#123; // 这个key是所有模块定义的变量key for (n = 0; n &lt; cmcf-&gt;variables_keys-&gt;keys.nelts; n++) &#123; av = key[n].value; if (v[i].name.len == key[n].key.len &amp;&amp; ngx_strncmp(v[i].name.data, key[n].key.data, v[i].name.len) == 0) &#123; // 设置get_handler v[i].get_handler = av-&gt;get_handler; v[i].data = av-&gt;data; av-&gt;flags |= NGX_HTTP_VAR_INDEXED; v[i].flags = av-&gt;flags; av-&gt;index = i; if (av-&gt;get_handler == NULL || (av-&gt;flags &amp; NGX_HTTP_VAR_WEAK)) &#123; break; &#125; goto next; &#125; &#125; len = 0; av = NULL; // 设置前缀变量get_handler for (n = 0; n &lt; cmcf-&gt;prefix_variables.nelts; n++) &#123; if (v[i].name.len &gt;= pv[n].name.len &amp;&amp; v[i].name.len &gt; len &amp;&amp; ngx_strncmp(v[i].name.data, pv[n].name.data, pv[n].name.len) == 0) &#123; av = &amp;pv[n]; len = pv[n].name.len; &#125; &#125; if (av) &#123; v[i].get_handler = av-&gt;get_handler; v[i].data = (uintptr_t) &amp;v[i].name; v[i].flags = av-&gt;flags; goto next; &#125; // 如果变量get_handler为NULL，报错 if (v[i].get_handler == NULL) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, \"unknown \\\"%V\\\" variable\", &amp;v[i].name); return NGX_ERROR; &#125; next: continue; &#125; // 如果带有nohash的标识，则将key.data置为NULL，在ngx_hash_init就不会将该key放在hash桶里面，比如proxy模块的几个变量 for (n = 0; n &lt; cmcf-&gt;variables_keys-&gt;keys.nelts; n++) &#123; av = key[n].value; if (av-&gt;flags &amp; NGX_HTTP_VAR_NOHASH) &#123; key[n].key.data = NULL; &#125; &#125; hash.hash = &amp;cmcf-&gt;variables_hash; hash.key = ngx_hash_key; hash.max_size = cmcf-&gt;variables_hash_max_size; hash.bucket_size = cmcf-&gt;variables_hash_bucket_size; hash.name = \"variables_hash\"; hash.pool = cf-&gt;pool; hash.temp_pool = NULL; // 开始初始化变量hash表 if (ngx_hash_init(&amp;hash, cmcf-&gt;variables_keys-&gt;keys.elts, cmcf-&gt;variables_keys-&gt;keys.nelts) != NGX_OK) &#123; return NGX_ERROR; &#125; cmcf-&gt;variables_keys = NULL; return NGX_OK;&#125;http模块如何获取变量，接下来看看ngx_http_get_variable函数实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071ngx_http_variable_value_t *ngx_http_get_variable(ngx_http_request_t *r, ngx_str_t *name, ngx_uint_t key)&#123; size_t len; ngx_uint_t i, n; ngx_http_variable_t *v; ngx_http_variable_value_t *vv; ngx_http_core_main_conf_t *cmcf; cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module); // 从全局变量hash表中根据key找到对应变量 v = ngx_hash_find(&amp;cmcf-&gt;variables_hash, key, name-&gt;data, name-&gt;len); if (v) &#123; if (v-&gt;flags &amp; NGX_HTTP_VAR_INDEXED) &#123; return ngx_http_get_flushed_variable(r, v-&gt;index); &#125; if (ngx_http_variable_depth == 0) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"cycle while evaluating variable \\\"%V\\\"\", name); return NULL; &#125; ngx_http_variable_depth--; vv = ngx_palloc(r-&gt;pool, sizeof(ngx_http_variable_value_t)); if (vv &amp;&amp; v-&gt;get_handler(r, vv, v-&gt;data) == NGX_OK) &#123; ngx_http_variable_depth++; return vv; &#125; ngx_http_variable_depth++; return NULL; &#125; vv = ngx_palloc(r-&gt;pool, sizeof(ngx_http_variable_value_t)); if (vv == NULL) &#123; return NULL; &#125; len = 0; v = cmcf-&gt;prefix_variables.elts; n = cmcf-&gt;prefix_variables.nelts; // 从前缀变量中查找 for (i = 0; i &lt; cmcf-&gt;prefix_variables.nelts; i++) &#123; if (name-&gt;len &gt;= v[i].name.len &amp;&amp; name-&gt;len &gt; len &amp;&amp; ngx_strncmp(name-&gt;data, v[i].name.data, v[i].name.len) == 0) &#123; len = v[i].name.len; n = i; &#125; &#125; // 从前缀变量中找到该变量 if (n != cmcf-&gt;prefix_variables.nelts) &#123; if (v[n].get_handler(r, vv, (uintptr_t) name) == NGX_OK) &#123; return vv; &#125; return NULL; &#125; vv-&gt;not_found = 1; return vv;&#125;1.1.2 配置文件变量配置文件变量是指set指令设置的变量，1set $a value;具体可以参考set，首先来看看set指令解析函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; ngx_int_t index; ngx_str_t *value; ngx_http_variable_t *v; ngx_http_script_var_code_t *vcode; ngx_http_script_var_handler_code_t *vhcode; value = cf-&gt;args-&gt;elts; // 如果没有带$符号，则返回错误 if (value[1].data[0] != '$') &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;value[1]); return NGX_CONF_ERROR; &#125; value[1].len--; value[1].data++; // 将变量添加到全局变量中 v = ngx_http_add_variable(cf, &amp;value[1], NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_WEAK); if (v == NULL) &#123; return NGX_CONF_ERROR; &#125; // 获取变量索引 index = ngx_http_get_variable_index(cf, &amp;value[1]); if (index == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125; if (v-&gt;get_handler == NULL) &#123; v-&gt;get_handler = ngx_http_rewrite_var; v-&gt;data = index; &#125; if (ngx_http_rewrite_value(cf, lcf, &amp;value[2]) != NGX_CONF_OK) &#123; return NGX_CONF_ERROR; &#125; //处理set_handler if (v-&gt;set_handler) &#123; vhcode = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_var_handler_code_t)); if (vhcode == NULL) &#123; return NGX_CONF_ERROR; &#125; vhcode-&gt;code = ngx_http_script_var_set_handler_code; vhcode-&gt;handler = v-&gt;set_handler; vhcode-&gt;data = v-&gt;data; return NGX_CONF_OK; &#125; vcode = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_var_code_t)); if (vcode == NULL) &#123; return NGX_CONF_ERROR; &#125; vcode-&gt;code = ngx_http_script_set_var_code; vcode-&gt;index = (uintptr_t) index; return NGX_CONF_OK;&#125;这个函数首先解析出第一个变量的名字，并将其加入到nginx的变量系统中，其次解析作为第一个值的变量(第二个变量)，但是第二个变量可能是一个普通的字符串也有可能是多个变量组成的字符串，都是在ngx_http_rewrite_value函数中进行处理，接下来看看ngx_http_rewrite_value函数实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static char *ngx_http_rewrite_value(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value)&#123; ngx_int_t n; ngx_http_script_compile_t sc; ngx_http_script_value_code_t *val; ngx_http_script_complex_value_code_t *complex; n = ngx_http_script_variables_count(value); if (n == 0) &#123; val = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_value_code_t)); if (val == NULL) &#123; return NGX_CONF_ERROR; &#125; n = ngx_atoi(value-&gt;data, value-&gt;len); if (n == NGX_ERROR) &#123; n = 0; &#125; val-&gt;code = ngx_http_script_value_code; val-&gt;value = (uintptr_t) n; val-&gt;text_len = (uintptr_t) value-&gt;len; val-&gt;text_data = (uintptr_t) value-&gt;data; return NGX_CONF_OK; &#125; //带有$的变量，value也是变量，如set $aa $bb，这里的$bb就是变量， complex = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_complex_value_code_t)); if (complex == NULL) &#123; return NGX_CONF_ERROR; &#125; complex-&gt;code = ngx_http_script_complex_value_code; complex-&gt;lengths = NULL; ngx_memzero(&amp;sc, sizeof(ngx_http_script_compile_t)); sc.cf = cf; sc.source = value; sc.lengths = &amp;complex-&gt;lengths; sc.values = &amp;lcf-&gt;codes; sc.variables = n; sc.complete_lengths = 1; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK;&#125;这个函数中，n为0表示value不包含变量，为纯字符串，否则表示value中包含变量，采用复杂变量解析方式。2、总结以上就是Nginx变量的相关解释，Nginx变量在nginx.conf配置文件中有着至关重要的作用，可定制性强。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的轮询算法","slug":"Nginx的轮询算法","date":"2019-09-15T10:27:13.000Z","updated":"2022-04-15T13:41:43.545Z","comments":true,"path":"2019/09/15/Nginx的轮询算法/","link":"","permalink":"https://weeweetan.github.io/2019/09/15/Nginx的轮询算法/","excerpt":"","text":"1、概述Nginx轮询算法应用于http模块和stream模块的upstream块，根据权重选择相应的服务器进行负载均衡。1.1、相关配置1234567891011http &#123; upstream backend &#123; server 127.0.0.1:8080 weight=10; server 192.168.1.2:8080 weight=10; &#125;&#125;&gt;若upstream块中没有指定负载均衡算法，则默认使用轮询算法。2、算法实现Nginx中http_upstream_module跟stream_upstream_module模块都使用了轮询算法，这里以stream_upstrean模块为例2.1、相关结构体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566typedef struct &#123; ngx_stream_upstream_rr_peers_t *peers; ngx_stream_upstream_rr_peer_t *current; uintptr_t *tried; //若后端服务器数量大于32，则使用此字段表示各个服务器是否使用 uintptr_t data; //若后端服务器数量小于32，则使用此字段表示各个服务器是否使用&#125; ngx_stream_upstream_rr_peer_data_t;typedef struct ngx_stream_upstream_rr_peer_s ngx_stream_upstream_rr_peer_t;struct ngx_stream_upstream_rr_peer_s &#123; struct sockaddr *sockaddr; socklen_t socklen; ngx_str_t name; //服务器名称，一般是ip地址 ngx_str_t server; ngx_int_t current_weight; ngx_int_t effective_weight; //RR算法权重，初始值与weight相同 ngx_int_t weight; //配置的权重 ngx_uint_t conns; //该后端peer上面的成功连接数 ngx_uint_t fails; //已尝试失败次数 time_t accessed; time_t checked; ngx_uint_t max_fails; //配置的max_fails阈值 time_t fail_timeout; ngx_uint_t down; /* unsigned down:1; */#if (NGX_STREAM_SSL) void *ssl_session; int ssl_session_len;#endif ngx_stream_upstream_rr_peer_t *next;#if (NGX_STREAM_UPSTREAM_ZONE) ngx_atomic_t lock;#endif&#125;;typedef struct ngx_stream_upstream_rr_peers_s ngx_stream_upstream_rr_peers_t;struct ngx_stream_upstream_rr_peers_s &#123; ngx_uint_t number; //服务器数量 为后端配置了多少个服务器 #if (NGX_STREAM_UPSTREAM_ZONE) ngx_slab_pool_t *shpool; ngx_atomic_t rwlock;#endif ngx_uint_t total_weight; //所有服务器的权重和 unsigned single:1; //是否只有一个服务器 unsigned weighted:1; ngx_str_t *name; ngx_stream_upstream_rr_peers_t *next; ngx_stream_upstream_rr_peer_t *peer; //服务器信息 //所有的peer[]服务器信息通过peers-&gt;peer连接在一起&#125;;上述3个结构体是整个轮询算法的核心，ngx_stream_upstream_rr_peer_data_t结构体保存已经选择过的服务器以及当前选择的服务器，ngx_stream_upstream_rr_peers_t结构体中几个weight成员用来选择服务器。2.1 初始化ngx_stream_upstream_rr_peer_t结构体Nginx在解析配置文件时，当解析到upstream块时，会调用ngx_stream_upstream_init_round_robin函数，将配置文件中的server保存在ngx_stream_upstream_rr_peer_t结构体中。接下来看看ngx_stream_upstream_init_round_robin函数定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210ngx_int_tngx_stream_upstream_init_round_robin(ngx_conf_t *cf, ngx_stream_upstream_srv_conf_t *us)&#123; ngx_url_t u; ngx_uint_t i, j, n, w; ngx_stream_upstream_server_t *server; ngx_stream_upstream_rr_peer_t *peer, **peerp; ngx_stream_upstream_rr_peers_t *peers, *backup;//一个是正常的servers，一个是backup servers us-&gt;peer.init = ngx_stream_upstream_init_round_robin_peer;//upstream中服务器节点的初始化赋值 if (us-&gt;servers) &#123; server = us-&gt;servers-&gt;elts; n = 0; w = 0; for (i = 0; i &lt; us-&gt;servers-&gt;nelts; i++) &#123; if (server[i].backup) &#123; continue; &#125; n += server[i].naddrs; w += server[i].naddrs * server[i].weight; &#125; if (n == 0) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, \"no servers in upstream \\\"%V\\\" in %s:%ui\", &amp;us-&gt;host, us-&gt;file_name, us-&gt;line); return NGX_ERROR; &#125; peers = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peers_t)); if (peers == NULL) &#123; return NGX_ERROR; &#125; peer = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peer_t) * n); if (peer == NULL) &#123; return NGX_ERROR; &#125; peers-&gt;single = (n == 1); peers-&gt;number = n; peers-&gt;weighted = (w != n); peers-&gt;total_weight = w; peers-&gt;name = &amp;us-&gt;host; n = 0; peerp = &amp;peers-&gt;peer; //初始化peer数据 for (i = 0; i &lt; us-&gt;servers-&gt;nelts; i++) &#123; if (server[i].backup) &#123; continue; &#125; for (j = 0; j &lt; server[i].naddrs; j++) &#123; peer[n].sockaddr = server[i].addrs[j].sockaddr; peer[n].socklen = server[i].addrs[j].socklen; peer[n].name = server[i].addrs[j].name; peer[n].weight = server[i].weight; peer[n].effective_weight = server[i].weight; peer[n].current_weight = 0; peer[n].max_fails = server[i].max_fails; peer[n].fail_timeout = server[i].fail_timeout; peer[n].down = server[i].down; peer[n].server = server[i].name; *peerp = &amp;peer[n]; peerp = &amp;peer[n].next; n++; &#125; &#125; us-&gt;peer.data = peers; /* backup servers */ n = 0; w = 0; for (i = 0; i &lt; us-&gt;servers-&gt;nelts; i++) &#123; if (!server[i].backup) &#123; continue; &#125; n += server[i].naddrs; w += server[i].naddrs * server[i].weight; &#125; if (n == 0) &#123; return NGX_OK; &#125; backup = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peers_t)); if (backup == NULL) &#123; return NGX_ERROR; &#125; peer = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peer_t) * n); if (peer == NULL) &#123; return NGX_ERROR; &#125; peers-&gt;single = 0; backup-&gt;single = 0; backup-&gt;number = n; backup-&gt;weighted = (w != n); backup-&gt;total_weight = w; backup-&gt;name = &amp;us-&gt;host; n = 0; peerp = &amp;backup-&gt;peer; for (i = 0; i &lt; us-&gt;servers-&gt;nelts; i++) &#123; if (!server[i].backup) &#123; continue; &#125; for (j = 0; j &lt; server[i].naddrs; j++) &#123; peer[n].sockaddr = server[i].addrs[j].sockaddr; peer[n].socklen = server[i].addrs[j].socklen; peer[n].name = server[i].addrs[j].name; peer[n].weight = server[i].weight; peer[n].effective_weight = server[i].weight; peer[n].current_weight = 0; peer[n].max_fails = server[i].max_fails; peer[n].fail_timeout = server[i].fail_timeout; peer[n].down = server[i].down; peer[n].server = server[i].name; *peerp = &amp;peer[n]; peerp = &amp;peer[n].next; n++; &#125; &#125; peers-&gt;next = backup; return NGX_OK; &#125; /* an upstream implicitly defined by proxy_pass, etc. */ if (us-&gt;port == 0) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, \"no port in upstream \\\"%V\\\" in %s:%ui\", &amp;us-&gt;host, us-&gt;file_name, us-&gt;line); return NGX_ERROR; &#125; ngx_memzero(&amp;u, sizeof(ngx_url_t)); u.host = us-&gt;host; u.port = us-&gt;port; if (ngx_inet_resolve_host(cf-&gt;pool, &amp;u) != NGX_OK) &#123; if (u.err) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, \"%s in upstream \\\"%V\\\" in %s:%ui\", u.err, &amp;us-&gt;host, us-&gt;file_name, us-&gt;line); &#125; return NGX_ERROR; &#125; n = u.naddrs; peers = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peers_t)); if (peers == NULL) &#123; return NGX_ERROR; &#125; peer = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peer_t) * n); if (peer == NULL) &#123; return NGX_ERROR; &#125; peers-&gt;single = (n == 1); peers-&gt;number = n; peers-&gt;weighted = 0; peers-&gt;total_weight = n; peers-&gt;name = &amp;us-&gt;host; peerp = &amp;peers-&gt;peer; for (i = 0; i &lt; u.naddrs; i++) &#123; peer[i].sockaddr = u.addrs[i].sockaddr; peer[i].socklen = u.addrs[i].socklen; peer[i].name = u.addrs[i].name; peer[i].weight = 1; peer[i].effective_weight = 1; peer[i].current_weight = 0; peer[i].max_fails = 1; peer[i].fail_timeout = 10; *peerp = &amp;peer[i]; peerp = &amp;peer[i].next; &#125; us-&gt;peer.data = peers; /* implicitly defined upstream has no backup servers */ return NGX_OK;&#125;如果没有指定其他负载均衡算法，则此函数在配置解析阶段执行，由ngx_stream_upstream_init_main_conf函数调用执行。将配置中的后端服务器使用peer连接起来，对backup服务器采取同样的操作。2.2 获取一个选中的server选择一个上游peer，主要由ngx_http_upstream_get_round_robin_peer实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177ngx_int_tngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)&#123; ngx_http_upstream_rr_peer_data_t *rrp = data; ngx_int_t rc; ngx_uint_t i, n; ngx_http_upstream_rr_peer_t *peer; ngx_http_upstream_rr_peers_t *peers; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc-&gt;log, 0, \"get rr peer, try: %ui\", pc-&gt;tries); pc-&gt;cached = 0; pc-&gt;connection = NULL; peers = rrp-&gt;peers; //如果启用了zone，则加锁 ngx_http_upstream_rr_peers_wlock(peers); //只配置了一个server，则直接使用 if (peers-&gt;single) &#123; peer = peers-&gt;peer; //单个server被标记为down，不可用 if (peer-&gt;down) &#123; goto failed; &#125; if (peer-&gt;max_conns &amp;&amp; peer-&gt;conns &gt;= peer-&gt;max_conns) &#123; goto failed; &#125; rrp-&gt;current = peer; &#125; else &#123; /* there are several peers */ // 调用选择peer的函数。 peer = ngx_http_upstream_get_peer(rrp); if (peer == NULL) &#123; goto failed; &#125; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&gt;log, 0, \"get rr peer, current: %p %i\", peer, peer-&gt;current_weight); &#125; // 赋值socket数据 pc-&gt;sockaddr = peer-&gt;sockaddr; pc-&gt;socklen = peer-&gt;socklen; pc-&gt;name = &amp;peer-&gt;name; //此peer上的连接数自增 peer-&gt;conns++; // 解锁 ngx_http_upstream_rr_peers_unlock(peers); return NGX_OK;// 错误处理failed: if (peers-&gt;next) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc-&gt;log, 0, \"backup servers\"); rrp-&gt;peers = peers-&gt;next; n = (rrp-&gt;peers-&gt;number + (8 * sizeof(uintptr_t) - 1)) / (8 * sizeof(uintptr_t)); for (i = 0; i &lt; n; i++) &#123; rrp-&gt;tried[i] = 0; &#125; ngx_http_upstream_rr_peers_unlock(peers); rc = ngx_http_upstream_get_round_robin_peer(pc, rrp); if (rc != NGX_BUSY) &#123; return rc; &#125; ngx_http_upstream_rr_peers_wlock(peers); &#125; ngx_http_upstream_rr_peers_unlock(peers); pc-&gt;name = peers-&gt;name; return NGX_BUSY;&#125;//轮询的核心算法static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)&#123; time_t now; uintptr_t m; ngx_int_t total; ngx_uint_t i, n, p; ngx_http_upstream_rr_peer_t *peer, *best; now = ngx_time(); best = NULL; total = 0;#if (NGX_SUPPRESS_WARN) p = 0;#endif for (peer = rrp-&gt;peers-&gt;peer, i = 0; peer; peer = peer-&gt;next, i++) &#123; //查找已选择过的peer n = i / (8 * sizeof(uintptr_t)); m = (uintptr_t) 1 &lt;&lt; i % (8 * sizeof(uintptr_t)); //已选择过，跳过 if (rrp-&gt;tried[n] &amp; m) &#123; continue; &#125; //被标记为不可用，跳过 if (peer-&gt;down) &#123; continue; &#125; //失败次数超过阈值，跳过 if (peer-&gt;max_fails &amp;&amp; peer-&gt;fails &gt;= peer-&gt;max_fails &amp;&amp; now - peer-&gt;checked &lt;= peer-&gt;fail_timeout) &#123; continue; &#125; //最大连接数超过配置，跳过 if (peer-&gt;max_conns &amp;&amp; peer-&gt;conns &gt;= peer-&gt;max_conns) &#123; continue; &#125; //调整当前peer权重 peer-&gt;current_weight += peer-&gt;effective_weight; total += peer-&gt;effective_weight; if (peer-&gt;effective_weight &lt; peer-&gt;weight) &#123; peer-&gt;effective_weight++; &#125; //根据权重选择 if (best == NULL || peer-&gt;current_weight &gt; best-&gt;current_weight) &#123; best = peer; p = i; &#125; &#125; //没有选择到合适的peer，退出 if (best == NULL) &#123; return NULL; &#125; rrp-&gt;current = best; n = p / (8 * sizeof(uintptr_t)); m = (uintptr_t) 1 &lt;&lt; p % (8 * sizeof(uintptr_t)); //标记已选中 rrp-&gt;tried[n] |= m; //调整选中节点的权重 best-&gt;current_weight -= total; //调整不可用时间 if (now - best-&gt;checked &gt; best-&gt;fail_timeout) &#123; best-&gt;checked = now; &#125; return best;&#125;2.3 释放server释放上游函数主要由ngx_http_upstream_free_round_robin_peer实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778voidngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc, void *data, ngx_uint_t state)&#123; ngx_http_upstream_rr_peer_data_t *rrp = data; time_t now; ngx_http_upstream_rr_peer_t *peer; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&gt;log, 0, \"free rr peer %ui %ui\", pc-&gt;tries, state); /* TODO: NGX_PEER_KEEPALIVE */ peer = rrp-&gt;current; ngx_http_upstream_rr_peers_rlock(rrp-&gt;peers); ngx_http_upstream_rr_peer_lock(rrp-&gt;peers, peer); // 单个peer情况 if (rrp-&gt;peers-&gt;single) &#123; peer-&gt;conns--; ngx_http_upstream_rr_peer_unlock(rrp-&gt;peers, peer); ngx_http_upstream_rr_peers_unlock(rrp-&gt;peers); pc-&gt;tries = 0; return; &#125; //如果以失败的状态进入此函数，调整权重 if (state &amp; NGX_PEER_FAILED) &#123; now = ngx_time(); peer-&gt;fails++; peer-&gt;accessed = now; peer-&gt;checked = now; //调整权重 if (peer-&gt;max_fails) &#123; peer-&gt;effective_weight -= peer-&gt;weight / peer-&gt;max_fails; if (peer-&gt;fails &gt;= peer-&gt;max_fails) &#123; ngx_log_error(NGX_LOG_WARN, pc-&gt;log, 0, \"upstream server temporarily disabled\"); &#125; &#125; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&gt;log, 0, \"free rr peer failed: %p %i\", peer, peer-&gt;effective_weight); //调整权重 if (peer-&gt;effective_weight &lt; 0) &#123; peer-&gt;effective_weight = 0; &#125; &#125; else &#123; /* mark peer live if check passed */ if (peer-&gt;accessed &lt; peer-&gt;checked) &#123; peer-&gt;fails = 0; &#125; &#125; //此上游连接数自减 peer-&gt;conns--; // 若启用了zone模块，则解锁 ngx_http_upstream_rr_peer_unlock(rrp-&gt;peers, peer); ngx_http_upstream_rr_peers_unlock(rrp-&gt;peers); // 重试次数自减 if (pc-&gt;tries) &#123; pc-&gt;tries--; &#125;&#125;3、总结","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx链接自定义静态库","slug":"Nginx链接自定义静态库","date":"2019-08-13T02:06:23.000Z","updated":"2023-05-21T03:56:31.346Z","comments":true,"path":"2019/08/13/Nginx链接自定义静态库/","link":"","permalink":"https://weeweetan.github.io/2019/08/13/Nginx链接自定义静态库/","excerpt":"","text":"1.准备静态库1.1 编译静态库使用gcc将源代码编译为目标文件123gcc -c test.c-c选项只编译不链接，生成目标对象文件，编译成功会生成test.o文件，接着对test.o文件进行打包1.2 打包静态库使用ar命令将test.o打包为静态库文件123ar -crv libtest.a test.o在定义静态库文件文件名时，需要遵从命名规则。2.配置静态库将生成的libtest.a 复制到/usr/lib64目录下，如有头文件，则复制到/usr/include目录下3.修改Nginx编译脚本在auto/unix脚本中修改变量CORE_LIBS的值123CORE_LIBS =\"$CORE_LIBS -ltest\"4. 使用第三方开发库4.1 安装第三方开发库123yum -y install xxx xxx-devel安装成功后，在/usr/include/目录下能找到相应的头文件，在/usr/lib64/目录下能找到类似于libxxx.so的文件4.2 在源码中包含第三方库的头文件，就可以使用相应的函数了4.3 修改Nginx编译脚本在auto/unix脚本中修改变量CORE_LIBS的值123CORE_LIBS =\"$CORE_LIBS -lxxx\"","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的rewrite模块详解","slug":"Nginx的rewrite模块详解","date":"2019-08-09T06:06:55.000Z","updated":"2019-09-01T13:47:08.189Z","comments":true,"path":"2019/08/09/Nginx的rewrite模块详解/","link":"","permalink":"https://weeweetan.github.io/2019/08/09/Nginx的rewrite模块详解/","excerpt":"","text":"1.相关指令1.1 if指令1Context: server, location依据指定的条件决定是否执行 if 块语句中的内容1.2 break指令1Context: server, location, if停止执行 ngx_http_rewrite_module 的指令集，但是其他模块指令是不受影响的1.3 rewrite指令123Context: server, location, ifrewrite regex replacement [flag];rewrite 指令是使用指定的正则表达式regex来匹配请求的urI，如果匹配成功，则使用replacement更改URI。rewrite指令按照它们在配置文件中出现的顺序执行。可以使用flag标志来终止指令的进一步处理。如果替换字符串replacement以http：//，https：//或$scheme开头，则停止处理后续内容，并直接重定向返回给客户端。1.4 return指令123456Context: server, location, ifreturn code [text];return code URL;return URL;停止处理并将指定的code码返回给客户端。 非标准code码 444 关闭连接而不发送响应报头2.源码解析2.1 rewrite指令源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139static char *ngx_http_rewrite(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; ngx_str_t *value; ngx_uint_t last; ngx_regex_compile_t rc; ngx_http_script_code_pt *code; ngx_http_script_compile_t sc; ngx_http_script_regex_code_t *regex; ngx_http_script_regex_end_code_t *regex_end; u_char errstr[NGX_MAX_CONF_ERRSTR]; regex = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_regex_code_t)); if (regex == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(regex, sizeof(ngx_http_script_regex_code_t)); value = cf-&gt;args-&gt;elts; ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t)); rc.pattern = value[1]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; /* TODO: NGX_REGEX_CASELESS */ //解析正则表达式，填写ngx_http_regex_t结构并返回。正则句柄，命名子模式等都在里面了。 regex-&gt;regex = ngx_http_regex_compile(cf, &amp;rc); if (regex-&gt;regex == NULL) &#123; return NGX_CONF_ERROR; &#125; //将其设置为第一个code函数，求出目标字符串大小。尾部还有ngx_http_script_regex_end_code regex-&gt;code = ngx_http_script_regex_start_code; regex-&gt;uri = 1; regex-&gt;name = value[1]; if (value[2].data[value[2].len - 1] == '?') &#123; /* the last \"?\" drops the original arguments */ value[2].len--; &#125; else &#123; regex-&gt;add_args = 1; &#125; last = 0; if (ngx_strncmp(value[2].data, \"http://\", sizeof(\"http://\") - 1) == 0 || ngx_strncmp(value[2].data, \"https://\", sizeof(\"https://\") - 1) == 0 || ngx_strncmp(value[2].data, \"$scheme\", sizeof(\"$scheme\") - 1) == 0) &#123; regex-&gt;status = NGX_HTTP_MOVED_TEMPORARILY; regex-&gt;redirect = 1; last = 1; &#125; if (cf-&gt;args-&gt;nelts == 4) &#123; if (ngx_strcmp(value[3].data, \"last\") == 0) &#123; last = 1; &#125; else if (ngx_strcmp(value[3].data, \"break\") == 0) &#123; regex-&gt;break_cycle = 1; last = 1; &#125; else if (ngx_strcmp(value[3].data, \"redirect\") == 0) &#123; regex-&gt;status = NGX_HTTP_MOVED_TEMPORARILY; regex-&gt;redirect = 1; last = 1; &#125; else if (ngx_strcmp(value[3].data, \"permanent\") == 0) &#123; regex-&gt;status = NGX_HTTP_MOVED_PERMANENTLY; regex-&gt;redirect = 1; last = 1; &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\", &amp;value[3]); return NGX_CONF_ERROR; &#125; &#125; ngx_memzero(&amp;sc, sizeof(ngx_http_script_compile_t)); sc.cf = cf; sc.source = &amp;value[2]; sc.lengths = &amp;regex-&gt;lengths; sc.values = &amp;lcf-&gt;codes; sc.variables = ngx_http_script_variables_count(&amp;value[2]); sc.main = regex; sc.complete_lengths = 1; sc.compile_args = !regex-&gt;redirect; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; regex = sc.main; regex-&gt;size = sc.size; regex-&gt;args = sc.args; if (sc.variables == 0 &amp;&amp; !sc.dup_capture) &#123; regex-&gt;lengths = NULL; &#125; regex_end = ngx_http_script_add_code(lcf-&gt;codes, sizeof(ngx_http_script_regex_end_code_t), &amp;regex); if (regex_end == NULL) &#123; return NGX_CONF_ERROR; &#125; regex_end-&gt;code = ngx_http_script_regex_end_code; //结束回调，对应前面的开始。 regex_end-&gt;uri = regex-&gt;uri; regex_end-&gt;args = regex-&gt;args; regex_end-&gt;add_args = regex-&gt;add_args; regex_end-&gt;redirect = regex-&gt;redirect; if (last) &#123; code = ngx_http_script_add_code(lcf-&gt;codes, sizeof(uintptr_t), &amp;regex); if (code == NULL) &#123; return NGX_CONF_ERROR; &#125; *code = NULL; &#125; //下一个解析句柄组的地址。如果匹配失败，则会直接跳过该regex匹配相关的所有code regex-&gt;next = (u_char *) lcf-&gt;codes-&gt;elts + lcf-&gt;codes-&gt;nelts - (u_char *) regex; return NGX_CONF_OK;&#125;2.2 return指令源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static char *ngx_http_rewrite_return(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; u_char *p; ngx_str_t *value, *v; ngx_http_script_return_code_t *ret; ngx_http_compile_complex_value_t ccv; ret = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_return_code_t)); if (ret == NULL) &#123; return NGX_CONF_ERROR; &#125; value = cf-&gt;args-&gt;elts; ngx_memzero(ret, sizeof(ngx_http_script_return_code_t)); //注册code为ngx_http_script_return_code ret-&gt;code = ngx_http_script_return_code; p = value[1].data; ret-&gt;status = ngx_atoi(p, value[1].len); if (ret-&gt;status == (uintptr_t) NGX_ERROR) &#123; if (cf-&gt;args-&gt;nelts == 2 &amp;&amp; (ngx_strncmp(p, \"http://\", sizeof(\"http://\") - 1) == 0 || ngx_strncmp(p, \"https://\", sizeof(\"https://\") - 1) == 0 || ngx_strncmp(p, \"$scheme\", sizeof(\"$scheme\") - 1) == 0)) &#123; ret-&gt;status = NGX_HTTP_MOVED_TEMPORARILY; v = &amp;value[1]; &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid return code \\\"%V\\\"\", &amp;value[1]); return NGX_CONF_ERROR; &#125; &#125; else &#123; if (ret-&gt;status &gt; 999) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid return code \\\"%V\\\"\", &amp;value[1]); return NGX_CONF_ERROR; &#125; if (cf-&gt;args-&gt;nelts == 2) &#123; return NGX_CONF_OK; &#125; v = &amp;value[2]; &#125; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = v; ccv.complex_value = &amp;ret-&gt;text; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK;&#125;2.3 break指令源码解析123456789101112131415161718static char *ngx_http_rewrite_break(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; ngx_http_script_code_pt *code; code = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(uintptr_t)); if (code == NULL) &#123; return NGX_CONF_ERROR; &#125; *code = ngx_http_script_break_code; return NGX_CONF_OK;&#125;配合ngx_http_rewrite_handler读代码，可以看到如果设置一个code节点到codes数组，那么在ngx_http_rewrite_handler的for循环执行到该节点code的时候，就会把e-&gt;ip置为NULL，这样就直接退出while ((uintptr_t ) e-&gt;ip){}循环2.4 if指令源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120static char * ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; void *mconf; char *rv; u_char *elts; ngx_uint_t i; ngx_conf_t save; ngx_http_module_t *module; ngx_http_conf_ctx_t *ctx, *pctx; ngx_http_core_loc_conf_t *clcf, *pclcf; ngx_http_script_if_code_t *if_code; ngx_http_rewrite_loc_conf_t *nlcf; //if的解析过程和location&#123;&#125;解析过程差不多,也有ctx ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; pctx = cf-&gt;ctx; //父块&#123;&#125;的上下文ctx ctx-&gt;main_conf = pctx-&gt;main_conf; ctx-&gt;srv_conf = pctx-&gt;srv_conf; ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;loc_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; for (i = 0; ngx_modules[i]; i++) &#123; if (ngx_modules[i]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = ngx_modules[i]-&gt;ctx; if (module-&gt;create_loc_conf) &#123; /* 在解析if时， nginx会把它当做一个location来对待的，并且它的location type为noname。通过ngx_http_add_location将该“location”添 加到上层的locations中。这里将if看做location自然有它的合理性，因为if的配置也是需要进行url匹配的。 */ mconf = module-&gt;create_loc_conf(cf); if (mconf == NULL) &#123; return NGX_CONF_ERROR; &#125; ctx-&gt;loc_conf[ngx_modules[i]-&gt;ctx_index] = mconf; &#125; &#125; pclcf = pctx-&gt;loc_conf[ngx_http_core_module.ctx_index];//该if&#123;&#125;所在location&#123;&#125;的配置信息 clcf = ctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; //if&#123;&#125;的配置信息 clcf-&gt;loc_conf = ctx-&gt;loc_conf; clcf-&gt;name = pclcf-&gt;name; clcf-&gt;noname = 1; //if配置被作为location的noname形式 if (ngx_http_add_location(cf, &amp;pclcf-&gt;locations, clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (ngx_http_rewrite_if_condition(cf, lcf) != NGX_CONF_OK) &#123; return NGX_CONF_ERROR; &#125; if_code = ngx_array_push_n(lcf-&gt;codes, sizeof(ngx_http_script_if_code_t)); if (if_code == NULL) &#123; return NGX_CONF_ERROR; &#125; if_code-&gt;code = ngx_http_script_if_code; elts = lcf-&gt;codes-&gt;elts; /* the inner directives must be compiled to the same code array */ nlcf = ctx-&gt;loc_conf[ngx_http_rewrite_module.ctx_index]; nlcf-&gt;codes = lcf-&gt;codes; save = *cf; cf-&gt;ctx = ctx; if (pclcf-&gt;name.len == 0) &#123; if_code-&gt;loc_conf = NULL; cf-&gt;cmd_type = NGX_HTTP_SIF_CONF; &#125; else &#123; if_code-&gt;loc_conf = ctx-&gt;loc_conf; cf-&gt;cmd_type = NGX_HTTP_LIF_CONF; &#125; rv = ngx_conf_parse(cf, NULL); *cf = save; if (rv != NGX_CONF_OK) &#123; return rv; &#125; if (elts != lcf-&gt;codes-&gt;elts) &#123; if_code = (ngx_http_script_if_code_t *) ((u_char *) if_code + ((u_char *) lcf-&gt;codes-&gt;elts - elts)); &#125; if_code-&gt;next = (u_char *) lcf-&gt;codes-&gt;elts + lcf-&gt;codes-&gt;nelts - (u_char *) if_code; /* the code array belong to parent block */ nlcf-&gt;codes = NULL; return NGX_CONF_OK;&#125;2.5 set指令源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*Syntax: set $variable value1. 将$variable加入到变量系统中，cmcf-&gt;variables_keys-&gt;keys和cmcf-&gt;variables。a. 如果value是简单字符串，那么解析之后，lcf-&gt;codes就会追加这样的到后面: ngx_http_script_value_code 直接简单字符串指向一下就行，都不用拷贝了。b. 如果value是复杂的包含变量的串，那么lcf-&gt;codes就会追加如下的进去 : ngx_http_script_complex_value_code 调用lengths的lcode获取组合字符串的总长度，并且申请内存 lengths values，这里根据表达式的不同而不同。 分别将value代表的复杂表达式拆分成语法单元，进行一个个求值，并合并在一起。 ngx_http_script_set_var_code 负责将上述合并出的最终结果设置到variables[]数组中去。*/static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; ngx_int_t index; ngx_str_t *value; ngx_http_variable_t *v; ngx_http_script_var_code_t *vcode; ngx_http_script_var_handler_code_t *vhcode; value = cf-&gt;args-&gt;elts; if (value[1].data[0] != '$') &#123;//变量必须以$开头 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;value[1]); return NGX_CONF_ERROR; &#125; value[1].len--; value[1].data++; //下面根据这个变量名，将其加入到cmcf-&gt;variables_keys-&gt;keys里面。 v = ngx_http_add_variable(cf, &amp;value[1], NGX_HTTP_VAR_CHANGEABLE); if (v == NULL) &#123; return NGX_CONF_ERROR; &#125; //将其加入到cmcf-&gt;variables里面，并返回其下标 index = ngx_http_get_variable_index(cf, &amp;value[1]); if (index == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125; //set $variable value中的第一个参数$variable对应的在这里或者ngx_http_variables_init_vars设置ngx_http_variable_t的get_handler和data成员 if (v-&gt;get_handler == NULL &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"http_\", 5) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"sent_http_\", 10) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"upstream_http_\", 14) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"cookie_\", 7) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"upstream_cookie_\", 16) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"arg_\", 4) != 0) //如果变量名称不是以上开头，则其get_handler为ngx_http_rewrite_var，data为index 。 &#123; //设置一个默认的handler。在ngx_http_variables_init_vars里面其实是会将上面这些\"http_\" \"sent_http_\"这些变量get_hendler的 v-&gt;get_handler = ngx_http_rewrite_var; v-&gt;data = index; &#125;/* 脚本引擎是一系列的凹调函数以及相关数据（它们被组织成ngx_httpscript_ xxx_codet这样的结构体，代表各种不同功能的操作步骤），被保存在变量lcf-&gt;codes数组内，而ngx_httprewrite_loc_conf_t类型变量Icf是与当前location相关联的，所以这个脚本引擎只有当客户端请求访问当前这个location时才会被启动执行。如下配置中，“set $file t_a;”构建的脚本引擎只有当客户端请求访问/t日录时才会被触发，如果当客户端请求访问根目录时则与它毫无关系。 location / &#123; root web; &#125; location /t &#123; set $file t_a; &#125;*/ //ngx_http_rewrite_handler中会移除执行lcf-&gt;codes数组中的各个ngx_http_script_xxx_code_t-&gt;code函数， //set $variable value的value参数在这里处理 , /* 从下面可以看出没set一次就会创建一个ngx_http_script_var_code_t和ngx_http_script_xxx_value_code_t但是如果连续多次设置同样的 变量不同的值，那么就会有多个var_code_t和value_code_t对，实际上在ngx_http_rewrite_handler变量执行的时候，以最后面的为准，例如: 50： location / &#123; 51： root web; 52: set $file indexl.html; 53： index $file; 54： 65: set $file index2.html; &#125; 上面的例子追踪访问到的是index2.html */ /* 如果set $variable value中的value是普通字符串，则下面的ngx_http_rewrite_value从ngx_http_rewrite_loc_conf_t-&gt;codes数组中获取ngx_http_script_value_code_t空间，紧接着在后面的ngx_http_script_start_code函数同样从ngx_http_rewrite_loc_conf_t-&gt;codes数组中获取ngx_http_script_var_code_t空间，因此在codes数组中存放变量值value的ngx_http_script_value_code_t空间与存放var变量名的ngx_http_script_var_code_t在空间上是靠着的，图形化见&lt;深入剖析nginx 图8-4&gt; 如果set $variable value中的value是变量名，则下面的ngx_http_rewrite_value从ngx_http_rewrite_loc_conf_t-&gt;codes数组中获取ngx_http_script_complex_value_code_t空间，紧接着在后面的 ngx_http_script_start_code函数同样从ngx_http_rewrite_loc_conf_t-&gt;codes数组中获取ngx_http_script_complex_value_code_t空间，因此在codes数组中 存放变量值value的ngx_http_script_value_code_t空间与存放var变量名的ngx_http_script_var_code_t在空间上是靠着的，图形化见&lt;深入剖析nginx 图8-4&gt; */// if (ngx_http_rewrite_value(cf, lcf, &amp;value[2]) != NGX_CONF_OK) &#123; return NGX_CONF_ERROR; &#125; if (v-&gt;set_handler) &#123; vhcode = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_var_handler_code_t)); if (vhcode == NULL) &#123; return NGX_CONF_ERROR; &#125; vhcode-&gt;code = ngx_http_script_var_set_handler_code; vhcode-&gt;handler = v-&gt;set_handler; vhcode-&gt;data = v-&gt;data; return NGX_CONF_OK; &#125; vcode = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_var_code_t)); if (vcode == NULL) &#123; return NGX_CONF_ERROR; &#125; vcode-&gt;code = ngx_http_script_set_var_code; vcode-&gt;index = (uintptr_t) index; return NGX_CONF_OK;&#125;3.总结","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的upstream模块","slug":"Nginx的upstream模块","date":"2019-07-16T14:58:54.000Z","updated":"2021-03-28T14:35:15.206Z","comments":true,"path":"2019/07/16/Nginx的upstream模块/","link":"","permalink":"https://weeweetan.github.io/2019/07/16/Nginx的upstream模块/","excerpt":"","text":"1.相关配置upstream模块的典型应用是反向代理，这里就以ngx_http_proxy_module模块为例。假定我们有如下这样的实例环境，客户端对服务器80端口的请求都被Nginx Proxy Server转发到另外两个真实的Nginx Web Server实例上进行处理（下图是实验环境，Web Server和Proxy Server都只是Nginx进程，并且运行在同一台服务器）：那么，Nginx Proxy Server的核心配置多半是这样：123456789101112131415161718 Filename : nginx.conf …http &#123; … upstream load_balance &#123; server localhost:8001; server localhost:8002; &#125; server &#123; listen 80; location / &#123; proxy_buffering off; proxy_pass http://load_balance; &#125; &#125; &#125;上面的proxy_buffering off;配置是为了禁用nginx反向代理的缓存功能，保证客户端的每次请求都被转发到后端真实服务器，以便我们每次跟踪分析的nginx执行流程更加简单且完整。而另外两个配置指令upstream和proxy_pass在此处显得更为重要，其中upstream配置指令的回调处理函数为ngx_http_upstream()，该函数除了申请内存、设置初始值等之外，最主要的动作就是切换配置上下文并调用ngx_conf_parse()函数继续进行配置解析：2.源码解析12345678Filename : ngx_http_upstream.c pcf = *cf; cf-&gt;ctx = ctx; cf-&gt;cmd_type = NGX_HTTP_UPS_CONF; rv = ngx_conf_parse(cf, NULL); … if (uscf-&gt;servers == NULL) &#123;进入到upstream配置块内，最主要的配置指令也就是server，其对应的处理函数为ngx_http_upstream_server()，对于每一个后端真实服务器，除了其uri地址外，还有诸如down、weight、max_fails、fail_timeout、backup这样的可选参数，所有这些都需要ngx_http_upstream_server()函数来处理。在ngx_http_upstream.c的第4173行下个断点，我们可以看到这里给出示例的解析结果：另外一个重要配置指令proxy_pass主要出现在location配置上下文中，而其对应的处理函数为ngx_http_proxy_pass()，抹去该函数内的众多细节，我们重点关注两个赋值语句：12345678Filename : ngx_http_proxy_module.c static char * ngx_http_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) &#123; … clcf-&gt;handler = ngx_http_proxy_handler; … plcf-&gt;upstream.upstream = ngx_http_upstream_add(cf, &amp;u, 0);上面片段代码里的第一个赋值语句给当前location的http处理设置回调函数，而第二个赋值语句则是查找（没有找到则会创建，比如如果配置文件中upstream指令出现在proxy_pass指令的后面）其对应的upstream配置，我们这里就一个名为load_balance的upstream，所以找到的配置就是它了：前面曾提到，Nginx将对客户端的http请求处理分为多个阶段，而其中有个NGX_HTTP_FIND_CONFIG_PHASE阶段主要就是做配置查找处理，如果当前请求location设置了upstream，即回调函数指针clcf-&gt;handler不为空，则表示对该location的请求需要后端真实服务器来处理：12345678910111213141516Filename : ngx_http_core_module.c ngx_int_t ngx_http_core_find_config_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph) &#123; … ngx_http_update_location_config(r); … void ngx_http_update_location_config(ngx_http_request_t *r) &#123; … if (clcf-&gt;handler) &#123; r-&gt;content_handler = clcf-&gt;handler; &#125; &#125;在其它有location更新的情况下，比如redirect重定向location或named命名location或if条件location等，此时也会调用ngx_http_update_location_config()函数进行location配置更新。我们知道upstream模块的主要功能是产生响应数据，虽然这些响应数据来自后端真实服务器，所以在NGX_HTTP_CONTENT_PHASE 阶段的checker函数ngx_http_core_content_phase()内，我们可以看到在r-&gt;content_handler不为空的情况下会优先对r-&gt;content_handler函数指针进行回调：123456789101112Filename : ngx_http_core_module.c ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph) &#123; … if (r-&gt;content_handler) &#123; r-&gt;write_event_handler = ngx_http_request_empty_handler; ngx_http_finalize_request(r, r-&gt;content_handler(r)); return NGX_OK; &#125; …如果r-&gt;content_handler不为空，即存在upstream，那么进入处理，注意第1397行直接返回NGX_OK，也即不再调用挂在该阶段的其它模块回调函数，所以说upstream模块的优先级是最高的。根据前面的回调赋值，调用r-&gt;content_handler()指针函数，实质上就是执行函数ngx_http_proxy_handler()，直到这里，我们才真正走进upstream代理模块的处理逻辑里。3.回调函数对于任何一个Upstream模块而言，最核心的实现主要是7个回调函数，upstream代理模块自然也不例外，它实现并注册了这7个回调函数：回调指针函数功能upstream代理模块create_request根据nginx与后端服务器通信协议（比如HTTP、Memcache），将客户端的HTTP请求信息转换为对应的发送到后端服务器的真实请求ngx_http_proxy_create_request 由于nginx与后端服务器通信协议也为HTTP，所以直接拷贝客户端的请求头、请求体（如果有）到变量r-&gt;upstream-&gt;request_bufs内。process_header根据nginx与后端服务器通信协议，将后端服务器返回的头部信息转换为对客户端响应的HTTP响应头。ngx_http_proxy_process_status_line 此时后端服务器返回的头部信息已经保存在变量r-&gt;upstream-&gt;buffer内，将这串字符串解析为HTTP响应头存储到变量r-&gt;upstream-&gt;headers_in内。input_filter_init根据前面获得的后端服务器返回的头部信息，为进一步处理后端服务器将返回的响应体做初始准备工作。ngx_http_proxy_input_filter_init 根据已解析的后端服务器返回的头部信息，设置需进一步处理的后端服务器将返回的响应体的长度，该值保存在变量r-&gt;upstream-&gt;length内。input_filter正式处理后端服务器返回的响应体ngx_http_proxy_non_buffered_copy_filter 本次收到的响应体数据长度为bytes，数据长度存储在r-&gt;upstream-&gt;buffer内，把它加入到r-&gt;upstream-&gt;out_bufs响应数据链等待发送给客户端。finalize_request正常结束与后端服务器的交互，比如剩余待取数据长度为0或读到EOF等，之后就会调用该函数。由于nginx会自动完成与后端服务器交互的清理工作，所以该函数一般仅做下日志，标识响应正常结束。ngx_http_proxy_finalize_request 记录一条日志，标识正常结束与后端服务器的交互，然后函数返回。reinit_request对交互重新初始化，比如当nginx发现一台后端服务器出错无法正常完成处理，需要尝试请求另一台后端服务器时就会调用该函数。ngx_http_proxy_reinit_request设置初始值，设置回调指针，处理比较简单。abort_request异常结束与后端服务器的交互后就会调用该函数。大部分情况下，该函数仅做下日志，标识响应异常结束。ngx_http_proxy_abort_request记录一条日志，标识异常结束与后端服务器的交互，然后函数返回。上表格中前面5个函数执行的先后次序如下图所示，由于在Client/Proxy/Server之间，一次请求/响应数据可以发送多次（下图中只画出一次就发送完毕的情况），所以下图中对应的函数也可能被执行多次，不过一般情况下，这5个函数执行的先后次序就是这样了。4.总结这些回调函数如何夹杂到nginx中被调用并不需要完全搞清楚，要写一个upstream模块，我们只要实现上面提到的这7个函数即可，当然，可以看到最主要的也就是create_request、process_header和input_filter这三个回调，它们实现从HTTP协议到Nginx与后端服务器之间交互协议的来回转换，使得在用户看来，他访问的就是一台功能完整的Web服务器，而也许事实上，显示在他面前的数据来自Memcache或别的什么服务器。参考文献：nginx核心讲解","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx缓存详解","slug":"Nginx缓存详解","date":"2019-06-27T12:56:57.000Z","updated":"2021-06-03T14:50:11.072Z","comments":true,"path":"2019/06/27/Nginx缓存详解/","link":"","permalink":"https://weeweetan.github.io/2019/06/27/Nginx缓存详解/","excerpt":"","text":"1. 相关配置1.1 配置指令Nginx缓存由proxy_cache_path指令开启1proxy_cache_path D:\\output levels=1:2 keys_zone=my_cache:10m max_size=2g inactive=60m use_temp_path=off;对于每个参数的具体含义可以参考nginx官方文档，对于缓存文件名则需要proxy_cache_key指令指定1proxy_cache my_cache;对于该指令的具体用法可以参考nginx官方文档1proxy_cache_valid 200 1h;需要注意的是，如果没有这条指令，nginx将不会缓存上游的数据。对于该指令的具体用法可以参考nginx官方文档2. 源码解析Nginx与文件缓存相关的代码在src/http/ngx_http_file_cache.c2.1 关键结构体与缓存相关的结构体有ngx_path_t、ngx_http_file_cache_sh_t、ngx_http_file_cache_s 、ngx_http_file_cache_node_t、 ngx_http_file_cache_header_t，来看看这几个结构体的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158typedef struct &#123; ngx_str_t name; size_t len; size_t level[3]; ngx_path_manager_pt manager; //决定是否启用cache manager进程 ngx_path_loader_pt loader; //决定是否启用cache loader进程 void *data; u_char *conf_file; //nginx配置文件路径 ngx_uint_t line;&#125; ngx_path_t;typedef struct &#123; ngx_rbtree_t rbtree; ngx_rbtree_node_t sentinel; ngx_queue_t queue; ngx_atomic_t cold; ngx_atomic_t loading; off_t size; ngx_uint_t count; ngx_uint_t watermark;&#125; ngx_http_file_cache_sh_t;struct ngx_http_file_cache_s &#123; ngx_http_file_cache_sh_t *sh; ngx_slab_pool_t *shpool; /* shpool是用于管理共享内存的 slab allocator ，所有缓存节点占用空间都由它进行分配 */ ngx_path_t *path; /* ngx_http_file_cache_set_slot中创建ngx_path_t空间 */ off_t max_size; //缓存目录能保存的缓存最大值 size_t bsize; time_t inactive; /* 触发LRU算法阈值 */ time_t fail_time; ngx_uint_t files; ngx_uint_t loader_files; /* 阈值，当load的文件个数大于这个值之后，load进程会短暂的休眠(时间位loader_sleep) */ ngx_msec_t last; ngx_msec_t loader_sleep; /* 阈值，执行一次缓存文件加载到共享内存后 , 进程的休眠时间 , 默认200 */ ngx_msec_t loader_threshold; ngx_uint_t manager_files; ngx_msec_t manager_sleep; /* 阈值，处理一定数量缓存结点后, 进程的休眠时间 , 默认200 */ ngx_msec_t manager_threshold; ngx_shm_zone_t *shm_zone; /* 共享内存区 */ ngx_uint_t use_temp_path; /* 是否使用临时目录 */ /* unsigned use_temp_path:1 */&#125;;typedef struct &#123; ngx_rbtree_node_t node; /* 缓存查询树的节点 */ ngx_queue_t queue; /* LRU页面置换算法 队列中的节点 */ u_char key[NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t)]; unsigned count:20; unsigned uses:10; //缓存使用次数 unsigned valid_msec:10; unsigned error:10; unsigned exists:1; unsigned updating:1; // 缓存分片更新标志位 unsigned deleting:1; // 缓存分片删除标志位 unsigned purged:1; /* 10 unused bits */ ngx_file_uniq_t uniq; time_t expire; //过期时间 time_t valid_sec; size_t body_start; off_t fs_size; ngx_msec_t lock_time;&#125; ngx_http_file_cache_node_t;//在写缓存文件时会将这个结构体写入typedef struct &#123; ngx_uint_t version; time_t valid_sec; time_t updating_sec; time_t error_sec; time_t last_modified; time_t date; uint32_t crc32; u_short valid_msec; u_short header_start; /* 缓存文件中http头开始的偏移 */ u_short body_start; u_char etag_len; u_char etag[NGX_HTTP_CACHE_ETAG_LEN]; u_char vary_len; u_char vary[NGX_HTTP_CACHE_VARY_LEN]; u_char variant[NGX_HTTP_CACHE_KEY_LEN];&#125; ngx_http_file_cache_header_t;struct ngx_http_cache_s &#123; ngx_file_t file; /* 缓存文件描述结构体 */ ngx_array_t keys; /* 存放proxy_cache_key指令的值 */ uint32_t crc32; u_char key[NGX_HTTP_CACHE_KEY_LEN]; /* 存放计算md5后的值 */ u_char main[NGX_HTTP_CACHE_KEY_LEN]; /* 跟key相同 */ ngx_file_uniq_t uniq; time_t valid_sec; time_t updating_sec; time_t error_sec; time_t last_modified; time_t date; ngx_str_t etag; ngx_str_t vary; u_char variant[NGX_HTTP_CACHE_KEY_LEN]; size_t header_start; /* http头在缓存中的偏移位置 */ size_t body_start; /* http响应体在缓存中的偏移位置 */ off_t length; /* 缓存文件的大小，见ngx_http_file_cache_open */ off_t fs_size; ngx_uint_t min_uses; ngx_uint_t error; ngx_uint_t valid_msec; ngx_uint_t vary_tag; ngx_buf_t *buf; /* 存储缓存文件头 */ ngx_http_file_cache_t *file_cache; ngx_http_file_cache_node_t *node; //ngx_http_file_cache_exists中创建空间和赋值#if (NGX_THREADS || NGX_COMPAT) ngx_thread_task_t *thread_task;#endif ngx_msec_t lock_timeout; ngx_msec_t lock_age; ngx_msec_t lock_time; ngx_msec_t wait_time; ngx_event_t wait_event; unsigned lock:1; unsigned waiting:1; unsigned updated:1; unsigned updating:1; unsigned exists:1; unsigned temp_file:1; unsigned purged:1; unsigned reading:1; unsigned secondary:1; unsigned background:1; unsigned stale_updating:1; unsigned stale_error:1;&#125;;部分字段含义见注释2.2 生成标记缓存文件的key生成标记缓存文件的key由ngx_http_file_cache_create_key函数实现，我们来看看具体实现12345678910111213141516171819202122232425262728293031323334353637voidngx_http_file_cache_create_key(ngx_http_request_t *r)&#123; size_t len; ngx_str_t *key; ngx_uint_t i; ngx_md5_t md5; ngx_http_cache_t *c; c = r-&gt;cache; len = 0; ngx_crc32_init(c-&gt;crc32); ngx_md5_init(&amp;md5); key = c-&gt;keys.elts; for (i = 0; i &lt; c-&gt;keys.nelts; i++) &#123; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http cache key: \\\"%V\\\"\", &amp;key[i]); len += key[i].len; ngx_crc32_update(&amp;c-&gt;crc32, key[i].data, key[i].len); ngx_md5_update(&amp;md5, key[i].data, key[i].len); &#125; c-&gt;header_start = sizeof(ngx_http_file_cache_header_t) + sizeof(ngx_http_file_cache_key) + len + 1; ngx_crc32_final(c-&gt;crc32); ngx_md5_final(c-&gt;key, &amp;md5); ngx_memcpy(c-&gt;main, c-&gt;key, NGX_HTTP_CACHE_KEY_LEN);&#125;该函数实现较简单，主要是计算proxy_cache_key指令值的md5值，并保存，然后初始化header_start成员的值，这个地方需要注意一下缓存文件头部信息[ngx_http_file_cache_header_t][“\\nKEY: “][orig_key][“\\n”][header][body]2.3 缓存文件名生成生成缓存文件名主要由ngx_http_file_cache_name实现，现在来看看源码1234567891011121314151617181920212223242526272829303132333435static ngx_int_tngx_http_file_cache_name(ngx_http_request_t *r, ngx_path_t *path)&#123; u_char *p; ngx_http_cache_t *c; c = r-&gt;cache; if (c-&gt;file.name.len) &#123; return NGX_OK; &#125; c-&gt;file.name.len = path-&gt;name.len + 1 + path-&gt;len + 2 * NGX_HTTP_CACHE_KEY_LEN; c-&gt;file.name.data = ngx_pnalloc(r-&gt;pool, c-&gt;file.name.len + 1); if (c-&gt;file.name.data == NULL) &#123; return NGX_ERROR; &#125; ngx_memcpy(c-&gt;file.name.data, path-&gt;name.data, path-&gt;name.len); p = c-&gt;file.name.data + path-&gt;name.len + 1 + path-&gt;len; p = ngx_hex_dump(p, c-&gt;key, NGX_HTTP_CACHE_KEY_LEN); *p = '\\0'; ngx_create_hashed_filename(path, c-&gt;file.name.data, c-&gt;file.name.len); ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"cache file: \\\"%s\\\"\", c-&gt;file.name.data); return NGX_OK;&#125;该函数首先判断当前缓存文件名是否已经生成成功，若已生成，则直接返回，代码如下：123if (c-&gt;file.name.len) &#123; return NGX_OK;&#125;接下来计算缓存文件名长度，其中path-&gt;name.len为proxy_cache_path指令第一个参数，path-&gt;len为levels长度，比如level=1:2则path-&gt;len为5，包含两个/，代码如下：12c-&gt;file.name.len = path-&gt;name.len + 1 + path-&gt;len + 2 * NGX_HTTP_CACHE_KEY_LEN;接着为缓存文件名申请内存，代码如下：1c-&gt;file.name.data = ngx_pnalloc(r-&gt;pool, c-&gt;file.name.len + 1);接着将proxy_cache_path指令设置的路径复制到c-&gt;file.name.data最前端，完成后c-&gt;file.name.data的值为:D:\\output,代码如下：1ngx_memcpy(c-&gt;file.name.data, path-&gt;name.data, path-&gt;name.len);接着将p指向c-&gt;file.name.data偏移 path-&gt;name.len + 1 + path-&gt;len的位置处，这样做的目的是准备生成32位长的md5文件名，并预留level设置的目录123p = c-&gt;file.name.data + path-&gt;name.len + 1 + path-&gt;len;p = ngx_hex_dump(p, c-&gt;key, NGX_HTTP_CACHE_KEY_LEN);*p = '\\0';这一步完成之后c-&gt;file.name.data的值为D:\\output屯屯屯md5(proxy_cache_key)调用ngx_create_hashed_filename函数补全第5步预留的level目录1ngx_create_hashed_filename(path, c-&gt;file.name.data, c-&gt;file.name.len);2.4 生成由levels参数指定的目录层级生成由levels参数指定的目录层级由ngx_create_hashed_filename实现，现在来看看源码1234567891011121314151617181920212223voidngx_create_hashed_filename(ngx_path_t *path, u_char *file, size_t len)&#123; size_t i, level; ngx_uint_t n; i = path-&gt;name.len + 1; file[path-&gt;name.len + path-&gt;len] = '/'; for (n = 0; n &lt; NGX_MAX_PATH_LEVEL; n++) &#123; level = path-&gt;level[n]; if (level == 0) &#123; break; &#125; len -= level; file[i - 1] = '/'; ngx_memcpy(&amp;file[i], &amp;file[len], level); i += level + 1; &#125;&#125;从上一节中我们知道参数file的值为D:\\output屯屯屯md5(proxy_cache_key)，该函数首先用一个变量i保存path长度加1，这个设计非常巧妙，在后续中会使用到，代码如下：1i = path-&gt;name.len + 1;接着修改file的值，在层级目录后添加一个反斜杠，修改后为D:\\output屯屯屯/md5(proxy_cache_key)1file[path-&gt;name.len + path-&gt;len] = '/';接下来进入一个for循环，填充file中的屯屯屯，在第一次循环中首先获取levels=1：2中的1，接着用变量len减去变量level，接着在output后添加一个’/‘，然后将file中从len位置复制1个字符到output/后，修改i的值；第二次循环，首先获取levels=1：2中的2，接着用len减去2，接着在第一次缓存复制的字符后添加一个’/‘，然后把file从len处复制2个字符到上一步的’/‘后，修改i的值；第三次跳出循环，至此填充完成，代码如下：123456789101112for (n = 0; n &lt; NGX_MAX_PATH_LEVEL; n++) &#123; level = path-&gt;level[n]; if (level == 0) &#123; break; &#125; len -= level; file[i - 1] = '/'; ngx_memcpy(&amp;file[i], &amp;file[len], level); i += level + 1;&#125;2.5 从红黑树中查找缓存节点缓存key跟缓存文件名生成好之后，紧接着根据生成好的key从红黑树中查找，若不存在则插入，找到则返回对应的缓存节点，这个功能由ngx_http_file_cache_exists函数实现，我们看看具体实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113static ngx_int_tngx_http_file_cache_exists(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)&#123; ngx_int_t rc; ngx_http_file_cache_node_t *fcn; ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); fcn = c-&gt;node;//后面没找到则会创建node节点 if (fcn == NULL) &#123; fcn = ngx_http_file_cache_lookup(cache, c-&gt;key); //以 c-&gt;key 为查找条件从缓存中查找缓存节点： &#125; if (fcn) &#123; //cache中存在该key ngx_queue_remove(&amp;fcn-&gt;queue); //该客户端在新建连接后，如果之前有缓存该文件，则c-&gt;node为NULL，表示这个连接请求第一次走到这里，有一个客户端在获取数据，如果在 //连接范围内(还没有断开连接)多次获取该缓存文件，则也只会加1，表示当前有多少个客户端连接在获取该缓存 if (c-&gt;node == NULL) &#123; //如果该请求第一次使用此缓存节点，则增加相关引用和使用次数 fcn-&gt;uses++; fcn-&gt;count++; &#125; if (fcn-&gt;error) &#123; if (fcn-&gt;valid_sec &lt; ngx_time()) &#123; goto renew; //缓存已过期 &#125; rc = NGX_OK; goto done; &#125; if (fcn-&gt;exists || fcn-&gt;uses &gt;= c-&gt;min_uses) &#123; //该请求的缓存已经存在，并且对该缓存的请求次数达到了最低要求次数min_uses //表示该缓存文件是否存在，Proxy_cache_min_uses 3，则第3次后开始获取后端数据，获取完毕后在ngx_http_file_cache_update中置1，但是只有在地4次请求的时候才会在ngx_http_file_cache_exists赋值为1 c-&gt;exists = fcn-&gt;exists; if (fcn-&gt;body_start) &#123; c-&gt;body_start = fcn-&gt;body_start; &#125; rc = NGX_OK; goto done; &#125; //例如配置Proxy_cache_min_uses 5，则需要客户端请求5才才能从缓存中取，如果现在只有4次，则都需要从后端获取数据 rc = NGX_AGAIN; goto done; &#125; //没找到，则在下面创建node节点，添加到ngx_http_file_cache_t-&gt;sh-&gt;rbtree红黑树中 fcn = ngx_slab_calloc_locked(cache-&gt;shpool, sizeof(ngx_http_file_cache_node_t)); if (fcn == NULL) &#123; ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); (void) ngx_http_file_cache_forced_expire(cache); ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); fcn = ngx_slab_calloc_locked(cache-&gt;shpool, sizeof(ngx_http_file_cache_node_t)); if (fcn == NULL) &#123; ngx_log_error(NGX_LOG_ALERT, ngx_cycle-&gt;log, 0, &quot;could not allocate node%s&quot;, cache-&gt;shpool-&gt;log_ctx); rc = NGX_ERROR; goto failed; &#125; &#125; ngx_memcpy((u_char *) &amp;fcn-&gt;node.key, c-&gt;key, sizeof(ngx_rbtree_key_t)); ngx_memcpy(fcn-&gt;key, &amp;c-&gt;key[sizeof(ngx_rbtree_key_t)], NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t)); ngx_rbtree_insert(&amp;cache-&gt;sh-&gt;rbtree, &amp;fcn-&gt;node); //把该节点添加到红黑树中 fcn-&gt;uses = 1; fcn-&gt;count = 1;renew: rc = NGX_DECLINED; //uri第一次请求的时候创建node节点，同时返回NGX_DECLINED。或者缓存过期需要把该节点相关信息恢复为默认值 fcn-&gt;valid_msec = 0; fcn-&gt;error = 0; fcn-&gt;exists = 0; fcn-&gt;valid_sec = 0; fcn-&gt;uniq = 0; fcn-&gt;body_start = 0; fcn-&gt;fs_size = 0;done: fcn-&gt;expire = ngx_time() + cache-&gt;inactive; ngx_queue_insert_head(&amp;cache-&gt;sh-&gt;queue, &amp;fcn-&gt;queue); //新创建的node节点添加到cache-&gt;sh-&gt;queue头部 c-&gt;uniq = fcn-&gt;uniq;//文件的uniq 赋值见ngx_http_file_cache_update c-&gt;error = fcn-&gt;error; c-&gt;node = fcn; //把新创建的fcn赋值给c-&gt;nodefailed: ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); return rc;&#125;2.6 打开缓存文件上一节中介绍了如何从红黑树中查找缓存节点，找到缓存节点之后，就要需要根据缓存节点中的缓存文件路径去打开缓存文件了，Nginx使用ngx_http_file_cache_open函数实现，接下来我们来看看实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137ngx_int_tngx_http_file_cache_open(ngx_http_request_t *r)&#123; ngx_int_t rc, rv; ngx_uint_t test; ngx_http_cache_t *c; ngx_pool_cleanup_t *cln; ngx_open_file_info_t of; ngx_http_file_cache_t *cache; ngx_http_core_loc_conf_t *clcf; c = r-&gt;cache; if (c-&gt;waiting) &#123; return NGX_AGAIN; &#125; if (c-&gt;reading) &#123; return ngx_http_file_cache_read(r, c); &#125; cache = c-&gt;file_cache; if (c-&gt;node == NULL) &#123; cln = ngx_pool_cleanup_add(r-&gt;pool, 0); if (cln == NULL) &#123; return NGX_ERROR; &#125; cln-&gt;handler = ngx_http_file_cache_cleanup; cln-&gt;data = c; &#125; rc = ngx_http_file_cache_exists(cache, c); ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http file cache exists: %i e:%d\", rc, c-&gt;exists); if (rc == NGX_ERROR) &#123; return rc; &#125; if (rc == NGX_AGAIN) &#123; return NGX_HTTP_CACHE_SCARCE; &#125; if (rc == NGX_OK) &#123; if (c-&gt;error) &#123; return c-&gt;error; &#125; c-&gt;temp_file = 1; test = c-&gt;exists ? 1 : 0; rv = NGX_DECLINED; &#125; else &#123; /* rc == NGX_DECLINED */ test = cache-&gt;sh-&gt;cold ? 1 : 0; if (c-&gt;min_uses &gt; 1) &#123; if (!test) &#123; return NGX_HTTP_CACHE_SCARCE; &#125; rv = NGX_HTTP_CACHE_SCARCE; &#125; else &#123; c-&gt;temp_file = 1; rv = NGX_DECLINED; &#125; &#125; if (ngx_http_file_cache_name(r, cache-&gt;path) != NGX_OK) &#123; return NGX_ERROR; &#125; if (!test) &#123; goto done; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); ngx_memzero(&amp;of, sizeof(ngx_open_file_info_t)); of.uniq = c-&gt;uniq; of.valid = clcf-&gt;open_file_cache_valid; of.min_uses = clcf-&gt;open_file_cache_min_uses; of.events = clcf-&gt;open_file_cache_events; of.directio = NGX_OPEN_FILE_DIRECTIO_OFF; of.read_ahead = clcf-&gt;read_ahead; if (ngx_open_cached_file(clcf-&gt;open_file_cache, &amp;c-&gt;file.name, &amp;of, r-&gt;pool) != NGX_OK) &#123; switch (of.err) &#123; case 0: return NGX_ERROR; case NGX_ENOENT: case NGX_ENOTDIR: goto done; default: ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, of.err, ngx_open_file_n \" \\\"%s\\\" failed\", c-&gt;file.name.data); return NGX_ERROR; &#125; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http file cache fd: %d\", of.fd); c-&gt;file.fd = of.fd; c-&gt;file.log = r-&gt;connection-&gt;log; c-&gt;uniq = of.uniq; c-&gt;length = of.size; c-&gt;fs_size = (of.fs_size + cache-&gt;bsize - 1) / cache-&gt;bsize; c-&gt;buf = ngx_create_temp_buf(r-&gt;pool, c-&gt;body_start); if (c-&gt;buf == NULL) &#123; return NGX_ERROR; &#125; return ngx_http_file_cache_read(r, c);done: if (rv == NGX_DECLINED) &#123; return ngx_http_file_cache_lock(r, c); &#125; return rv;&#125;2.7 读缓存文件若缓存文件存在，则会读取缓存文件头部，并根据读取出的头部信息进行下一步操作，nginx使用ngx_http_file_cache_read函数实现这个功能，我们来看一下具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144static ngx_int_tngx_http_file_cache_read(ngx_http_request_t *r, ngx_http_cache_t *c)&#123; u_char *p; time_t now; ssize_t n; ngx_str_t *key; ngx_int_t rc; ngx_uint_t i; ngx_http_file_cache_t *cache; ngx_http_file_cache_header_t *h; n = ngx_http_file_cache_aio_read(r, c); if (n &lt; 0) &#123; return n; &#125; //写缓冲区封装过程参考:ngx_http_upstream_process_header //缓存文件中前面部分格式:[ngx_http_file_cache_header_t][\"\\nKEY: \"][orig_key][\"\\n\"][header] if ((size_t) n &lt; c-&gt;header_start) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" is too small\", c-&gt;file.name.data); return NGX_DECLINED; &#125; h = (ngx_http_file_cache_header_t *) c-&gt;buf-&gt;pos; if (h-&gt;version != NGX_HTTP_CACHE_VERSION) &#123; ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" version mismatch\", c-&gt;file.name.data); return NGX_DECLINED; //如果返回这个NGX_DECLINED，会把cached置0，返回出去后只有从后端从新获取数据 &#125; if (h-&gt;crc32 != c-&gt;crc32 || (size_t) h-&gt;header_start != c-&gt;header_start) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" has md5 collision\", c-&gt;file.name.data); return NGX_DECLINED; &#125; p = c-&gt;buf-&gt;pos + sizeof(ngx_http_file_cache_header_t) + sizeof(ngx_http_file_cache_key); key = c-&gt;keys.elts; for (i = 0; i &lt; c-&gt;keys.nelts; i++) &#123; if (ngx_memcmp(p, key[i].data, key[i].len) != 0) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" has md5 collision\", c-&gt;file.name.data); return NGX_DECLINED; &#125; p += key[i].len; &#125; if ((size_t) h-&gt;body_start &gt; c-&gt;body_start) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" has too long header\", c-&gt;file.name.data); return NGX_DECLINED; &#125; if (h-&gt;vary_len &gt; NGX_HTTP_CACHE_VARY_LEN) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" has incorrect vary length\", c-&gt;file.name.data); return NGX_DECLINED; &#125; if (h-&gt;vary_len) &#123; ngx_http_file_cache_vary(r, h-&gt;vary, h-&gt;vary_len, c-&gt;variant); if (ngx_memcmp(c-&gt;variant, h-&gt;variant, NGX_HTTP_CACHE_KEY_LEN) != 0) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http file cache vary mismatch\"); return ngx_http_file_cache_reopen(r, c); &#125; &#125; c-&gt;buf-&gt;last += n; c-&gt;valid_sec = h-&gt;valid_sec; c-&gt;updating_sec = h-&gt;updating_sec; c-&gt;error_sec = h-&gt;error_sec; c-&gt;last_modified = h-&gt;last_modified; c-&gt;date = h-&gt;date; c-&gt;valid_msec = h-&gt;valid_msec; c-&gt;body_start = h-&gt;body_start; c-&gt;etag.len = h-&gt;etag_len; c-&gt;etag.data = h-&gt;etag; r-&gt;cached = 1; cache = c-&gt;file_cache; if (cache-&gt;sh-&gt;cold) &#123; ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); if (!c-&gt;node-&gt;exists) &#123; c-&gt;node-&gt;uses = 1; c-&gt;node-&gt;body_start = c-&gt;body_start; c-&gt;node-&gt;exists = 1; c-&gt;node-&gt;uniq = c-&gt;uniq; c-&gt;node-&gt;fs_size = c-&gt;fs_size; cache-&gt;sh-&gt;size += c-&gt;fs_size; &#125; ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); &#125; now = ngx_time(); if (c-&gt;valid_sec &lt; now) &#123; c-&gt;stale_updating = c-&gt;valid_sec + c-&gt;updating_sec &gt;= now; c-&gt;stale_error = c-&gt;valid_sec + c-&gt;error_sec &gt;= now; ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); if (c-&gt;node-&gt;updating) &#123; rc = NGX_HTTP_CACHE_UPDATING; &#125; else &#123; c-&gt;node-&gt;updating = 1; c-&gt;updating = 1; c-&gt;lock_time = c-&gt;node-&gt;lock_time; rc = NGX_HTTP_CACHE_STALE; &#125; ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http file cache expired: %i %T %T\", rc, c-&gt;valid_sec, now); return rc; &#125; return NGX_OK;&#125;调用ngx_http_file_cache_aio_read函数读取缓存文件，读取大小为c-&gt;header_start，读取完成后，对返回值进行校验，确定是否读取成功，代码如下：12345678910111213n = ngx_http_file_cache_aio_read(r, c);if (n &lt; 0) &#123; return n;&#125;if ((size_t) n &lt; c-&gt;header_start) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" is too small\", c-&gt;file.name.data); return NGX_DECLINED;&#125;取出缓存文件头部，并对其字段进行校验，封包过程参考ngx_http_file_cache_set_header函数123h = (ngx_http_file_cache_header_t *) c-&gt;buf-&gt;pos;使用读出的缓存文件头部，更新内存中缓存节点信息12345678910111213c-&gt;buf-&gt;last += n; //buf后续会被用来存放http头，所以这个地方移动last指针c-&gt;valid_sec = h-&gt;valid_sec;c-&gt;updating_sec = h-&gt;updating_sec;c-&gt;error_sec = h-&gt;error_sec;c-&gt;last_modified = h-&gt;last_modified;c-&gt;date = h-&gt;date;c-&gt;valid_msec = h-&gt;valid_msec;c-&gt;body_start = h-&gt;body_start;c-&gt;etag.len = h-&gt;etag_len;c-&gt;etag.data = h-&gt;etag;2.8 发送缓存若2.7节读取缓存文件成功，而且缓存校验也成功，则开始发送缓存内容，该功能由ngx_http_upstream_cache_send函数实现，接下来我们看看源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static ngx_int_tngx_http_upstream_cache_send(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; ngx_int_t rc; ngx_http_cache_t *c; r-&gt;cached = 1; c = r-&gt;cache; if (c-&gt;header_start == c-&gt;body_start) &#123; r-&gt;http_version = NGX_HTTP_VERSION_9; return ngx_http_cache_send(r); &#125; /* TODO: cache stack */ u-&gt;buffer = *c-&gt;buf; u-&gt;buffer.pos += c-&gt;header_start; ngx_memzero(&amp;u-&gt;headers_in, sizeof(ngx_http_upstream_headers_in_t)); u-&gt;headers_in.content_length_n = -1; u-&gt;headers_in.last_modified_time = -1; if (ngx_list_init(&amp;u-&gt;headers_in.headers, r-&gt;pool, 8, sizeof(ngx_table_elt_t)) != NGX_OK) &#123; return NGX_ERROR; &#125; if (ngx_list_init(&amp;u-&gt;headers_in.trailers, r-&gt;pool, 2, sizeof(ngx_table_elt_t)) != NGX_OK) &#123; return NGX_ERROR; &#125; rc = u-&gt;process_header(r); if (rc == NGX_OK) &#123; if (ngx_http_upstream_process_headers(r, u) != NGX_OK) &#123; return NGX_DONE; &#125; return ngx_http_cache_send(r); &#125; if (rc == NGX_ERROR) &#123; return NGX_ERROR; &#125; if (rc == NGX_AGAIN) &#123; rc = NGX_HTTP_UPSTREAM_INVALID_HEADER; &#125; /* rc == NGX_HTTP_UPSTREAM_INVALID_HEADER */ ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" contains invalid header\", c-&gt;file.name.data); /* TODO: delete file */ return rc;&#125;2.9 向上游回源若缓存不存在，nginx则向上游回源，那么整个流程就走到ngx_http_upstream_init_request函数的#if (NGX_HTTP_CACHE)块后，我们来看看其源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269static voidngx_http_upstream_init_request(ngx_http_request_t *r)&#123; ngx_str_t *host; ngx_uint_t i; ngx_resolver_ctx_t *ctx, temp; ngx_http_cleanup_t *cln; ngx_http_upstream_t *u; ngx_http_core_loc_conf_t *clcf; ngx_http_upstream_srv_conf_t *uscf, **uscfp; ngx_http_upstream_main_conf_t *umcf; if (r-&gt;aio) &#123; return; &#125; u = r-&gt;upstream;#if (NGX_HTTP_CACHE) if (u-&gt;conf-&gt;cache) &#123; ngx_int_t rc; rc = ngx_http_upstream_cache(r, u); if (rc == NGX_BUSY) &#123; r-&gt;write_event_handler = ngx_http_upstream_init_request; return; &#125; r-&gt;write_event_handler = ngx_http_request_empty_handler; if (rc == NGX_ERROR) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (rc == NGX_OK) &#123; rc = ngx_http_upstream_cache_send(r, u); if (rc == NGX_DONE) &#123; return; &#125; if (rc == NGX_HTTP_UPSTREAM_INVALID_HEADER) &#123; rc = NGX_DECLINED; r-&gt;cached = 0; u-&gt;buffer.start = NULL; u-&gt;cache_status = NGX_HTTP_CACHE_MISS; u-&gt;request_sent = 1; &#125; if (ngx_http_upstream_cache_background_update(r, u) != NGX_OK) &#123; rc = NGX_ERROR; &#125; &#125; if (rc != NGX_DECLINED) &#123; ngx_http_finalize_request(r, rc); return; &#125; &#125;#endif u-&gt;store = u-&gt;conf-&gt;store; /* *设置Nginx与下游客户端之间TCP连接的检查方法 *实际上，这两个方法都会通过ngx_http_upstream_check_broken_connection方法检查Nginx与下游的连接是否正常，如果出现错误，就会立即终止连接。 */ if (!u-&gt;store &amp;&amp; !r-&gt;post_action &amp;&amp; !u-&gt;conf-&gt;ignore_client_abort) &#123; //注意这时候的r还是客户端的连接，与上游服务器的连接r还没有建立 r-&gt;read_event_handler = ngx_http_upstream_rd_check_broken_connection; r-&gt;write_event_handler = ngx_http_upstream_wr_check_broken_connection; &#125; //有接收到客户端包体，则把包体结构赋值给u-&gt;request_bufs，在后面的if (u-&gt;create_request(r) != NGX_OK) &#123;会用到 if (r-&gt;request_body) &#123; u-&gt;request_bufs = r-&gt;request_body-&gt;bufs; &#125; if (u-&gt;create_request(r) != NGX_OK) &#123; //ngx_http_proxy_create_request ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ngx_http_upstream_set_local(r, u, u-&gt;conf-&gt;local) != NGX_OK) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (u-&gt;conf-&gt;socket_keepalive) &#123; u-&gt;peer.so_keepalive = 1; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); /* 初始化ngx_http_upstream_t结构中成员output向下游发送响应的方式 */ u-&gt;output.alignment = clcf-&gt;directio_alignment; u-&gt;output.pool = r-&gt;pool; u-&gt;output.bufs.num = 1; u-&gt;output.bufs.size = clcf-&gt;client_body_buffer_size; if (u-&gt;output.output_filter == NULL) &#123; u-&gt;output.output_filter = ngx_chain_writer; u-&gt;output.filter_ctx = &amp;u-&gt;writer; &#125; u-&gt;writer.pool = r-&gt;pool; /* 添加用于表示上游响应的状态，例如：错误编码、包体长度等 */ if (r-&gt;upstream_states == NULL) &#123; r-&gt;upstream_states = ngx_array_create(r-&gt;pool, 1, sizeof(ngx_http_upstream_state_t)); if (r-&gt;upstream_states == NULL) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; &#125; else &#123; u-&gt;state = ngx_array_push(r-&gt;upstream_states); if (u-&gt;state == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; ngx_memzero(u-&gt;state, sizeof(ngx_http_upstream_state_t)); &#125; cln = ngx_http_cleanup_add(r, 0); if (cln == NULL) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; cln-&gt;handler = ngx_http_upstream_cleanup; //当请求结束时，一定会调用ngx_http_upstream_cleanup方法 cln-&gt;data = r; u-&gt;cleanup = &amp;cln-&gt;handler; if (u-&gt;resolved == NULL) &#123; uscf = u-&gt;conf-&gt;upstream; &#125; else &#123;#if (NGX_HTTP_SSL) u-&gt;ssl_name = u-&gt;resolved-&gt;host;#endif host = &amp;u-&gt;resolved-&gt;host; umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module); uscfp = umcf-&gt;upstreams.elts; for (i = 0; i &lt; umcf-&gt;upstreams.nelts; i++) &#123; uscf = uscfp[i]; if (uscf-&gt;host.len == host-&gt;len &amp;&amp; ((uscf-&gt;port == 0 &amp;&amp; u-&gt;resolved-&gt;no_port) || uscf-&gt;port == u-&gt;resolved-&gt;port) &amp;&amp; ngx_strncasecmp(uscf-&gt;host.data, host-&gt;data, host-&gt;len) == 0) &#123; goto found; &#125; &#125; if (u-&gt;resolved-&gt;sockaddr) &#123; if (u-&gt;resolved-&gt;port == 0 &amp;&amp; u-&gt;resolved-&gt;sockaddr-&gt;sa_family != AF_UNIX) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"no port in upstream \\\"%V\\\"\", host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ngx_http_upstream_create_round_robin_peer(r, u-&gt;resolved) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; ngx_http_upstream_connect(r, u); return; &#125; if (u-&gt;resolved-&gt;port == 0) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"no port in upstream \\\"%V\\\"\", host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; temp.name = *host; // 初始化域名解析器 ctx = ngx_resolve_start(clcf-&gt;resolver, &amp;temp); if (ctx == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ctx == NGX_NO_RESOLVER) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"no resolver defined to resolve %V\", host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY); return; &#125; ctx-&gt;name = *host; ctx-&gt;handler = ngx_http_upstream_resolve_handler; //设置域名解析完成后的回调函数。 ctx-&gt;data = r; ctx-&gt;timeout = clcf-&gt;resolver_timeout; u-&gt;resolved-&gt;ctx = ctx; //开始域名解析，没有完成也会返回的。 if (ngx_resolve_name(ctx) != NGX_OK) &#123; u-&gt;resolved-&gt;ctx = NULL; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; return; // 域名还没有解析完成，则直接返回 &#125;found: if (uscf == NULL) &#123; ngx_log_error(NGX_LOG_ALERT, r-&gt;connection-&gt;log, 0, \"no upstream configuration\"); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; u-&gt;upstream = uscf;#if (NGX_HTTP_SSL) u-&gt;ssl_name = uscf-&gt;host;#endif if (uscf-&gt;peer.init(r, uscf) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; u-&gt;peer.start_time = ngx_current_msec; if (u-&gt;conf-&gt;next_upstream_tries &amp;&amp; u-&gt;peer.tries &gt; u-&gt;conf-&gt;next_upstream_tries) &#123; u-&gt;peer.tries = u-&gt;conf-&gt;next_upstream_tries; &#125; ngx_http_upstream_connect(r, u);&#125;2.10 接受上游返回的数据该功能由ngx_http_upstream_send_response函数实现，我们来看看源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343static voidngx_http_upstream_send_response(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; ssize_t n; ngx_int_t rc; ngx_event_pipe_t *p; ngx_connection_t *c; ngx_http_core_loc_conf_t *clcf; rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;post_action) &#123; ngx_http_upstream_finalize_request(r, u, rc); return; &#125; u-&gt;header_sent = 1; if (u-&gt;upgrade) &#123;#if (NGX_HTTP_CACHE) if (r-&gt;cache) &#123; ngx_http_file_cache_free(r-&gt;cache, u-&gt;pipe-&gt;temp_file); &#125;#endif ngx_http_upstream_upgrade(r, u); return; &#125; c = r-&gt;connection; if (r-&gt;header_only) &#123; if (!u-&gt;buffering) &#123; ngx_http_upstream_finalize_request(r, u, rc); return; &#125; if (!u-&gt;cacheable &amp;&amp; !u-&gt;store) &#123; ngx_http_upstream_finalize_request(r, u, rc); return; &#125; u-&gt;pipe-&gt;downstream_error = 1; &#125; if (r-&gt;request_body &amp;&amp; r-&gt;request_body-&gt;temp_file &amp;&amp; r == r-&gt;main &amp;&amp; !r-&gt;preserve_body &amp;&amp; !u-&gt;conf-&gt;preserve_output) &#123; ngx_pool_run_cleanup_file(r-&gt;pool, r-&gt;request_body-&gt;temp_file-&gt;file.fd); r-&gt;request_body-&gt;temp_file-&gt;file.fd = NGX_INVALID_FILE; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); if (!u-&gt;buffering) &#123;#if (NGX_HTTP_CACHE) if (r-&gt;cache) &#123; ngx_http_file_cache_free(r-&gt;cache, u-&gt;pipe-&gt;temp_file); &#125;#endif if (u-&gt;input_filter == NULL) &#123; u-&gt;input_filter_init = ngx_http_upstream_non_buffered_filter_init; u-&gt;input_filter = ngx_http_upstream_non_buffered_filter; u-&gt;input_filter_ctx = r; &#125; u-&gt;read_event_handler = ngx_http_upstream_process_non_buffered_upstream; r-&gt;write_event_handler = ngx_http_upstream_process_non_buffered_downstream; r-&gt;limit_rate = 0; if (u-&gt;input_filter_init(u-&gt;input_filter_ctx) == NGX_ERROR) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; if (clcf-&gt;tcp_nodelay &amp;&amp; ngx_tcp_nodelay(c) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; n = u-&gt;buffer.last - u-&gt;buffer.pos; if (n) &#123; u-&gt;buffer.last = u-&gt;buffer.pos; u-&gt;state-&gt;response_length += n; if (u-&gt;input_filter(u-&gt;input_filter_ctx, n) == NGX_ERROR) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; ngx_http_upstream_process_non_buffered_downstream(r); &#125; else &#123; u-&gt;buffer.pos = u-&gt;buffer.start; u-&gt;buffer.last = u-&gt;buffer.start; if (ngx_http_send_special(r, NGX_HTTP_FLUSH) == NGX_ERROR) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; if (u-&gt;peer.connection-&gt;read-&gt;ready || u-&gt;length == 0) &#123; ngx_http_upstream_process_non_buffered_upstream(r, u); &#125; &#125; return; &#125; /* TODO: preallocate event_pipe bufs, look \"Content-Length\" */#if (NGX_HTTP_CACHE) if (r-&gt;cache &amp;&amp; r-&gt;cache-&gt;file.fd != NGX_INVALID_FILE) &#123; ngx_pool_run_cleanup_file(r-&gt;pool, r-&gt;cache-&gt;file.fd); r-&gt;cache-&gt;file.fd = NGX_INVALID_FILE; &#125; switch (ngx_http_test_predicates(r, u-&gt;conf-&gt;no_cache)) &#123; case NGX_ERROR: ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; case NGX_DECLINED: u-&gt;cacheable = 0; break; default: /* NGX_OK */ if (u-&gt;cache_status == NGX_HTTP_CACHE_BYPASS) &#123; /* create cache if previously bypassed */ if (ngx_http_file_cache_create(r) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; &#125; break; &#125; if (u-&gt;cacheable) &#123; time_t now, valid; now = ngx_time(); valid = r-&gt;cache-&gt;valid_sec; if (valid == 0) &#123; valid = ngx_http_file_cache_valid(u-&gt;conf-&gt;cache_valid, u-&gt;headers_in.status_n); if (valid) &#123; r-&gt;cache-&gt;valid_sec = now + valid; &#125; &#125; //如果没有配置proxy_cache_valid，valid的值为0 if (valid) &#123; r-&gt;cache-&gt;date = now; r-&gt;cache-&gt;body_start = (u_short) (u-&gt;buffer.pos - u-&gt;buffer.start); if (u-&gt;headers_in.status_n == NGX_HTTP_OK || u-&gt;headers_in.status_n == NGX_HTTP_PARTIAL_CONTENT) &#123; r-&gt;cache-&gt;last_modified = u-&gt;headers_in.last_modified_time; if (u-&gt;headers_in.etag) &#123; r-&gt;cache-&gt;etag = u-&gt;headers_in.etag-&gt;value; &#125; else &#123; ngx_str_null(&amp;r-&gt;cache-&gt;etag); &#125; &#125; else &#123; r-&gt;cache-&gt;last_modified = -1; ngx_str_null(&amp;r-&gt;cache-&gt;etag); &#125; if (ngx_http_file_cache_set_header(r, u-&gt;buffer.start) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; &#125; else &#123; u-&gt;cacheable = 0; &#125; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, \"http cacheable: %d\", u-&gt;cacheable); if (u-&gt;cacheable == 0 &amp;&amp; r-&gt;cache) &#123; ngx_http_file_cache_free(r-&gt;cache, u-&gt;pipe-&gt;temp_file); &#125; if (r-&gt;header_only &amp;&amp; !u-&gt;cacheable &amp;&amp; !u-&gt;store) &#123; ngx_http_upstream_finalize_request(r, u, 0); return; &#125;#endif p = u-&gt;pipe; p-&gt;output_filter = ngx_http_upstream_output_filter; p-&gt;output_ctx = r; p-&gt;tag = u-&gt;output.tag; p-&gt;bufs = u-&gt;conf-&gt;bufs; p-&gt;busy_size = u-&gt;conf-&gt;busy_buffers_size; p-&gt;upstream = u-&gt;peer.connection; p-&gt;downstream = c; p-&gt;pool = r-&gt;pool; p-&gt;log = c-&gt;log; p-&gt;limit_rate = u-&gt;conf-&gt;limit_rate; p-&gt;start_sec = ngx_time(); p-&gt;cacheable = u-&gt;cacheable || u-&gt;store; p-&gt;temp_file = ngx_pcalloc(r-&gt;pool, sizeof(ngx_temp_file_t)); if (p-&gt;temp_file == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; p-&gt;temp_file-&gt;file.fd = NGX_INVALID_FILE; p-&gt;temp_file-&gt;file.log = c-&gt;log; p-&gt;temp_file-&gt;path = u-&gt;conf-&gt;temp_path; //u-&gt;conf-&gt;temp_path的值在ngx_http_proxy_handler函数中赋值，赋值流程为ngx_http_proxy_merge_loc_conf-&gt;ngx_conf_merge_path_value p-&gt;temp_file-&gt;pool = r-&gt;pool; if (p-&gt;cacheable) &#123; p-&gt;temp_file-&gt;persistent = 1;#if (NGX_HTTP_CACHE) if (r-&gt;cache &amp;&amp; !r-&gt;cache-&gt;file_cache-&gt;use_temp_path) &#123; p-&gt;temp_file-&gt;path = r-&gt;cache-&gt;file_cache-&gt;path; p-&gt;temp_file-&gt;file.name = r-&gt;cache-&gt;file.name; &#125;#endif &#125; else &#123; p-&gt;temp_file-&gt;log_level = NGX_LOG_WARN; p-&gt;temp_file-&gt;warn = \"an upstream response is buffered \" \"to a temporary file\"; &#125; p-&gt;max_temp_file_size = u-&gt;conf-&gt;max_temp_file_size; p-&gt;temp_file_write_size = u-&gt;conf-&gt;temp_file_write_size;#if (NGX_THREADS) if (clcf-&gt;aio == NGX_HTTP_AIO_THREADS &amp;&amp; clcf-&gt;aio_write) &#123; p-&gt;thread_handler = ngx_http_upstream_thread_handler; p-&gt;thread_ctx = r; &#125;#endif p-&gt;preread_bufs = ngx_alloc_chain_link(r-&gt;pool); if (p-&gt;preread_bufs == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; p-&gt;preread_bufs-&gt;buf = &amp;u-&gt;buffer; p-&gt;preread_bufs-&gt;next = NULL; u-&gt;buffer.recycled = 1; p-&gt;preread_size = u-&gt;buffer.last - u-&gt;buffer.pos; if (u-&gt;cacheable) &#123; p-&gt;buf_to_file = ngx_calloc_buf(r-&gt;pool); if (p-&gt;buf_to_file == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; p-&gt;buf_to_file-&gt;start = u-&gt;buffer.start; p-&gt;buf_to_file-&gt;pos = u-&gt;buffer.start; p-&gt;buf_to_file-&gt;last = u-&gt;buffer.pos; p-&gt;buf_to_file-&gt;temporary = 1; &#125; if (ngx_event_flags &amp; NGX_USE_IOCP_EVENT) &#123; /* the posted aio operation may corrupt a shadow buffer */ p-&gt;single_buf = 1; &#125; /* TODO: p-&gt;free_bufs = 0 if use ngx_create_chain_of_bufs() */ p-&gt;free_bufs = 1; /* * event_pipe would do u-&gt;buffer.last += p-&gt;preread_size * as though these bytes were read */ u-&gt;buffer.last = u-&gt;buffer.pos; if (u-&gt;conf-&gt;cyclic_temp_file) &#123; /* * we need to disable the use of sendfile() if we use cyclic temp file * because the writing a new data may interfere with sendfile() * that uses the same kernel file pages (at least on FreeBSD) */ p-&gt;cyclic_temp_file = 1; c-&gt;sendfile = 0; &#125; else &#123; p-&gt;cyclic_temp_file = 0; &#125; p-&gt;read_timeout = u-&gt;conf-&gt;read_timeout; p-&gt;send_timeout = clcf-&gt;send_timeout; p-&gt;send_lowat = clcf-&gt;send_lowat; p-&gt;length = -1; if (u-&gt;input_filter_init &amp;&amp; u-&gt;input_filter_init(p-&gt;input_ctx) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; u-&gt;read_event_handler = ngx_http_upstream_process_upstream; r-&gt;write_event_handler = ngx_http_upstream_process_downstream; ngx_http_upstream_process_upstream(r, u);&#125;读取数据的具体操作在ngx_http_upstream_process_upstream函数中实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546static voidngx_http_upstream_process_upstream(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; ngx_event_t *rev; ngx_event_pipe_t *p; ngx_connection_t *c; c = u-&gt;peer.connection; p = u-&gt;pipe; rev = c-&gt;read; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, \"http upstream process upstream\"); c-&gt;log-&gt;action = \"reading upstream\"; if (rev-&gt;timedout) &#123; p-&gt;upstream_error = 1; ngx_connection_error(c, NGX_ETIMEDOUT, \"upstream timed out\"); &#125; else &#123; //请求没有超时，那么对后端，处理一下读事件。ngx_event_pipe开始处理 if (rev-&gt;delayed) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, \"http upstream delayed\"); if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); &#125; return; &#125; if (ngx_event_pipe(p, 0) == NGX_ABORT) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; &#125; //注意走到这里的时候，后端发送的头部行信息已经在前面的ngx_http_upstream_send_response-&gt;ngx_http_send_header已经把头部行部分发送给客户端了 //该函数处理的只是后端放回过来的网页包体部分 ngx_http_upstream_process_request(r, u);&#125;接下来分析一下ngx_event_pipe这个函数，在有buffering的时候，使用event_pipe进行数据的转发，调用ngx_event_pipe_write_to_downstream函数读取数据，或者发送数据给客户端。ngx_event_pipe将upstream响应发送回客户端。do_write代表是否要往客户端发送，写数据。如果设置了，那么会先发给客户端，再读upstream数据，当然，如果读取了数据，也会调用这里的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677ngx_int_tngx_event_pipe(ngx_event_pipe_t *p, ngx_int_t do_write)&#123; ngx_int_t rc; ngx_uint_t flags; ngx_event_t *rev, *wev; for ( ;; ) &#123; if (do_write) &#123; p-&gt;log-&gt;action = \"sending to client\"; rc = ngx_event_pipe_write_to_downstream(p); if (rc == NGX_ABORT) &#123; return NGX_ABORT; &#125; if (rc == NGX_BUSY) &#123; return NGX_OK; &#125; &#125; p-&gt;read = 0; p-&gt;upstream_blocked = 0; p-&gt;log-&gt;action = \"reading upstream\"; if (ngx_event_pipe_read_upstream(p) == NGX_ABORT) &#123; return NGX_ABORT; &#125; if (!p-&gt;read &amp;&amp; !p-&gt;upstream_blocked) &#123; break; &#125; do_write = 1; &#125; if (p-&gt;upstream-&gt;fd != (ngx_socket_t) -1) &#123; rev = p-&gt;upstream-&gt;read; flags = (rev-&gt;eof || rev-&gt;error) ? NGX_CLOSE_EVENT : 0; if (ngx_handle_read_event(rev, flags) != NGX_OK) &#123; return NGX_ABORT; &#125; if (!rev-&gt;delayed) &#123; if (rev-&gt;active &amp;&amp; !rev-&gt;ready) &#123; ngx_add_timer(rev, p-&gt;read_timeout); &#125; else if (rev-&gt;timer_set) &#123; ngx_del_timer(rev); &#125; &#125; &#125; if (p-&gt;downstream-&gt;fd != (ngx_socket_t) -1 &amp;&amp; p-&gt;downstream-&gt;data == p-&gt;output_ctx) &#123; wev = p-&gt;downstream-&gt;write; if (ngx_handle_write_event(wev, p-&gt;send_lowat) != NGX_OK) &#123; return NGX_ABORT; &#125; if (!wev-&gt;delayed) &#123; if (wev-&gt;active &amp;&amp; !wev-&gt;ready) &#123; ngx_add_timer(wev, p-&gt;send_timeout); &#125; else if (wev-&gt;timer_set) &#123; ngx_del_timer(wev); &#125; &#125; &#125; return NGX_OK;&#125;这个函数中最重要的就是ngx_event_pipe_write_to_downstream跟ngx_event_pipe_read_upstream，这两个函数将处理来自上游的数据以及将数据转发到客户端。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx反向代理详解","slug":"Nginx反向代理详解","date":"2019-06-17T12:59:19.000Z","updated":"2021-05-18T13:56:28.100Z","comments":true,"path":"2019/06/17/Nginx反向代理详解/","link":"","permalink":"https://weeweetan.github.io/2019/06/17/Nginx反向代理详解/","excerpt":"","text":"1. 相关配置Nginx实现反向代理功能主要由proxy_pass、upstream指令实现，配置指令如下：1234567891011121314151617http &#123; ... upstream proxy &#123; server 127.0.0.1:8080 &#125; ... server &#123; ... location / &#123; proxy_pass http://proxy &#125; ... &#125;&#125;具体配置可以参考ngx_http_proxy_module2. 源码解析Nginx实现反向代理功能的源码在src/http/modules/ngx_http_proxy_module.c，因为反向代理模块是一种upstream模块，所以还有一些基础代码在src/http/ngx_http_upstream.c中2.1 入口函数反向代理模块的入口函数是ngx_http_proxy_handler，我们看一下源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static ngx_int_tngx_http_proxy_handler(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_http_upstream_t *u; ngx_http_proxy_ctx_t *ctx; ngx_http_proxy_loc_conf_t *plcf;#if (NGX_HTTP_CACHE) ngx_http_proxy_main_conf_t *pmcf;#endif if (ngx_http_upstream_create(r) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_proxy_ctx_t)); if (ctx == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; ngx_http_set_ctx(r, ctx, ngx_http_proxy_module); plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module); u = r-&gt;upstream; if (plcf-&gt;proxy_lengths == NULL) &#123; ctx-&gt;vars = plcf-&gt;vars; u-&gt;schema = plcf-&gt;vars.schema;#if (NGX_HTTP_SSL) u-&gt;ssl = (plcf-&gt;upstream.ssl != NULL);#endif &#125; else &#123; if (ngx_http_proxy_eval(r, ctx, plcf) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; &#125; u-&gt;output.tag = (ngx_buf_tag_t) &amp;ngx_http_proxy_module; u-&gt;conf = &amp;plcf-&gt;upstream;#if (NGX_HTTP_CACHE) pmcf = ngx_http_get_module_main_conf(r, ngx_http_proxy_module); u-&gt;caches = &amp;pmcf-&gt;caches; u-&gt;create_key = ngx_http_proxy_create_key;#endif u-&gt;create_request = ngx_http_proxy_create_request; u-&gt;reinit_request = ngx_http_proxy_reinit_request; u-&gt;process_header = ngx_http_proxy_process_status_line; u-&gt;abort_request = ngx_http_proxy_abort_request; u-&gt;finalize_request = ngx_http_proxy_finalize_request; r-&gt;state = 0; if (plcf-&gt;redirects) &#123; u-&gt;rewrite_redirect = ngx_http_proxy_rewrite_redirect; &#125; if (plcf-&gt;cookie_domains || plcf-&gt;cookie_paths) &#123; u-&gt;rewrite_cookie = ngx_http_proxy_rewrite_cookie; &#125; u-&gt;buffering = plcf-&gt;upstream.buffering; u-&gt;pipe = ngx_pcalloc(r-&gt;pool, sizeof(ngx_event_pipe_t)); if (u-&gt;pipe == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; u-&gt;pipe-&gt;input_filter = ngx_http_proxy_copy_filter; u-&gt;pipe-&gt;input_ctx = r; u-&gt;input_filter_init = ngx_http_proxy_input_filter_init; u-&gt;input_filter = ngx_http_proxy_non_buffered_copy_filter; u-&gt;input_filter_ctx = r; u-&gt;accel = 1; if (!plcf-&gt;upstream.request_buffering &amp;&amp; plcf-&gt;body_values == NULL &amp;&amp; plcf-&gt;upstream.pass_request_body &amp;&amp; (!r-&gt;headers_in.chunked || plcf-&gt;http_version == NGX_HTTP_VERSION_11)) &#123; r-&gt;request_body_no_buffering = 1; &#125; rc = ngx_http_read_client_request_body(r, ngx_http_upstream_init); if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; return NGX_DONE;&#125;该函数首先调用ngx_http_upstream_create函数从内存池中创建ngx_http_upstream_s结构体；123if (ngx_http_upstream_create(r) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR;&#125;接下来初始化ngx_http_upstream_s各成员，应当注意ngx_http_upstream_s结构体的几个回调函数，这个是实现反向代理的重要功能123456789101112131415161718192021222324252627282930u-&gt;create_request = ngx_http_proxy_create_request;u-&gt;reinit_request = ngx_http_proxy_reinit_request;u-&gt;process_header = ngx_http_proxy_process_status_line;u-&gt;abort_request = ngx_http_proxy_abort_request;u-&gt;finalize_request = ngx_http_proxy_finalize_request;r-&gt;state = 0; if (plcf-&gt;redirects) &#123; u-&gt;rewrite_redirect = ngx_http_proxy_rewrite_redirect;&#125; if (plcf-&gt;cookie_domains || plcf-&gt;cookie_paths) &#123; u-&gt;rewrite_cookie = ngx_http_proxy_rewrite_cookie;&#125; u-&gt;buffering = plcf-&gt;upstream.buffering; u-&gt;pipe = ngx_pcalloc(r-&gt;pool, sizeof(ngx_event_pipe_t));if (u-&gt;pipe == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR;&#125; u-&gt;pipe-&gt;input_filter = ngx_http_proxy_copy_filter;u-&gt;pipe-&gt;input_ctx = r; u-&gt;input_filter_init = ngx_http_proxy_input_filter_init;u-&gt;input_filter = ngx_http_proxy_non_buffered_copy_filter;u-&gt;input_filter_ctx = r; u-&gt;accel = 1;2.2 绑定入口函数nginx在解析配置文件时，遇到proxy_pass指令时将上述的入口函数绑定到content阶段的handler上，解析proxy_pass执行后的参数，确定上游服务器，那么当请求到达时，进入到入口函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124static char *ngx_http_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_proxy_loc_conf_t *plcf = conf; size_t add; u_short port; ngx_str_t *value, *url; ngx_url_t u; ngx_uint_t n; ngx_http_core_loc_conf_t *clcf; ngx_http_script_compile_t sc; if (plcf-&gt;upstream.upstream || plcf-&gt;proxy_lengths) &#123; return &quot;is duplicate&quot;; &#125; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_http_proxy_handler; if (clcf-&gt;name.len &amp;&amp; clcf-&gt;name.data[clcf-&gt;name.len - 1] == &apos;/&apos;) &#123; clcf-&gt;auto_redirect = 1; &#125; value = cf-&gt;args-&gt;elts; url = &amp;value[1]; // 计算变量数 n = ngx_http_script_variables_count(url); if (n) &#123; ngx_memzero(&amp;sc, sizeof(ngx_http_script_compile_t)); sc.cf = cf; sc.source = url; sc.lengths = &amp;plcf-&gt;proxy_lengths; sc.values = &amp;plcf-&gt;proxy_values; sc.variables = n; sc.complete_lengths = 1; sc.complete_values = 1; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125;#if (NGX_HTTP_SSL) plcf-&gt;ssl = 1;#endif return NGX_CONF_OK; &#125; if (ngx_strncasecmp(url-&gt;data, (u_char *) &quot;http://&quot;, 7) == 0) &#123; add = 7; port = 80; &#125; else if (ngx_strncasecmp(url-&gt;data, (u_char *) &quot;https://&quot;, 8) == 0) &#123;#if (NGX_HTTP_SSL) plcf-&gt;ssl = 1; add = 8; port = 443;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;https protocol requires SSL support&quot;); return NGX_CONF_ERROR;#endif &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid URL prefix&quot;); return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;u, sizeof(ngx_url_t)); u.url.len = url-&gt;len - add; u.url.data = url-&gt;data + add; u.default_port = port; u.uri_part = 1; u.no_resolve = 1; // 根据proxy_pass指令后面的值，查找upstream块 plcf-&gt;upstream.upstream = ngx_http_upstream_add(cf, &amp;u, 0); if (plcf-&gt;upstream.upstream == NULL) &#123; return NGX_CONF_ERROR; &#125; plcf-&gt;vars.schema.len = add; plcf-&gt;vars.schema.data = url-&gt;data; plcf-&gt;vars.key_start = plcf-&gt;vars.schema; ngx_http_proxy_set_vars(&amp;u, &amp;plcf-&gt;vars); plcf-&gt;location = clcf-&gt;name; if (clcf-&gt;named#if (NGX_PCRE) || clcf-&gt;regex#endif || clcf-&gt;noname) &#123; if (plcf-&gt;vars.uri.len) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;\\&quot;proxy_pass\\&quot; cannot have URI part in &quot; &quot;location given by regular expression, &quot; &quot;or inside named location, &quot; &quot;or inside \\&quot;if\\&quot; statement, &quot; &quot;or inside \\&quot;limit_except\\&quot; block&quot;); return NGX_CONF_ERROR; &#125; plcf-&gt;location.len = 0; &#125; plcf-&gt;url = *url; return NGX_CONF_OK;&#125;3. 注意事项对session的处理，nginx默认使用轮询，若某个IP的请求被代理到A上，这个IP的下一个请求可能会被代理到B上，这样就会有问题，可考虑使用ip hash","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx日志详解","slug":"Nginx日志详解","date":"2019-06-15T12:59:00.000Z","updated":"2019-08-07T03:10:04.761Z","comments":true,"path":"2019/06/15/Nginx日志详解/","link":"","permalink":"https://weeweetan.github.io/2019/06/15/Nginx日志详解/","excerpt":"","text":"1. 相关配置Nginx日志系统由两条指令开启error_log、access_log12345678error_log logs/error.log debug;http &#123; ... access_log logs/access.log main; ...&#125;具体配置可以参考error_log跟access_log2. 源码解析首先来看一下关于日志的几个宏定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546filename:log.h#if (NGX_HAVE_C99_VARIADIC_MACROS)#define NGX_HAVE_VARIADIC_MACROS 1#define ngx_log_error(level, log, ...) \\ if ((log)-&gt;log_level &gt;= level) ngx_log_error_core(level, log, __VA_ARGS__)void ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...);#define ngx_log_debug(level, log, ...) \\ if ((log)-&gt;log_level &amp; level) \\ ngx_log_error_core(NGX_LOG_DEBUG, log, __VA_ARGS__)/*********************************/#elif (NGX_HAVE_GCC_VARIADIC_MACROS)#define NGX_HAVE_VARIADIC_MACROS 1#define ngx_log_error(level, log, args...) \\ if ((log)-&gt;log_level &gt;= level) ngx_log_error_core(level, log, args)void ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...);#define ngx_log_debug(level, log, args...) \\ if ((log)-&gt;log_level &amp; level) \\ ngx_log_error_core(NGX_LOG_DEBUG, log, args)/*********************************/#else /* no variadic macros */#define NGX_HAVE_VARIADIC_MACROS 0void ngx_cdecl ngx_log_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...);void ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, va_list args);void ngx_cdecl ngx_log_debug_core(ngx_log_t *log, ngx_err_t err, const char *fmt, ...);#endif /* variadic macros */从上面的定义可以看出，实现日志功能的核心在于ngx_log_error_core函数，接下来我们就来看看这个函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#if (NGX_HAVE_VARIADIC_MACROS)voidngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...)#elsevoidngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, va_list args)#endif&#123;#if (NGX_HAVE_VARIADIC_MACROS) va_list args;#endif u_char *p, *last, *msg; ssize_t n; ngx_uint_t wrote_stderr, debug_connection; u_char errstr[NGX_MAX_ERROR_STR]; last = errstr + NGX_MAX_ERROR_STR; p = ngx_cpymem(errstr, ngx_cached_err_log_time.data, ngx_cached_err_log_time.len); p = ngx_slprintf(p, last, \" [%V] \", &amp;err_levels[level]); /* pid#tid */ p = ngx_slprintf(p, last, \"%P#\" NGX_TID_T_FMT \": \", ngx_log_pid, ngx_log_tid); if (log-&gt;connection) &#123; p = ngx_slprintf(p, last, \"*%uA \", log-&gt;connection); &#125; msg = p;#if (NGX_HAVE_VARIADIC_MACROS) va_start(args, fmt); p = ngx_vslprintf(p, last, fmt, args); va_end(args);#else p = ngx_vslprintf(p, last, fmt, args);#endif if (err) &#123; p = ngx_log_errno(p, last, err); &#125; if (level != NGX_LOG_DEBUG &amp;&amp; log-&gt;handler) &#123; p = log-&gt;handler(log, p, last - p); &#125; if (p &gt; last - NGX_LINEFEED_SIZE) &#123; p = last - NGX_LINEFEED_SIZE; &#125; ngx_linefeed(p); wrote_stderr = 0; debug_connection = (log-&gt;log_level &amp; NGX_LOG_DEBUG_CONNECTION) != 0; while (log) &#123; if (log-&gt;log_level &lt; level &amp;&amp; !debug_connection) &#123; break; &#125; if (log-&gt;writer) &#123; log-&gt;writer(log, level, errstr, p - errstr); goto next; &#125; if (ngx_time() == log-&gt;disk_full_time) &#123; /* * on FreeBSD writing to a full filesystem with enabled softupdates * may block process for much longer time than writing to non-full * filesystem, so we skip writing to a log for one second */ goto next; &#125; n = ngx_write_fd(log-&gt;file-&gt;fd, errstr, p - errstr); if (n == -1 &amp;&amp; ngx_errno == NGX_ENOSPC) &#123; log-&gt;disk_full_time = ngx_time(); &#125; if (log-&gt;file-&gt;fd == ngx_stderr) &#123; wrote_stderr = 1; &#125; next: log = log-&gt;next; &#125; if (!ngx_use_stderr || level &gt; NGX_LOG_WARN || wrote_stderr) &#123; return; &#125; msg -= (7 + err_levels[level].len + 3); (void) ngx_sprintf(msg, \"nginx: [%V] \", &amp;err_levels[level]); (void) ngx_write_console(ngx_stderr, msg, p - msg);&#125;从代码中可以看出，nginx的作者对于变参处理还是很细心的，把各种情况都考虑到了，在处理好变参定义之后，就开始初始化字符串格式：1234567891011121314p = ngx_cpymem(errstr, ngx_cached_err_log_time.data, ngx_cached_err_log_time.len);p = ngx_slprintf(p, last, &quot; [%V] &quot;, &amp;err_levels[level]);/* pid#tid */p = ngx_slprintf(p, last, &quot;%P#&quot; NGX_TID_T_FMT &quot;: &quot;, ngx_log_pid, ngx_log_tid);if (log-&gt;connection) &#123; p = ngx_slprintf(p, last, &quot;*%uA &quot;, log-&gt;connection);&#125;处理变参参数，将变参的值复制到日志串中：1234567891011#if (NGX_HAVE_VARIADIC_MACROS) va_start(args, fmt); p = ngx_vslprintf(p, last, fmt, args); va_end(args);#else p = ngx_vslprintf(p, last, fmt, args);#endif处理错误号跟换行：12345678910111213if (err) &#123; p = ngx_log_errno(p, last, err);&#125;if (level != NGX_LOG_DEBUG &amp;&amp; log-&gt;handler) &#123; p = log-&gt;handler(log, p, last - p);&#125;if (p &gt; last - NGX_LINEFEED_SIZE) &#123; p = last - NGX_LINEFEED_SIZE;&#125;ngx_linefeed(p);最后就是将日志串输出到文件或者标准错误流3. 总结","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx模块详解","slug":"Nginx模块详解","date":"2019-06-05T12:58:43.000Z","updated":"2019-07-20T03:15:19.597Z","comments":true,"path":"2019/06/05/Nginx模块详解/","link":"","permalink":"https://weeweetan.github.io/2019/06/05/Nginx模块详解/","excerpt":"","text":"1. Nginx模块综述nginx的模块非常之多，可以认为所有代码都是以模块的形式组织，这包括核心模块和功能模块，针对不同的应用场合，并非所有的功能模块都要被用到，附录A给出的是默认configure（即简单的http服务器应用）下被连接的模块，这里虽说是模块连接，但nginx不会像apache或lighttpd那样在编译时生成so动态库而在程序执行时再进行动态加载，nginx模块源文件会在生成nginx时就直接被编译到其二进制执行文件中，所以如果要选用不同的功能模块，必须对nginx做重新配置和编译。对于功能模块的选择，如果要修改默认值，需要在进行configure时进行指定，比如新增http_flv功能模块（默认是没有这个功能的，各个选项的默认值可以在文件auto/options内看到）：1[root@localhost nginx-1.2.0]# ./configure --with-http_flv_module执行后，生成的objs/ngx_modules.c文件内就包含有对ngx_http_flv_module模块的引用了，要再去掉http_flv功能模块，则需要重新configure，即不带–with-http_flv_module配置后再编译生成新的nginx执行程序。通过执行./configure –help，我们可以看到更多的配置选项。虽然Nginx模块有很多，并且每个模块实现的功能各不相同，但是根据模块的功能性质，可以将它们分为四个类别：1， handlers：处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。2， filters：对handlers产生的响应内容做各种过滤处理（即是增删改），比如模块ngx_http_not_modified_filter_module，对待响应内容进行过滤检测，如果通过时间戳判断出前后两次请求的响应内容没有发生任何改变，那么可以直接响应 “304 Not Modified”状态标识，让客户端使用缓存即可，而原本待发送的响应内容将被清除掉。3， upstream：如果存在后端真实服务器，nginx可利用upstream模块充当反向代理（Proxy）的角色，对客户端发起的请求只负责进行转发（当然也包括后端真实服务器响应的回转），比如ngx_http_proxy_module就为标准的代理模块。4， load-balance：在nginx充当中间代理时，由于后端真实服务器往往多于一个，对于某一次客户端的请求，如何选择对应的后端真实服务器来进行处理，这就有类似于ngx_http_upstream_ip_hash_module这样的模块来实现不同的负载均衡算法（Load Balance）。对于这几类模块，我们马上会分别进行详细介绍并分析各自典型代表模块，不过在此之前先从nginx模块源码上来进行直观认识。前面讲过nginx的所有代码都是以模块形式进行组织，而封装nginx模块的结构体为ngx_module_s，定义如下：1234567891011121314151617Filename : ngx_conf_file.hstruct ngx_module_s &#123; ngx_uint_t ctx_index; //当前模块在同类模块中的序号 ngx_uint_t index; //当前模块在所有模块中的序号 … ngx_uint_t version; //当前模块版本号 void *ctx; //指向当前模块特有的数据 ngx_command_t *commands; //指向当前模块配置项解析数组 ngx_uint_t type; //模块类型 //以下为模块回调函数，回调时机可根据函数名看出 ngx_int_t (*init_master)(ngx_log_t *log); …&#125;;Filename : ngx_core.htypedef struct ngx_module_s ngx_module_t;结构体ngx_module_s值得关注的几个字段分别为ctx、commands、type，其中commands字段表示当前模块可以解析的配置项目，这在配置文件解析一章做过详细描述；表示模块类型的type值只有5种可能的值，而同一类型模块的ctx指向的数据类型也相同：序号type值ctx指向数据类型1NGX_CORE_MODULEngx_core_module_t2NGX_EVENT_MODULEngx_event_module_t3NGX_CONF_MODULENULL4NGX_HTTP_MODULEngx_http_module_t5NGX_MAIL_MODULEngx_mail_module_t上表中第三列里的数据类型非常重要，它们的字段基本都是一些回调函数，这些回调函数会在其模块对应的配置文件解析过程前/中/后会适时的被调用，做一些内存准备、初始化、配置值检查、初始值填充与合并、回调函数挂载等初始工作，以ngx_http_core_module模块为例，该模块type类型为NGX_HTTP_MODULE，ctx指向的ngx_http_module_t结构体变量ngx_http_core_module_ctx：123456789101112131415Filename : ngx_http_core_module.cstatic ngx_http_module_t ngx_http_core_module_ctx = &#123; ngx_http_core_preconfiguration, /* preconfiguration */ NULL, /* postconfiguration */ ngx_http_core_create_main_conf, /* create main configuration */ ngx_http_core_init_main_conf, /* init main configuration */ ngx_http_core_create_srv_conf, /* create server configuration */ ngx_http_core_merge_srv_conf, /* merge server configuration */ ngx_http_core_create_loc_conf, /* create location configuration */ ngx_http_core_merge_loc_conf /* merge location configuration */&#125;;根据上面代码注释，可以很明显的看出各个回调函数的回调时机，比如函数ngx_http_core_preconfiguration()将在进行http块配置解析前被调用，所以在ngx_http_block()函数里可以看到这样的代码：12345678910111213141516171819Filename : ngx_http.cstatic char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)… if (module-&gt;preconfiguration) &#123; if (module-&gt;preconfiguration(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125;… rv = ngx_conf_parse(cf, NULL);… if (module-&gt;postconfiguration) &#123; if (module-&gt;postconfiguration(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125;…至于这些回调函数内的具体逻辑，如前所述一般是一些初始或默认值填充工作，但也有回调函数挂载的设置，比如ngx_http_static_module模块的postconfiguration字段回调函数ngx_http_static_init()就是将自己的处理函数ngx_http_static_handler()挂载在http处理状态机上，但总体来看这毕竟都只是一些简单的初始准备工作，值得一提的还有ngx_http_core_create_main_conf、ngx_http_core_create_srv_conf、ngx_http_core_create_loc_conf这三个回调函数用来创建存储位于http块、server块、location块配置项的内存。参考文献：nginx核心讲解","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Dos常用命令","slug":"Dos常用命令","date":"2019-05-26T05:56:27.000Z","updated":"2020-02-13T14:21:44.953Z","comments":true,"path":"2019/05/26/Dos常用命令/","link":"","permalink":"https://weeweetan.github.io/2019/05/26/Dos常用命令/","excerpt":"","text":"scsc命令可用于卸载windows服务，如下所示：sc delete serv 其中serv为服务名，可在服务中查看xcopyxcopy命令用于Dos下复制文件夹及子文件夹，如下所示：xcopy d:\\abc\\aaa\\*.* c:\\windows\\system /s 其中第一个参数是源位置，第二个参数是目标位置/s：复制目录和子目录，除了空的。taskkilltaskkill命令用于杀进程，可根据pid，也可根据进程名。taskkill /im nginx.exe /f taskkill /pid {pid}","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"Dos","slug":"Dos","permalink":"https://weeweetan.github.io/tags/Dos/"}]},{"title":"中国菜翻译方法","slug":"中国菜翻译方法","date":"2019-05-18T02:27:42.000Z","updated":"2019-05-18T02:32:50.166Z","comments":true,"path":"2019/05/18/中国菜翻译方法/","link":"","permalink":"https://weeweetan.github.io/2019/05/18/中国菜翻译方法/","excerpt":"","text":"以主料为主配料或配汁为辅的翻译原则菜肴的主料和配料主料（名称/形状）+ with + 配料如：松仁香菇 Chinese Mushrooms with Pine Nuts菜肴的主料和配汁主料 + with / in + 汤汁（Sauce）如：冰梅凉瓜 Bitter Melon in Plum Sauc以烹制方法为主原料为辅的翻译原则菜肴的做法和主料做法（动词过去分词）+ 主料（名称/形状）如：拌双耳 Tossed Black and White Fungus菜肴的做法、主料和汤汁做法(动词过去分词) + 主料（名称/形状）+ with / in + 汤汁如：京酱肉丝 Sautéed Shredded Pork in Sweet Bean Sauce以形状、口感为主原料为辅的翻译原则菜肴形状或口感以及主配料形状/口感 + 主料如：玉兔馒头 Rabbit-Shaped Mantou菜肴的做法、形状或口感、做法以及主配料做法（动词过去分词）+ 形状/口感 + 主料 + 配料如： 小炒黑山羊 Sautéed Sliced Lamb with Pepper and Parsley","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://weeweetan.github.io/tags/翻译/"}]},{"title":"C语言编程常见错误及技巧","slug":"C语言编程常见错误","date":"2019-05-17T15:21:03.000Z","updated":"2022-04-03T14:45:23.015Z","comments":true,"path":"2019/05/17/C语言编程常见错误/","link":"","permalink":"https://weeweetan.github.io/2019/05/17/C语言编程常见错误/","excerpt":"","text":"1. 使用close函数出现bad file descriptor错误出现这种错误一般是两次close导致，仔细检查代码，调用close关闭文件描述符后，应该将文件描述符置为0，避免重复调用close，切记切记。2. 守护程序闪退问题出现这个问题一般是两次释放同一块内存，仔细检查释放内存与指针赋值相关代码，释放内存后，应将指针置为NULL，避免重复调用close，切记切记。3. 四字节对齐4. 什么是四字节对齐现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。4.1 四字节对齐作用定义结构体成员时应当注意四字节对齐，保证内存利用最大化。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。5. 柔性数组定义结构体时，最后一个成员定义为struct test { int a; char b[0]; } b[0]就称为柔性数组，使用sizeof(struct test); 返回值为4，即b[0]不占用内存空间。6. 数字转字符C语言书籍上可能出现过如下代码将数字转为字符int a = 0; char b = a + &apos;0&apos;; 这个操作有局限性，当a的值超过9的时候就会得到你意向不到的结果，int a = 10; char b = a + &apos;0&apos;; 这个时候字符b的值为’:’7. fork函数注意事项fork函数用来产生一个子进程，而且会复制父进程的资源（包括打开的文件描述符，变量等），无论是在子进程还是父进程对打开的文件描述符都需要谨慎对待，调用close函数关闭文件描述符可能不会报错，但是删除文件的时候就会出问题。8. 变参宏定义C99定义了一种变参宏定义#define LOG(format, ...) fprintf(stdout, format, __VA_ARGS__) …表示可变参数列表，VA_ARGS在预处理中，会被实际的参数集（实参列表）所替换。同时gcc还支持带可以变参数名的方式（注意：VC不支持,即在vs环境下无法使用）：#define LOG(format, args...) fprintf(stdout, format, args) 同样，args在预处理过程中，会被实际的参数集所替换。其用法和上面的方式一样，只是参数的符号有变。9. 整数相除C语言中，两个int型相除只能得到int型，若结果分子小于分母，则结果为0。必要时，将分子或者分母强转为float型，则结果为float型。10. 屏蔽gcc编译函数未使用错误函数定义了未使用在visual studio中，不会报错，但是使用gcc编译时就要报错，如下所示：1warning: 'xxx_handler' defined but not used [-Wunused-function]这个时候需要添加一个编译标志如下1CFLAGS=\"$CFLAGS -Wno-unused-function\"添加上这个标志以后，就不会报错了，常见标志可以参考gcc官网，要特别注意的是no这个标志，如果编译出现其他类似错误，又不想改代码，就可以加对应的标志，不同版本的gcc对于同一份代码可能出现错误。11. 大端机与小端机所谓大端就是指高位值在内存中放低位地址，所谓小端是指低位值在内存中放低位地址。比如0x12345678在大端机上是12345678，在小端机上是78563412，而一个主机是大端还是小端要看cpu类型以及运行在上面的操作系统。同一款cpu在不同的操作系统使用的大小端情况是不同的。个人理解0x1234是我们的书写习惯，转成二进制就是‭0001001000110100‬，读数从右往左读，所以0100是低位值，0001是高位值，在计算机中，内存地址增长方向是从左到右，所以左边是低位地址，右边是高位地址，如果计算机的低位地址存的是书写习惯的高位值，那么就是小端机，大小端机对单字节没影响。12. 主机字节序与网络字节序主机字节序就是大端序与小端序，网络字节序与大端序相同。在编写网络相关代码时，需要使用函数转换字节序，比如htons,htonl,ntohs,ntohl。13. 管道管道是一种把两个进程之间的标准输入和标准输出连接起来的机制，从而提供一种让多个进程间通信的方法，pipe（无名管道）和fifo（命名管道）两种。管道为半双工通信方式，也就是说只能一端读，一端写。14. 隐式类型转换unsigned char类型变量左移8位，编译器会进行类型提升。15. 屏蔽格式转换错误ubuntu gcc编译报错：1format '%llu' excepts argument of type 'long long unsigned int', but argument 2 has type 'uint_64'[-Wformat=]解决方法：在编译时添加-Wformat=0","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"C","slug":"C","permalink":"https://weeweetan.github.io/tags/C/"}]},{"title":"Nginx学习笔记","slug":"Nginx学习笔记","date":"2019-05-08T02:49:55.000Z","updated":"2020-12-25T03:35:50.276Z","comments":true,"path":"2019/05/08/Nginx学习笔记/","link":"","permalink":"https://weeweetan.github.io/2019/05/08/Nginx学习笔记/","excerpt":"","text":"1. 编译步骤1.1 configure原理configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。1.2 auto脚本auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。1.2.1 auto/options脚本auto/options主是处理用户输入的configure选项，以及输出帮助信息等。auto/options的目的主要是处理用户选项，并由选项生成一些全局变量的值，这些值在其它文件中会用到。该文件也会输出configure的帮助信息。应当注意如下代码123for optiondo opt=\"$opt `echo $option | sed -e \\\"s/\\(--[^=]*=\\)\\(.* .*\\)/\\1'\\2'/\\\"`\"for后面可以省略要遍历的变量,这时,表示在遍历$@,即用户传入的所有变量组合1.2.2 auto/init脚本该文件的目录在于初始化一些临时文件的路径，检查echo的兼容性，并创建最原始的Makefile文件。淘宝Nginx开发从入门到精通注意：这里生成的Makefile文件与configure文件在同一目录，真正执行编译指令的Makefile在objs目录下1.2.3 auto/sources脚本该文件从文件名中就可以看出，它的主要功能是跟源文件相关的。它的主要作用是定义不同功能或系统所需要的文件的变量。根据功能，分为CORE/REGEX/EVENT/UNIX/FREEBSD/HTTP等。每一个功能将会由四个变量组成，”_MODULES”表示此功能相关的模块，最终会输出到ngx_modules.c文件中，即动态生成需要编译到nginx中的模块；”INCS”表示此功能依赖的源码目录，查找头文件的时候会用到，在编译选项中，会出现在”-I”中；”DEPS”显示指明在Makefile中需要依赖的文件名，即编译时，需要检查这些文件的更新时间；”SRCS”表示需要此功能编译需要的源文件。淘宝Nginx开发从入门到精通根据上面的描述，所以如果需要对nginx进行功能扩展，添加相应的C文件后，修改这个脚本就可以将自己的功能编译进nginx。2. 源码解析2.1 模块相关在ngx_module.h中引用了两个至关重要的外部变量12extern ngx_module_t *ngx_modules[];extern char *ngx_module_names[];ngx_modules跟ngx_module_names定义在ngx_modules.c中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用ngx_cycle_modules函数，原型如下：1ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle)此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下：main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules 2.2 数据结构2.2.1 ngx_str_tNginx开发从入门到精通已经对ngx_str_t的定义以及相关api进行了非常详细的讲解，以下为定义：1234typedef struct &#123; size_t len; u_char *data;&#125; ngx_str_t;注意事项：不要试图复制char *到data所指向的内存，可能导致coredump初始化相关api都是基于常量字符串，char *类型慎用如果非要复制char *到data所指向的内存，一定先分配内存2.2.2 ngx_array_tNginx开发从入门到精通已经对ngx_array_t的定义以及相关api进行了非常详细的讲解，以下为定义：12345678typedef struct ngx_array_s ngx_array_t;struct ngx_array_s &#123; void *elts; ngx_uint_t nelts; size_t size; ngx_uint_t nalloc; ngx_pool_t *pool;&#125;;注意事项如果使用ngx_array_t作为字符串容器，在调用ngx_array_create时，使用字符串长度最后一个参数ngx_array_push返回第n个元素首地址，要注意指针运算3. handler模块的编写步骤编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量：123static ngx_command_t ngx_http_module_name_commands[] = &#123;&#125;;static ngx_http_module_t ngx_http_module_name_module_ctx = &#123;&#125;;ngx_module_t ngx_http_module_name_module = &#123;&#125;;实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数：1static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)；编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数：1static ngx_int_t ngx_http_module_name_handler(ngx_http_request_t *r);3.1 模块编译对于开发一个模块，我们是需要把这个模块的C代码组织到一个目录里，同时需要编写一个config文件。这个config文件的内容就是告诉nginx的编译脚本，该如何进行编译。淘宝Nginx开发从入门到精通1234 ngx_addon_name=ngx_http_hello_moduleHTTP_MODULES=&quot;$HTTP_MODULES ngx_http_hello_module&quot;NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_hello_module.c&quot;执行如下命令进行编译1./configure –add-module=/home/jizhao/open_source/book_module 4. 部分功能简介4.1 日志系统Nginx的日志系统分为两个部分，一个是Nginx核心的错误日志（包括debug日志），一个是各模块的访问日志，整个Nginx框架中主要以核心的错误日志为主，各模块的访问日志根据模块调用顺序使用，下面分别介绍两种日志系统。4.1.1 错误日志关于错误日志的配置指令可以参考error_log，分析Nginx源码可以发现，源码中多处使用ngx_log_debug0，ngx_log_debug1等类似的宏定义，启用这些宏定义需要在configure的时候执行–with-debug。错误日志初始化分为两个阶段，一个是ngx_log_init函数中初始化日志对象，另外一个就是在解析配置文件的时候会新建一个日志对象。4.1.2 访问日志目前实现了访问日志的官方模块有http模块，stream模块，其中http模块的配置指令可以参考ngx_http_log_module。http模块的日志系统是以http第三方模块的形式存在，所以编写的时候遵循第3节的规则，Nginx将HTTP请求划分为11个阶段，访问日志是最后一个阶段，所以访问日志在HTTP请求完成时写入。4.2 upstream机制upstream机制使得nginx能够作为代理服务器，或者负载均衡服务器，将来自客户端的请求转发到上游，并将上游响应转发到客户端。参考配置如下#位于http上下文中 upstream local { server 127.0.0.1:8080 weight=5; server 127.0.0.1:80 weight=2; } 4.3 反向代理nginx反向代理实际上是一个upstream模块，实现upstream机制的几个回调函数。参考配置如下：location / { proxy_pass http://local } 5. 编码过程中遇到的问题5.1 使用ngx_sprintf遇到的问题ngx_sprintf函数用于向缓冲区中复制格式化字符串，跟标准C的sprintf函数一样，Nginx增加了一些格式，具体可以看ngx_string.c的源码，接下来结合代码说明一些问题：1234567 size_t a;off_t b;u_char c[20] = &#123;\"0\"&#125;;ngx_sprintf(c, \"a:%z,b:%O\", a, b); 上面这段代码是正确示范，若a也为off_t类型，在执行ngx_sprintf时一定要使用%O，否者b的值会受影响。6. 热更新6.1 热更新步骤替换nginx程序向master进程发送信号 kill -USR2 PID，启动新程序向旧master进程发送信号 kill -WINCH PID，告诉旧worker进程不再接受新请求结语此博文只粗略记录笔记，在后续会写详细的博客对nginx进行分析","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"libxml2使用心得","slug":"libxml2使用心得","date":"2019-05-04T14:21:35.000Z","updated":"2020-11-09T13:55:58.680Z","comments":true,"path":"2019/05/04/libxml2使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/05/04/libxml2使用心得/","excerpt":"","text":"背景由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考C++的XML编程经验――LIBXML2库使用指南，这篇博文讲得很详细，我在这里只是做出一点补充。1. 中文问题xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。1.1 举例说明我使用GLib2的g_locale_from_utf8将内容转换为本地程序默认的编码格式，在写入xml内容时使用g_locale_to_utf8将内容转换为UTF-8.1.2 总结总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。2. 设置文档编码问题","categories":[{"name":"libxml","slug":"libxml","permalink":"https://weeweetan.github.io/categories/libxml/"}],"tags":[{"name":"libxml","slug":"libxml","permalink":"https://weeweetan.github.io/tags/libxml/"}]},{"title":"GLib使用心得","slug":"GLib使用心得","date":"2019-04-28T05:51:59.000Z","updated":"2019-07-11T03:11:05.932Z","comments":true,"path":"2019/04/28/GLib使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/04/28/GLib使用心得/","excerpt":"","text":"前言关于GLib的介绍这里就不赘述了，具体API介绍可以去GLib API Reference查阅，这里只是记录一下使用相关API所遇到的一些坑。相关API字符串相关API12345 GString *g_string_new(const gchar *init);GString *g_string_append(GString *string, const gchar *val);GString *g_string_prepend(GString *string, const gchar *val);gchar *g_string_free(GString *string, gboolean free_segment);如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。注意 g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。g_string_append跟g_string_prepend都是直接在原字符串上操作，这点要切记。字符转换相关API123gchar *g_filename_display_basename(const gchar *filename);gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8下面看个例子, 比如我们有个含中文的文件名 /data/test/哈哈.txt如果想获得 哈哈.txt，则必须首先使用 g_locale_to_utf8函数转换一次, 然后再去获取basename123GString *string = g_string_new(\"/data/test/哈哈.txt\");gchar *str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL);gchar *basename = g_filename_display_basename(str);如果想使用GString 类型保存basename，则必须重新申请内存块1GString *basename_string = g_string_new(basename); 千万别像下面这样做12GString *string = g_string_new(\"/data/test/哈哈.txt\");string-&gt;str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); 如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，g_locale_from_utf8 同理注意 g_locale_to_utf8返回的char 需要手动释放内存解析key-value文件API12345GKeyFile *g_key_file_new(void);gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);void g_key_file_free(GKeyFile *key_file);这几个API很好理解,用来解析具有键值对特征的文件,g_key_file_new跟g_key_file_free配套使用;g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;","categories":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/categories/GLib/"}],"tags":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/tags/GLib/"}]},{"title":"调用glib库出现0xc000007b解决办法","slug":"调用glib库出现0xc000007b解决办法","date":"2019-04-18T14:47:29.000Z","updated":"2019-05-18T01:22:38.363Z","comments":true,"path":"2019/04/18/调用glib库出现0xc000007b解决办法/","link":"","permalink":"https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/","excerpt":"","text":"背景之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示：网上的解决办法都试过，没能解决问题。出现转机出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。开始分析我使用depends分析libglib-2.0.dll，结果如下图所示从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。1、网上下载libintl-8.dll2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下问题解决上述步骤完成之后，再次使用depends检查，如下图所示：程序也正常运行注意我这里只是说明解决问题的方法，图中dll版本问题自行忽略","categories":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/categories/GLib/"}],"tags":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/tags/GLib/"}]},{"title":"安装vCenter Server出现1603错误的一种解决方法","slug":"安装vCenter-Server出现1603错误的一种解决方法","date":"2018-11-29T02:04:37.000Z","updated":"2019-05-15T14:12:39.771Z","comments":true,"path":"2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/","link":"","permalink":"https://weeweetan.github.io/2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/","excerpt":"","text":"背景vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配置，导致vCenter Server相关服务无法启动，查找解决方法无果后，就打算重装vCenter Server。遇到的问题部署过程主要参考VMware Vsphere 6.0安装部署 （三） vCenter Server安装。在这里我主要说明一下我所遇到的问题以及解决方法。在安装过程中遇到Encountered an internal error，Install-parameter rhttpproxy.ext.port1 not set具体错误信息如下图所示：出现这个错误后，会退出安装，在最后会报‘安装组件VCSServiceManager失败并显示错误代码1603’，如下图所示：出现这个错误，首先应当排查在安装vCenter Server 过程中配置的http端口是否被占用(使用命令netstat -nao)，如果端口没有被占用，则使用如下方法：删除C:\\Program Files\\VMware\\vCenter Server目录；重启虚拟机，重新安装总结这个方法不一定能解决所有这类问题，这只是其中一种解决方法。","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"VMware虚拟机备份与恢复","slug":"VMware虚拟机备份与恢复","date":"2018-10-31T08:05:03.000Z","updated":"2019-06-03T14:12:21.114Z","comments":true,"path":"2018/10/31/VMware虚拟机备份与恢复/","link":"","permalink":"https://weeweetan.github.io/2018/10/31/VMware虚拟机备份与恢复/","excerpt":"","text":"前言本文主要是根据自己实际项目经验对云与备份之（1）：VMware虚机备份和恢复这篇文章进行补充说明。本文将以部分引用，部分说明的方式进行组织，加粗部分为我自己总结的内容。原文中提到两套SDK（vddk跟Web service SDK），整个虚拟机备份流程需要着两套SDK配合使用，我把这两套SDK整理了一下，使之能够在clion跟idea中运行，地址如下：VMwareProjectvix_disklib_sample1. 与备份有关的VMWare基础知识1.1 VMware 虚机磁盘在 ESXi 宿主机上的文件简单来说，虚机的每个虚拟磁盘由ESXi 宿主机上的三个文件组成（这里的虚机名字是 sammy-target-win-small，下面是其第一个磁盘对应的三个文件）：sammy-target-win-small.vmdk （配置文件，大小 633 字节）sammy-target-win-small-flat.vmdk （二进制文件，大小 12884901888 字节）sammy-target-win-small-ctk.vmdk （二进制文件，大小 78694 字节）其中，第一个文件保存的是该磁盘的元数据，其中包括另外两个文件的信息# Extent description RW 25165824 VMFS &quot;sammy-target-win-small-flat.vmdk&quot; # Change Tracking File changeTrackPath=&quot;sammy-target-win-small-ctk.vmdk&quot; 第二个文件是 Extent description 文件，二进制数据保存在这个文件中。下面会介绍使用API获取该文件中数据的方法。第三个文件是 CTK 文件。下面讲到 CTK 的时候再说。@刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)1.2 虚拟磁盘类型上一节中的磁盘组织形式并不是唯一的，早期版本的Esxi不是以这种方式组织。vddk文档中定义了8种磁盘类型，在创建虚拟磁盘时，使用不同磁盘类型，则虚拟磁盘的组织方式不同。8中磁盘类型如下：VIXDISKLIB_DISK_MONOLITHIC_SPARSE – Growable virtual disk contained in a single virtual disk file. This is the default type for hosted disk, and the only setting in the Virtual Disk API Sample Code sample program.VIXDISKLIB_DISK_MONOLITHIC_FLAT – Preallocated virtual disk contained in a single virtual disk file. This takes time to create and occupies a lot of space, but might perform better than sparse.VIXDISKLIB_DISK_SPLIT_SPARSE – Growable virtual disk split into 2GB extents ( s sequence). These files can to 2GB, then continue growing in a new extent. This type works on older file systems.VIXDISKLIB_DISK_SPLIT_FLAT – Preallocated virtual disk split into 2GB extents ( f sequence). These files start at 2GB, so they take a while to create, but available space can grow in 2GB increments.VIXDISKLIB_DISK_VMFS_FLAT – Preallocated virtual disk compatible with ESX 3 and later. Also known as thick disk. This managed disk type is discussed in Managed Disk and Hosted Disk.VIXDISKLIB_DISK_VMFS_SPARSE – Employs a copy-on-write (COW) mechanism to save storage space.VIXDISKLIB_DISK_VMFS_THIN – Growable virtual disk that consumes only as much space as needed, compatible with ESX 3 or later, supported by VDDK 1.1 or later, and highly recommended.VIXDISKLIB_DISK_STREAM_OPTIMIZED – Monolithic sparse format compressed for streaming. Stream optimized format does not support random reads or writes.只有vddk使用VIXDISKLIB_DISK_VMFS_FLAT类型创建虚拟磁盘时才会生成1.1节中所示的虚拟磁盘文件，使用Web Service SDK创建虚拟磁盘则不受此限制。1.3 虚拟磁盘模式虚拟磁盘模式分为持久跟非持久，以下为vddk中对持久的定义持久模式(persistent)：In persistent disk mode, changes are immediately and permanently written to the virtual disk, so that they survive even through to the next power on.非持久模式(nonpersistent)：In nonpersistent mode, changes to the virtual disk are discarded when the virtual machine powers off. The VMDK files revert to their original state.使用vSphere client创建虚拟磁盘跟vddk的选项可能会有区别独立持久：持久模式磁盘的行为与物理机上常规磁盘的行为相似。写入持久模式磁盘的所有数据都会永久性地写入磁盘。独立非持久：关闭虚拟机电源或重置虚拟机时，对非持久模式磁盘的更改将丢失。使用非持久模式，您可以每次使用相同的虚拟磁盘状态重新启动虚拟机。对磁盘的更改会写入重做日志文件并从中读取，重做日志文件会在关闭虚拟机电源或重置虚拟机时被删除。1.4 vCenter ServervCenter Server相当于一套管理多台Esxi服务器的系统，如果需要对虚拟机进行备份，则需要部署这么一套系统，具体怎么部署可以参考VMware Vsphere 6.0安装部署 （三） vCenter Server安装。备份所使用的Web serviceSDK依赖这套系统，对于这套系统的使用可以参考我其他关于vSphere的文章。1.5 vSphere Web ClientvSphere Web Client为vCenter Server提供一个web管理界面，文中关于对vCenter的操作都是在这界面上完成。1.5 虚拟机注册在vCenter Server中，Esxi服务器以及虚拟机以实体对象的形式存在，已有的虚拟机文件可以通过注册功能，将虚拟机文件激活成虚拟机，这里涉及到虚拟机的其他文件，可以参考什么是虚拟机?。在vCenter Server中将.vmx文件作为虚拟机，所以在vCenter Server中找到虚拟机文件，右键注册就可以了。2. 备份要点原文中对备份流程进行了详细说明，我这里就不再赘述，我将从以下几个方面说明备份要点。其中具体代码实现可以去我的csdn查看相关文章2.1 如何确定虚拟机对象？这个时候就需要使用Web service SDK去遍历vCenter Server中的虚拟机对象，并返回虚拟机的名称和在vCenter中的id，有了这两个变量，就可以确定虚拟机对象了。2.2 如何获取虚拟机相关配置？这一步中最重要的是拿到虚拟机磁盘对象，对虚拟机的备份，实际上是对虚拟磁盘的备份，这里还是使用Web ServiceSDk进行获取2.3 如何获取变化数据？原文中有提到一个API：QueryChangedDiskAreas获取 CBT 变化块的函数的定义为：QueryChangedDiskAreas(snapshot, deviceKey, startOffSet, changeID)。其中，snapshot 代表当前的快照，也就是“变化”时间段的后端点；deviceKey 是目标虚拟磁盘的 device ID；startOffSet 是开始获取变化块的offset；changeID 是指“变化”时间段的前端点，即老的快照的 changeID。其结果类似 “(117768192, 65536),(132120576, 65536),(145096704, 43122688),(265289728, 65536),(958398464, 65536)”，每项的格式为 （offset，length），表示一个发生变化的数据块。@刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)使用QueryChangedDiskAreas获取到变化数据后，需要将这些数据保存下来，以供后续使用。2.4 如何下载变化数据？这个时候就需要vddk，vddk可以连接到远程的虚拟磁盘，并根据上一节保存的数据，将虚拟磁盘中的变化数据读取并保存下来，以供恢复使用。3. 恢复要点3.1 完全恢复如果在完全备份的时候采用文件下载的形式进行备份，则在恢复的时候就可以直接将文件上传至vCenter Server然后注册虚拟机就可以了。如果备份的时候只备份了虚拟磁盘，则在恢复的时候需要使用Web Service SDK创建虚拟机，再将磁盘数据写入到新建的虚拟机中。3.2 增量恢复增量恢复以完全恢复为前提，每个增量点依次恢复。3.3 其他办法如果业务十分紧急，则可以将备份的虚拟机文件以NFS的形式挂载到vCenter Server上，通过注册虚拟机的方式进行恢复。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"Java与PHP之间的Socket通信","slug":"Java与PHP之间的Socket通信","date":"2018-08-08T15:55:23.000Z","updated":"2019-07-16T15:13:03.436Z","comments":true,"path":"2018/08/08/Java与PHP之间的Socket通信/","link":"","permalink":"https://weeweetan.github.io/2018/08/08/Java与PHP之间的Socket通信/","excerpt":"","text":"Java作为服务端Java端作为服务端，PHP端作为客户端，在之前一篇文章中说了下PHP作为客户端如何与Java端进行通信。由于业务需要，socket必须等待服务端处理完成，并返回处理结果给PHP端。在这里主要说明一下Java端如何处理的，不足之处，望指正。12345678910111213141516171819202122232425262728ServerSocket serverSocket = new ServerSocket(port); //创建绑定到特定端口的服务器套接字Socket socket = serverSocket.accept(); //侦听并接受到此套接字的连接InputStream inputStream = socket.getInputStream();StringBuilder sb = new StringBuilder();byte[] packetLength = new byte[4];inputStream.read(packetLength, 0, 4); //首先从套接字中读取4字节的数据长度int target = byteToint(packetLength); //这里将字节数组转换成整数System.out.println(\"message size:\" + target);byte[] bytes = new byte[target];inputStream.read(bytes); //读取指定长度的数据sb.append(new String(bytes, 0, target, \"UTF-8\"));System.out.println(\"get message \" + sb);String result = \"has receive message\";OutputStream outputStream = socket.getOutputStream();int responseLength = result.getBytes().length; //这个地方的长度，一定要是字节数组的长度，否则如果字符串中包含中文，接收端接收数据会不完整 byte[] targets = intTobyte(responseLength);outputStream.write(targets); //首先发送4个字节的数据大小outputStream.write(result.getBytes()); //再发送真正的数据outputStream.flush();outputStream.close();inputStream.close();socket.close();上述代码需要处异常，而且代码中的byteToint和intTobyte这两个函数非原创，是其他博主的劳动成果，感谢这位作者，原文地址https://www.cnblogs.com/langren1992/p/4717241.html。PHP作为服务端相关函数: socket_create、socket_set_block、socket_bind、socket_listen、socket_accept、socket_read、socket_write，这些函数具体参数说明在PHP文档上写很详细，这里就不再赘述，这里只是介绍服务端如何处理请求。12345678910111213141516171819202122232425262728293031323334353637383940//确保在连接客户端时不会超时set_time_limit(0);//设置IP和端口号$address = \"127.0.0.1\";$port = 54321;$socketServer = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(\"socket_create() fail:\" . socket_strerror(socket_last_error()) . \"/n\");//设置为阻塞模式socket_set_block($socketServer) or die(\"socket_set_block() fail:\" . socket_strerror(socket_last_error()) . \"/n\");//绑定端口$result = socket_bind($socketServer, $address, $port) or die(\"socket_bind() fail:\" . socket_strerror(socket_last_error()) . \"/n\");//开始监听$result = socket_listen($socketServer, 4) or die(\"socket_listen() fail:\" . socket_strerror(socket_last_error()) . \"/n\");do &#123; //接收连接请求并返回一个子Socket来处理客户端和服务器间的信息 $sock = socket_accept($socketServer) or die(\"socket_accept() failed: reason: \" . socket_strerror(socket_last_error()) . \"/n\"); while($sock)&#123; //读取客户端数据 echo \"Read client data \\n\"; $length = socket_read($sock, 4); $length = unpack('i', $length); echo \"length:$length[1] \\n\"; $request = socket_read($sock, $length[1]); echo \"$request:$request \\n\"; //数据传送 向客户端写入返回结果 $msg = \"this is response message \\n\"; $msgLength = strlen($msg); $msgLength = pack('i', $msgLength); socket_write($sock, $msgLength); socket_write($sock, $msg, strlen($msg)) or die(\"socket_write() failed: reason: \" . socket_strerror(socket_last_error()) .\"/n\"); break; &#125;&#125; while (true);//根据需要关闭socketsocket_close($socketServer);在接收到客户端的请求后，可以结合PHP的多线程进行处理，这里只是简单的返回字符串。总结各大语言实现socket通信的方式都是大同小异，在服务端的流程都是差不多的。在有现成高性能socket通信框架的情况下，建议不要自己去实现，但是得理解框架底层是怎样实现的。","categories":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/categories/Socket/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/tags/Socket/"},{"name":"Java","slug":"Java","permalink":"https://weeweetan.github.io/tags/Java/"}]},{"title":"VMware vSphere WebService SDK使用心得","slug":"VMware-vSphere-WebService-SDK使用心得","date":"2018-07-25T12:13:58.000Z","updated":"2019-05-15T13:27:59.170Z","comments":true,"path":"2018/07/25/VMware-vSphere-WebService-SDK使用心得/","link":"","permalink":"https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK使用心得/","excerpt":"","text":"善用mob（Managed Object Browser）mob地址一般是https://vcenter的FQDN/mob，mob可以让你更好的理解SDK中的那些例子，以及根据自己的业务逻辑改写一些功能。下图为mob首页图，图中的content为整个Managed Object的顶层，从这里进去可以找到整个vcenter server中所有对象及其属性。善用GetMOREF类GetMOREF类具体位置在VMware-vSphere-SDK-6.0.0-2561048\\SDK\\vsphere-ws\\java\\JAXWS\\samples\\com\\vmware\\connection\\helpers，这是VMware官方提供的一个工具类，里面的每个函数对于开发都很有用。例如​List&lt;VirtualDevice&gt; listvd = ((ArrayOfVirtualDevice) getMOREFs .entityProps(vmMor, new String[] { &quot;config.hardware.device&quot; }) .get(&quot;config.hardware.device&quot;)).getVirtualDevice(); 这是VMReconfig.java中的一个片段，这段代码的作用就是去获取指定虚拟机对象的所有设备，vmMor可以通过GetMOREF类中的vmByVMname函数去获得。至于config.hardware.device，就需要用mob一层一层点进去看了，相信结合mob就能理解为什么要这么写。​​ ManagedObjectReference propCol = connection.getServiceContent().getPropertyCollector(); ManagedObjectReference vmRef = getMOREFs.vmByVMname(virtualMachineName,propCol); 上面这段代码的作用就是如何根据虚拟机名去获取其对应的ManagedObjectReference善用SDK里面的文档文档首页为VMware-vSphere-SDK-6.0.0-2561048/SDK/vsphere-ws/docs/ReferenceGuide/index.html根据需求，在左侧导航栏对应的去找。对SDK我整理了一下，使其能够在idea中编译运行，项目地址在VMwareProject ​","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"Socket粘包处理","slug":"Socket粘包处理","date":"2018-07-25T11:05:52.000Z","updated":"2019-07-16T15:11:06.374Z","comments":true,"path":"2018/07/25/Socket粘包处理/","link":"","permalink":"https://weeweetan.github.io/2018/07/25/Socket粘包处理/","excerpt":"","text":"背景这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据，并等待Java的响应结果，数据格式为JSON。遇到的问题PHP端发送数据后，Java端从socket里读取数据，但是一直读不到结束符。原因PHP需要调用socket_close函数才会向socket里面写入结束符。改进方法PHP端与Java端之间确定每次发送数据包的长度，用4个字节表示数据长度，PHP端先发送数据包长度，再发送数据包，Java端先接收4个字节长度的数据包长度，再根据数据包长度接收数据包。PHP端代码如下:1234567891011121314$socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP ) or die ( 'could not create socket' ); $connect = socket_connect ( $socket, 'xxx.xxx.xxx.xxx', xxxx); //服务端发送数据 $arr = array(\"data\" =&gt; \"dadadada\");$strlen = pack('i', strlen(json_encode($arr)));var_dump($strlen);socket_write ($socket, $strlen);socket_write ($socket, json_encode($arr), strlen(json_encode($arr)));$response = socket_read($socket, 4); $res = unpack('i', $response);var_dump($res);$response = socket_read($socket, $res[1]);var_dump($response);socket_close($socket);pack与unpack函数使用说明见PHP官方文档​","categories":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/categories/Socket/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/tags/Socket/"}]},{"title":"使用gcc编译驱动模块遇到的问题","slug":"使用gcc编译驱动模块遇到的问题","date":"2017-05-22T09:30:33.000Z","updated":"2019-05-17T15:43:16.624Z","comments":true,"path":"2017/05/22/使用gcc编译驱动模块遇到的问题/","link":"","permalink":"https://weeweetan.github.io/2017/05/22/使用gcc编译驱动模块遇到的问题/","excerpt":"","text":"背景由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客写一个块设备驱动学习，练习环境为centos6.5 gcc版本为6.3。遇到的问题跟着敲完那个简单的驱动程序后，发现编译出错，错误信息为include/linux/compiler-gcc.h:89:30: fatal error: linux/compiler-gcc6.h: No such file or directory 一通百度，说gcc版本太高，去下载一个compiler-gcc6.h文件，放到内核源码文件夹里面，按着做了，结果编译又出问题了，错误信息为include/linux/compiler.h:163:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void data_access_exceeds_word_size(void) include/linux/compiler.h:169:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void data_access_exceeds_word_size(void) include/linux/compiler.h:173:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void __read_once_size(volatile void *p, void *res, int size) include/linux/compiler.h:190:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void __write_once_size(volatile void *p, void *res, int size) 解决方法又是一通百度，发现跟我情况不符，看了下博客发表时间，08年，果断换了一个centos6.0的机器，gcc版本为4.6，编译完美通过,环境因素很重要啊。。。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/categories/Linux/"}],"tags":[{"name":"驱动模块","slug":"驱动模块","permalink":"https://weeweetan.github.io/tags/驱动模块/"},{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/tags/Linux/"}]},{"title":"PHP脚本中使用exec总结","slug":"PHP脚本中使用exec总结","date":"2017-02-20T01:03:11.000Z","updated":"2019-05-17T15:54:50.468Z","comments":true,"path":"2017/02/20/PHP脚本中使用exec总结/","link":"","permalink":"https://weeweetan.github.io/2017/02/20/PHP脚本中使用exec总结/","excerpt":"","text":"背景总结一下这两天加班遇到的坑，由于本次任务涉及到在PHP中使用exec函数运行shell命令，并解析返回值。屁颠屁颠的写好代码，上传到服务器，服务器环境配置centos6.5+Nginx，ssh到服务器，在控制台运行php xxx.php结果完美显示。蛋疼的是前端调用脚本的时候，没有数据，返回false，一脸懵逼，开始想问题所在，试着在浏览器地址栏直接访问xxx.php没有结果。然后把代码改成exec(&quot;ls 2&gt;&amp;1&quot;, $result); var_dump($result); 显示ls命令没找到，试着加上路径exec(&quot;/bin/ls 2&gt;&amp;1&quot;, $result); var_dump($result); 显示权限不够。解决方法lsof -i:80 查看你Nginx的用户是谁，我这里是nginx在脚本中添加file_put_contents(“/tmp/test.log”, “xxx”)查看test.log的用户是谁。我这里是nobody在vim /etc/sudoers添加权限nobody ALL=(ALL) NOPASSWD:ALLnginx ALL=(ALL) NOPASSWD:ALL重启nginx服务。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"}]},{"title":"Esxi5.1挂载NFS存储遇到的问题及解决办法","slug":"Esxi5-1挂载NFS存储遇到的问题及解决办法","date":"2017-01-13T01:18:44.000Z","updated":"2019-05-18T01:20:29.052Z","comments":true,"path":"2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/","link":"","permalink":"https://weeweetan.github.io/2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/","excerpt":"","text":"背景如何配置NFS以及怎样在Esxi中添加NFS，可以参考VMware ESXI 5.5使用NFS添加存储器, 我也是按照这个博客来配置的。遇到的问题遇到如下问题：解决方法必须要检查你的esxi主机是否配置了VMkernel，检查步骤如下：1、使用 VI/vSphere Client 连接到 Virtual Center/vCenter Server。2、选择 ESX/ESXi 主机。3、单击配置选项卡。4、单击网络。5、查看 VMKernel 的网络图，或单击属性 &gt; 端口 &gt; VMKernel。如果 VMKernel 未列出，必须添加它。手动挂载手动挂载命令：esxcli storage nfs add -H NFS_IP|NFS_HOSTNAME -s Share_mount_point_on_the_NFS -v DatastoreName 注意事项必须保证esxi主机与NFS服务器在同一网段或者能够相互通信","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"linux下编译vddk例程的错误总结","slug":"linux下编译vddk例程的错误总结","date":"2016-11-10T09:29:27.000Z","updated":"2019-05-18T02:28:46.640Z","comments":true,"path":"2016/11/10/linux下编译vddk例程的错误总结/","link":"","permalink":"https://weeweetan.github.io/2016/11/10/linux下编译vddk例程的错误总结/","excerpt":"","text":"背景vddk是visual disk development kit的缩写，是VMware vSphere提供的可用来操作虚拟磁盘的一套SDK，具体可看VDDK Document，在这里记录一下编译问题。遇到的问题按照官方文档编译vixDiskLibSample.cpp时报错Package vix-disklib was not found in the pkg-config search path. Perhaps you should add the directory containing `vix-disklib.pc&apos; to the PKG_CONFIG_PATH environment variable No package &apos;vix-disklib&apos; found 解决方法按照官方文档的说明编辑~/.bash_profile,添加如下内容：PKG_CONFIG_PATH=/usr/lib/pkgconfig export PKG_CONFIG_PATH LD_LIBRARY_PATH=/usr/lib/vmware-vix-disklib/lib64 export LD_LIBRARY_PATH 其中/usr/lib/vmware-vix-disklib/lib64是vddk安装后，默认的lib路径，添加完成后执行source bash_profile 再次编译就成功了","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"},{"name":"vddk","slug":"vddk","permalink":"https://weeweetan.github.io/tags/vddk/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2016-08-05T13:58:21.000Z","updated":"2023-05-21T03:56:31.344Z","comments":true,"path":"2016/08/05/Linux常用命令/","link":"","permalink":"https://weeweetan.github.io/2016/08/05/Linux常用命令/","excerpt":"","text":"vim1、使用u退回上一步2、使用U一次撤销对当前行的全部操作3、vim + filename 表示把光标定位到文件最后一行4、vim +数字 filemame 定位到数字行，如果超过文件行数，定位到最后一行5、vim +/word filename 定位到Word第一次出现的行，按n切换6、vim file1 file2 file3 一次性打开或者创建多个文件，底行模式下使用:n向后切换文件，:N和prev向前切换文件7、:w save:q quit:! 强制:ls 列出当前编辑器打开的所有文件:n 切换到下一个文件:N 切换到前一个文件:15 定位到15行:/xxx 表示从光标位置向后搜索xxx,定位到第一次出现的时候:?xxx搜索8、命令行模式常用命令h 光标左移j 光标下移k 光标上移l 光标右移Ctrl+f 向下翻页（front）Ctrl+b 向上翻页（back）Ctrl+d 向下翻半页（down）Ctrl+u 向上翻半页（up）df查看磁盘分区使用状况-l 仅显示本地磁盘（默认）-a 显示所有文件系统的磁盘使用情况-h 以1024进制计算最适合的单位显示磁盘容量-H 以1000进制计算最适合的单位显示磁盘容量-T 显示磁盘分区类型-t 显示指定类型文件系统的磁盘分区-x 不显示指定类型文件系统的磁盘分区du统计磁盘上的文件大小-b 以byte为单位统计文件-k 以KB为单位统计文件-m 以MB为单位统计文件-h 按照1024进制以最适合的单位统计文件-H 按照1000进制以最适合的单位统计文件-s 指定统计目标lsof可以列出被进程所打开的文件的信息。被打开的文件可以是1.普通的文件2.目录3.网络文件系统的文件4.字符设备文件5.(函数)共享库6.管道，命名管道7.符号链接8.底层的socket字流，网络socket，unix域名socket9.在linux里面，大部分的东西都是被当做文件的…..还有其他很多怎样使用lsof这里主要用案例的形式来介绍lsof 命令的使用列出所有打开的文件:lsof备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位查看谁正在使用某个文件lsof /filepath/file递归查看某个目录的文件信息lsof +D /filepath/filepath2/备注: 使用了+D，对应目录下的所有子目录和文件都会被列出比使用+D选项，遍历查看某个目录的所有文件信息 的方法lsof | grep ‘/filepath/filepath2/’列出某个用户打开的文件信息lsof -u username备注: -u 选项，u其实是user的缩写列出某个程序所打开的文件信息lsof -c mysql备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成lsof | grep mysql,但是第一种方法明显比第二种方法要少打几个字符了列出多个程序多打开的文件信息lsof -c mysql -c apache列出某个用户以及某个程序所打开的文件信息lsof -u test -c mysql列出除了某个用户外的被打开的文件信息lsof -u ^root备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示通过某个进程号显示该进行打开的文件lsof -p 1列出多个进程号对应的文件信息lsof -p 123,456,789列出除了某个进程号，其他进程号所打开的文件信息lsof -p ^113 . 列出所有的网络连接lsof -i列出所有tcp 网络连接信息lsof -i tcp列出所有udp网络连接信息lsof -i udp列出谁在使用某个端口lsof -i :3306列出谁在使用某个特定的udp端口lsof -i udp:55特定的tcp端口lsof -i tcp:80列出某个用户的所有活跃的网络端口lsof -a -u test -i列出所有网络文件系统lsof -N域名socket文件lsof -u某个用户组所打开的文件信息lsof -g 5555根据文件描述列出对应的文件信息lsof -d description(like 2)根据文件描述范围列出文件信息lsof -d 2-3top系列iotop – I/O 监控iotop 命令利用 Linux 内核监控 I/O 使用情况，它按进程或线程的顺序显示 I/O 使用情况。htop – 交互式的进程查看器htop 是一款免费并开源的基于 ncurses 的 Linux 进程查看器。它比 top 命令更简单易用。您无需使用 PID、无需离开 htop 界面，便可以杀掉进程或调整其调度优先级。atop – 高级版系统与进程监控工具atop 是一个非常强大的交互式 Linux 系统负载监控器，它从性能的角度显示最关键的硬件资源信息。您可以快速查看 CPU、内存、磁盘和网络性能。它还可以从进程的级别显示哪些进程造成了相关 CPU 和内存的负载。iftop – 显示主机上网络接口的带宽使用情况iftop 命令监听指定接口（如 eth0）上的网络通信情况。它显示了一对主机的带宽使用情况。vmstat虚拟内存统计显示 Slab 缓存的利用率vmstat -m 获取有关活动和非活动内存页面的信息vmstat -a grep高亮搜索关键字step1:修改~/.bashrc，在~/.bashrc中添加如下内容alias grep=’grep –color=auto’step2:重新加载.bashrc文件source ~/.bashrcnetstat-a ：all，表示列出所有的连接，服务监听，Socket资料-t ：tcp，列出tcp协议的服务-u ：udp，列出udp协议的服务-n ：port number， 用端口号来显示-l ：listening，列出当前监听服务-p ：program，列出服务程序的PIDps显示长输出格式# ps -Al 显示完整输出格式（它将显示传递给进程的命令行参数）# ps -AlF 显示线程（轻量级进程（LWP）和线程的数量（NLWP））# ps -AlFH 在进程后显示线程# ps -AlLm 显示系统上所有的进程# ps ax # ps aux 显示进程树# ps -ejH # ps axjf # pstree 显示进程的安全信息# ps -eo euser,ruser,suser,fuser,f,comm,label # ps axZ # ps -eM 显示指定用户（如 vivek）运行的进程# ps -U vivek -u vivek u 设置用户自定义的输出格式# ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm # ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm # ps -eopid,tt,user,fname,tmout,f,wchan 显示某进程（如 lighttpd）的 PID# ps -C lighttpd -o pid= 或# pgrep lighttpd 或# pgrep -u vivek php-cgi 显示指定 PID（如 55977）的进程名称# ps -p 55977 -o comm= 找出占用内存资源最多的前 10 个进程# ps -auxf | sort -nr -k 4 | head -10 找出占用 CPU 资源最多的前 10 个进程# ps -auxf | sort -nr -k 3 | head -10 ##ssss 命令用于获取套接字统计信息。它可以显示类似于 netstat 的信息。不过 netstat 几乎要过时了，ss 命令更具优势。要显示所有 TCP 或 UDP 套接字：# ss -t -a 或# ss -u -a 显示所有带有 SELinux 安全上下文Security Context的 TCP 套接字：# ss -t -a -Z pmappmap 命令用以显示进程的内存映射，使用此命令可以查找内存瓶颈。# pmap -d PID 显示 PID 为 47394 的进程的内存信息，请输入：# pmap -d 47394 sar?sar 命令用于收集、汇报和保存系统活动信息。要查看网络统计，请输入：# sar -n DEV | more 显示 24 日的网络统计：# sar -n DEV -f /var/log/sa/sa24 | more 显示实时使用情况：# sar 4 5 mpstatmpstat 命令显示每个可用处理器的使用情况，编号从 0 开始。命令 mpstat -P ALL 显示了每个处理器的平均使用率：# mpstat -P ALL w显示了当前登录在该系统上的用户及其进程。# w username tcpdumptcpdump 命令是简单的分析网络通信的命令。您需要充分了解 TCP/IP 协议才便于使用此工具。例如，要显示有关 DNS 的流量信息，请输入：# tcpdump -i eth1 &apos;udp port 53&apos; 查看所有去往和来自端口 80 的 IPv4 HTTP 数据包，仅打印真正包含数据的包，而不是像 SYN、FIN 和仅含 ACK 这类的数据包，请输入：# tcpdump &apos;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&apos; 显示所有目标地址为 202.54.1.5 的 FTP 会话，请输入：# tcpdump -i eth1 &apos;dst 202.54.1.5 and (port 21 or 20&apos; 打印所有目标地址为 192.168.1.5 的 HTTP 会话：# tcpdump -ni eth0 &apos;dst 192.168.1.5 and tcp and port http&apos; 捕获所有目标地址为 192.168.1.5 的 HTTP 会话，并保存：# tcpdump -ni eth0 &apos;dst 192.168.1.5 and tcp and port http&apos; -w output.cap &amp; 使用 wireshark 查看文件的详细内容，请输入：# tcpdump -n -i eth1 -s 0 -w output.cap src or dst port 80 lsb_releaselsb_release是读取/etc/redhat-release文件中的第一行记录，这里面记载了系统版本!!在Linux命令行中有特色含义，即感叹号后面的内容会被截断，所以如果需要将感叹号当作普通字符处理，需要使用单引号，如下：echo &quot;hello world&apos;!&apos;&quot; fdiskfdisk只能给磁盘做MBR分区，MBR只能有四个主分区，每个分区最大2TBpartedparted既可以做MBR分区也可以做GPT分区，GPT几乎没有分区限制，也没有大小限制ntpdatentpdate命令是用来设置本地日期和时间。它从指定的每个服务器获得了一些样本，并应用标准 NTP 时钟过滤器和选择算法来选择最好的样本。可使用如下命令进行网络时间更新ntpdate -u ntp.api.bz -u参数可以越过防火墙与主机同步；ntp.api.bz：NTP服务器(上海)。iptablesiptables命令是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。pkillpkill命令可以按照进程名杀死进程。语法pkill(选项)(参数) 选项-o：仅向找到的最小（起始）进程号发送信号；-n：仅向找到的最大（结束）进程号发送信号；-P：指定父进程号发送信号；-g：指定进程组；-t：指定开启进程的终端。killfirewall-cmd防火墙命令行开启指定host访问端口 firewall-cmd –permanent –add-rich-rule=”rule family=”ipv4” source address=”xxx.xxx.xxx.xxx” port protocol=”tcp” port=”xxxx” accept”刷新防火墙规则 firewall-cmd –relwgetwget拉取http请求语法wget(选项)(参数)选项–max-redirect 0：设置重定向次数，设置为0，表示不跟随302free查看系统剩余内存大小sed文本操作命令语法sed(选项)(参数)删除指定行，例如删除第6行： sed -i ‘6 d’ a.txt，删除第1-5行: sed -i ‘1,5 d’ a.txt匹配字符串后追加行，例如匹配到aaa后追加hello：sed -i ‘/aaa/ ahello’ a.txt;指定行后追加一行，例如sed -i ‘N;2a\\ xxxx’ a.txt，N之后的数字要是偶数，如果想插入换行符，sed -i ‘N;2a\\ \\nxxxx’ a.txtecho用于输出指定的字符串或者变量，带换行符的字符串需要用&lt;&gt;，最后用EOF表示字符串结束watch可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令awk用于处理文本htop用于查看系统状态xargs用于管道传递参数smem查看内存占用killall杀掉所有名字相同的进程","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/tags/Linux/"}]},{"title":"centos6.5下lamp环境部署laravel","slug":"centos6-5下lamp环境部署laravel","date":"2016-07-31T13:54:35.000Z","updated":"2019-05-18T13:56:16.929Z","comments":true,"path":"2016/07/31/centos6-5下lamp环境部署laravel/","link":"","permalink":"https://weeweetan.github.io/2016/07/31/centos6-5下lamp环境部署laravel/","excerpt":"","text":"安装composer，命令如下curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer chmod +x /usr/local/bin/composer 切换到Apache默认目录下cd /var/www/ composer create-project laravel/laravel --prefer-dist &quot;5.1.11&quot; composer install 修改权限cd laravel chmod -R 777 storage/ 修改配置vim/etc/httpd/conf/httpd.conf 把DocumentRoot “/var/www/html”改为DocumentRoot “/var/www/laravel/public”重启Apache服务service httpd restart","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"https://weeweetan.github.io/tags/Laravel/"}]},{"title":"MySQL常见问题","slug":"MySQL常见问题","date":"2016-05-22T05:55:31.000Z","updated":"2020-11-11T09:38:03.660Z","comments":true,"path":"2016/05/22/MySQL常见问题/","link":"","permalink":"https://weeweetan.github.io/2016/05/22/MySQL常见问题/","excerpt":"","text":"修改目录后MySQL无法启动这种问题一般是selinux造成的1、终端输入sestatus，如出现SELinux status: enabled，则selinux为开启状态，2、编辑/etc/selinux/config 文件，将SELINUX=enforcing改为SELINUX=disabled，重启机器修改密码修改密码分为两种情况，一种情况是拥有原来密码，另外一种情况则是忘记密码拥有原来的myql的root的密码；方法一：在mysql系统外，使用mysqladmin# mysqladmin -u root -p password &quot;test123&quot; Enter password: 【输入原来的密码】 方法二：通过登录mysql系统，# mysql -uroot -p Enter password: 【输入原来的密码】 mysql&gt;use mysql; mysql&gt; update user set password=password(&quot;test&quot;) where user=&apos;root&apos;; mysql&gt; flush privileges; mysql&gt; exit; 忘记原来的myql的root的密码；首先，你必须要有操作系统的root权限了。要是连系统的root权限都没有的话，先考虑root系统再走下面的步骤。类似于安全模式登录系统，有人建议说是pkill mysql，但是我不建议哈。因为当你执行了这个命令后，会导致这样的状况：/etc/init.d/mysqld statusmysqld dead but subsys locked这样即使你是在安全模式下启动mysql都未必会有用的，所以一般是这样/etc/init.d/mysqld stop，如果你不幸先用了pkill，那么就start一下再stop咯。# mysqld_safe --skip-grant-tables &amp; &amp;，表示在后台运行，不再后台运行的话，就再打开一个终端咯。# mysql mysql&gt; use mysql; mysql&gt; UPDATE user SET password=password(&quot;test123&quot;) WHERE user=&apos;root&apos;; mysql&gt; flush privileges; mysql&gt; exit; 本来mysql是不分大小写的，但是这个是修改的mysql中的mysql数据库的具体的值，要注意到。插入10万条记录的SQLdrop table if exists foo; create table foo ( id int unsigned not null auto_increment primary key, val smallint unsigned not null default 0 ) engine=innodb; drop procedure if exists load_foo_test_data; delimiter # create procedure load_foo_test_data() begin declare v_max int unsigned default 100000; declare v_counter int unsigned default 0; truncate table foo; start transaction; while v_counter &lt; v_max do insert into foo (val) values ( floor(0 + (rand() * 65535)) ); set v_counter=v_counter+1; end while; commit; end # delimiter ; call load_foo_test_data(); MySQL开启远程访问选择mysql库，选user表 新增用户mysql&gt; insert into user(Host,User,Password) values(&apos;%&apos;,&apos;用户名（必须是英文数字）&apos;,&apos;密码&apos;); 刷新权限mysql&gt;flush privileges; 授权给新增的用户mysql&gt; Grant all privileges on *.* to &apos;用户名&apos;@&apos;%&apos; identified by &apos;密码&apos; with grant option; 注释：其中：“ . ”代表所有数据库和表（也就是root权限） 其格式为:数据库名称 . 表名刷新权限mysql&gt;flush privileges; 数据库优化十个原则尽量避免在列上进行计算，这样会导致索引失效select * from t where year(d)&gt;=2011 =&gt; select * from t where d&gt;=&apos;2011-01-01&apos;; 使用join时，应该用小结果集驱动大结果集。同时把复杂的join查询拆分成多个query。因为join多个表时，可能导致更多的锁定和堵塞。注意like模糊查询的使用，避免%%。仅列出需要查询的字段，这对速度不会又明显的影响，主要考虑节省内存。使用批量插入语句节省交互。limit的基数比较大时使用between。不要使用rand函数获取多条随机记录。避免使用null不要使用count(id),而应该是count(*)不要做所谓的排序操作，而应尽可能在索引中完成排序适当使用联合索引，加快查询速度","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://weeweetan.github.io/tags/MySQL/"}]}]}