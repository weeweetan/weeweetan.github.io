{"meta":{"title":"weeweetan's blog","subtitle":"GitHub个人站点","description":"主要记录nginx、虚拟机备份以及其他学习笔记","author":"weeweetan","url":"https://weeweetan.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-04-30T06:58:00.000Z","updated":"2019-05-15T06:20:17.000Z","comments":true,"path":"about/index.html","permalink":"https://weeweetan.github.io/about/index.html","excerpt":"","text":"尝试过的技术VMware虚拟机备份与恢复数据库备份与恢复基于卷的持续数据保护Linux块设备驱动Linux C编程ThinkPHP框架Laravel框架Java SE目前正在研究的技术NginxCDN"},{"title":"友情链接","date":"2019-10-07T13:32:55.096Z","updated":"2019-05-15T04:37:44.000Z","comments":true,"path":"links/index.html","permalink":"https://weeweetan.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-10-07T13:32:54.940Z","updated":"2019-05-15T04:37:44.000Z","comments":false,"path":"books/index.html","permalink":"https://weeweetan.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-07T13:32:54.940Z","updated":"2019-05-15T04:37:44.000Z","comments":false,"path":"categories/index.html","permalink":"https://weeweetan.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-07T13:32:55.143Z","updated":"2019-05-15T04:37:44.000Z","comments":false,"path":"repository/index.html","permalink":"https://weeweetan.github.io/repository/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2019-05-15T01:36:14.000Z","updated":"2019-05-15T01:42:30.000Z","comments":true,"path":"resume/index.html","permalink":"https://weeweetan.github.io/resume/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-07T13:32:55.174Z","updated":"2019-05-15T04:37:44.000Z","comments":false,"path":"tags/index.html","permalink":"https://weeweetan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Nginx的共享内存详解","slug":"Nginx的共享内存详解","date":"2020-05-25T12:05:11.000Z","updated":"2020-06-06T12:17:32.313Z","comments":true,"path":"2020/05/25/Nginx的共享内存详解/","link":"","permalink":"https://weeweetan.github.io/2020/05/25/Nginx的共享内存详解/","excerpt":"","text":"1. 简述1.1 应用介绍nginx使用共享内存的模块有ngx_http_file_cache_module、ngx_http_limit_conn_module、ngx_http_limit_req_module等模块。无一例外，这几个模块都是使用nginx实现的红黑树，基于共享内存来保存他们所需要的数据。2 源码详解2.1 首先来看看相关结构体定义1234567891011121314151617181920212223242526272829303132333435363738394041424344typedef struct ngx_slab_page_s ngx_slab_page_t;struct ngx_slab_page_s &#123; uintptr_t slab; ngx_slab_page_t *next; //下一个page页 uintptr_t prev; //上一个page页&#125;;typedef struct &#123; ngx_uint_t total; ngx_uint_t used; ngx_uint_t reqs; ngx_uint_t fails;&#125; ngx_slab_stat_t;typedef struct &#123; ngx_shmtx_sh_t lock; //mutex锁 size_t min_size; //设定的最小内存块长度； size_t min_shift; //ngx_init_zone_pool中默认为3 ngx_slab_page_t *pages; //所有的空闲页组成一个链表挂在free成员上 ngx_slab_page_t *last; ngx_slab_page_t free; ngx_slab_stat_t *stats; ngx_uint_t pfree; // 剩余页数 u_char *start; u_char *end; ngx_shmtx_t mutex; u_char *log_ctx; u_char zero; unsigned log_nomem:1; void *data; void *addr;&#125; ngx_slab_pool_t;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx限流模块详解","slug":"Nginx限流模块详解","date":"2020-04-15T14:54:37.000Z","updated":"2020-05-28T09:38:16.802Z","comments":true,"path":"2020/04/15/Nginx限流模块详解/","link":"","permalink":"https://weeweetan.github.io/2020/04/15/Nginx限流模块详解/","excerpt":"","text":"1.相关指令123Syntax: limit_conn_zone key zone=name:size;Default: —Context: http此指令设置限流所需共享内存的名称和size，key指定限流的标志，比如$binary_remote_addr。12345Syntax: limit_conn zone number;Default: —Context: http, server, location此指令指定共享内存名以及限制多少连接，比如limit_conn_zone指令key设置为$binary_remote_addr，zone设置为limit_zone，那么来自于$binary_remote_addr的连接超过number，nginx直接给客户端响应503。2.源码解析2.1 配置解析函数首先来看下limit_conn_zone指令的解析函数ngx_http_limit_conn_zone，这个函数的功能主要是解析共享内存的name和size，然后使用这两个值作为参数调用ngx_shared_memory_add函数，将共享内存添加到nginx共享内存管理模块中，设置共享内存的data以及初始化函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100static char *ngx_http_limit_conn_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; u_char *p; ssize_t size; ngx_str_t *value, name, s; ngx_uint_t i; ngx_shm_zone_t *shm_zone; ngx_http_limit_conn_ctx_t *ctx; ngx_http_compile_complex_value_t ccv; value = cf-&gt;args-&gt;elts; ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_limit_conn_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = &amp;ctx-&gt;key; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; size = 0; name.len = 0; for (i = 2; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; if (ngx_strncmp(value[i].data, \"zone=\", 5) == 0) &#123; name.data = value[i].data + 5; p = (u_char *) ngx_strchr(name.data, ':'); if (p == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid zone size \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; name.len = p - name.data; s.data = p + 1; s.len = value[i].data + value[i].len - s.data; size = ngx_parse_size(&amp;s); if (size == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid zone size \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; if (size &lt; (ssize_t) (8 * ngx_pagesize)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"zone \\\"%V\\\" is too small\", &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\", &amp;value[i]); return NGX_CONF_ERROR; &#125; if (name.len == 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"\\\"%V\\\" must have \\\"zone\\\" parameter\", &amp;cmd-&gt;name); return NGX_CONF_ERROR; &#125; shm_zone = ngx_shared_memory_add(cf, &amp;name, size, &amp;ngx_http_limit_conn_module); if (shm_zone == NULL) &#123; return NGX_CONF_ERROR; &#125; if (shm_zone-&gt;data) &#123; ctx = shm_zone-&gt;data; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"%V \\\"%V\\\" is already bound to key \\\"%V\\\"\", &amp;cmd-&gt;name, &amp;name, &amp;ctx-&gt;key.value); return NGX_CONF_ERROR; &#125; shm_zone-&gt;init = ngx_http_limit_conn_init_zone; shm_zone-&gt;data = ctx; return NGX_CONF_OK;&#125;接下来看下limit_conn指令解析函数ngx_http_limit_conn，这个函数主要是保存配置的共享内存名以及限制连接的个数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static char *ngx_http_limit_conn(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_shm_zone_t *shm_zone; ngx_http_limit_conn_conf_t *lccf = conf; ngx_http_limit_conn_limit_t *limit, *limits; ngx_str_t *value; ngx_int_t n; ngx_uint_t i; value = cf-&gt;args-&gt;elts; shm_zone = ngx_shared_memory_add(cf, &amp;value[1], 0, &amp;ngx_http_limit_conn_module); if (shm_zone == NULL) &#123; return NGX_CONF_ERROR; &#125; limits = lccf-&gt;limits.elts; if (limits == NULL) &#123; if (ngx_array_init(&amp;lccf-&gt;limits, cf-&gt;pool, 1, sizeof(ngx_http_limit_conn_limit_t)) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; for (i = 0; i &lt; lccf-&gt;limits.nelts; i++) &#123; if (shm_zone == limits[i].shm_zone) &#123; return \"is duplicate\"; &#125; &#125; n = ngx_atoi(value[2].data, value[2].len); if (n &lt;= 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid number of connections \\\"%V\\\"\", &amp;value[2]); return NGX_CONF_ERROR; &#125; if (n &gt; 65535) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"connection limit must be less 65536\"); return NGX_CONF_ERROR; &#125; limit = ngx_array_push(&amp;lccf-&gt;limits); if (limit == NULL) &#123; return NGX_CONF_ERROR; &#125; limit-&gt;conn = n; limit-&gt;shm_zone = shm_zone; return NGX_CONF_OK;&#125;接下来就来看下nginx是如何实现限流的，这个功能由ngx_http_limit_conn_handler实现，主要功能就是统计各个进程与key对应的连接数，超过则返回503，在统计各个进程数据的时候使用了共享内存。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116static ngx_int_tngx_http_limit_conn_handler(ngx_http_request_t *r)&#123; size_t n; uint32_t hash; ngx_str_t key; ngx_uint_t i; ngx_slab_pool_t *shpool; ngx_rbtree_node_t *node; ngx_pool_cleanup_t *cln; ngx_http_limit_conn_ctx_t *ctx; ngx_http_limit_conn_node_t *lc; ngx_http_limit_conn_conf_t *lccf; ngx_http_limit_conn_limit_t *limits; ngx_http_limit_conn_cleanup_t *lccln; if (r-&gt;main-&gt;limit_conn_set) &#123; return NGX_DECLINED; &#125; lccf = ngx_http_get_module_loc_conf(r, ngx_http_limit_conn_module); limits = lccf-&gt;limits.elts; for (i = 0; i &lt; lccf-&gt;limits.nelts; i++) &#123; ctx = limits[i].shm_zone-&gt;data; //获取limit_conn_zone指令后key的值 if (ngx_http_complex_value(r, &amp;ctx-&gt;key, &amp;key) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; if (key.len == 0) &#123; continue; &#125; if (key.len &gt; 255) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"the value of the \\\"%V\\\" key \" \"is more than 255 bytes: \\\"%V\\\"\", &amp;ctx-&gt;key.value, &amp;key); continue; &#125; r-&gt;main-&gt;limit_conn_set = 1; //对key进行crc计算，用于在红黑树中查找结点 hash = ngx_crc32_short(key.data, key.len); shpool = (ngx_slab_pool_t *) limits[i].shm_zone-&gt;shm.addr; ngx_shmtx_lock(&amp;shpool-&gt;mutex); // 查找符合要求的结点 node = ngx_http_limit_conn_lookup(ctx-&gt;rbtree, &amp;key, hash); // 没有找到对应的结点，将此次请求插入到红黑树中 if (node == NULL) &#123; //计算结点所需内存 n = offsetof(ngx_rbtree_node_t, color) + offsetof(ngx_http_limit_conn_node_t, data) + key.len; // 申请结点内存 node = ngx_slab_alloc_locked(shpool, n); if (node == NULL) &#123; ngx_shmtx_unlock(&amp;shpool-&gt;mutex); ngx_http_limit_conn_cleanup_all(r-&gt;pool); return lccf-&gt;status_code; &#125; lc = (ngx_http_limit_conn_node_t *) &amp;node-&gt;color; // 赋值key，用于下次请求到来查询 node-&gt;key = hash; lc-&gt;len = (u_char) key.len; lc-&gt;conn = 1; ngx_memcpy(lc-&gt;data, key.data, key.len); ngx_rbtree_insert(ctx-&gt;rbtree, node); &#125; else &#123; lc = (ngx_http_limit_conn_node_t *) &amp;node-&gt;color; // 判断key标记的connections是否超过配置，如果超过则返回错误码 if ((ngx_uint_t) lc-&gt;conn &gt;= limits[i].conn) &#123; ngx_shmtx_unlock(&amp;shpool-&gt;mutex); ngx_log_error(lccf-&gt;log_level, r-&gt;connection-&gt;log, 0, \"limiting connections by zone \\\"%V\\\"\", &amp;limits[i].shm_zone-&gt;shm.name); ngx_http_limit_conn_cleanup_all(r-&gt;pool); return lccf-&gt;status_code; &#125; //连接数量+1 lc-&gt;conn++; &#125; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"limit conn: %08Xi %d\", node-&gt;key, lc-&gt;conn); ngx_shmtx_unlock(&amp;shpool-&gt;mutex); //注册内存池清理函数 cln = ngx_pool_cleanup_add(r-&gt;pool, sizeof(ngx_http_limit_conn_cleanup_t)); if (cln == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; cln-&gt;handler = ngx_http_limit_conn_cleanup; lccln = cln-&gt;data; lccln-&gt;shm_zone = limits[i].shm_zone; lccln-&gt;node = node; &#125; return NGX_DECLINED;&#125;结点插入函数，限流模块是将每个连接都存进一颗红黑树中，nginx提供一个默认的插入函数，限流模块自己实现了一个插入函数。3. 总结以上就是nginx限流模块的基本实现，其他限制请求数的模块类似。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"GDB调试技巧","slug":"GDB调试技巧","date":"2020-02-26T11:24:12.000Z","updated":"2020-04-08T12:00:24.836Z","comments":true,"path":"2020/02/26/GDB调试技巧/","link":"","permalink":"https://weeweetan.github.io/2020/02/26/GDB调试技巧/","excerpt":"","text":"1 预备工作1.1 添加编译参数1gcc -g只有在编译的时候添加了-g这个参数，才能够使用gdb进行调试。2 调试过程2.1 调试新进程gdb a.exe2.2 调试已有进程使用命令 gdb attach pid，跟踪现有进程2.3 常用命令单步调式 s，全称step，意味着每个函数都会进入单步调试 n, 全称next，不会进入函数打印变量 p, 全称print，可以打印各种变量的值继续进程 c, 全称continue，设置好断点后，继续运行，直到发生断点设置断点 b, 全称breakpoint，可设置函数断点也可以设置代码行号断点打印堆栈 bt, 全称backtrace, 打印当前函数调用栈退出当前函数栈 finish, 当使用s命令进入到某个函数后，可以使用finish指令退出当前函数设置命令行参数 set args, 若函数需要argv，args，可以使用此命令设置3 总结以上就是gdb调试常用命令，大多数场景都能应用","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"https://weeweetan.github.io/tags/GDB/"}]},{"title":"Nginx缓存清理","slug":"Nginx缓存清理","date":"2019-10-27T13:56:19.000Z","updated":"2019-11-21T14:42:06.501Z","comments":true,"path":"2019/10/27/Nginx缓存清理/","link":"","permalink":"https://weeweetan.github.io/2019/10/27/Nginx缓存清理/","excerpt":"","text":"1、相关配置123proxy_cache_path /dev/sda1/data inactive=60m max_size=10G;proxy_cache_path指令的inactive参数和max_size参数用来维护缓存队列大小2、源码解析首先来看看配置解析函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320char *ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; char *confp = conf; off_t max_size; u_char *last, *p; time_t inactive; ssize_t size; ngx_str_t s, name, *value; ngx_int_t loader_files, manager_files; ngx_msec_t loader_sleep, manager_sleep, loader_threshold, manager_threshold; ngx_uint_t i, n, use_temp_path; ngx_array_t *caches; ngx_http_file_cache_t *cache, **ce; cache = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_file_cache_t)); if (cache == NULL) &#123; return NGX_CONF_ERROR; &#125; cache-&gt;path = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_path_t)); if (cache-&gt;path == NULL) &#123; return NGX_CONF_ERROR; &#125; use_temp_path = 1; inactive = 600; loader_files = 100; loader_sleep = 50; loader_threshold = 200; manager_files = 100; manager_sleep = 50; manager_threshold = 200; name.len = 0; size = 0; max_size = NGX_MAX_OFF_T_VALUE; value = cf-&gt;args-&gt;elts; cache-&gt;path-&gt;name = value[1]; if (cache-&gt;path-&gt;name.data[cache-&gt;path-&gt;name.len - 1] == &apos;/&apos;) &#123; cache-&gt;path-&gt;name.len--; &#125; if (ngx_conf_full_name(cf-&gt;cycle, &amp;cache-&gt;path-&gt;name, 0) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; for (i = 2; i &lt; cf-&gt;args-&gt;nelts; i++) &#123; if (ngx_strncmp(value[i].data, &quot;levels=&quot;, 7) == 0) &#123; p = value[i].data + 7; last = value[i].data + value[i].len; for (n = 0; n &lt; NGX_MAX_PATH_LEVEL &amp;&amp; p &lt; last; n++) &#123; if (*p &gt; &apos;0&apos; &amp;&amp; *p &lt; &apos;3&apos;) &#123; cache-&gt;path-&gt;level[n] = *p++ - &apos;0&apos;; cache-&gt;path-&gt;len += cache-&gt;path-&gt;level[n] + 1; if (p == last) &#123; break; &#125; if (*p++ == &apos;:&apos; &amp;&amp; n &lt; NGX_MAX_PATH_LEVEL - 1 &amp;&amp; p &lt; last) &#123; continue; &#125; goto invalid_levels; &#125; goto invalid_levels; &#125; if (cache-&gt;path-&gt;len &lt; 10 + NGX_MAX_PATH_LEVEL) &#123; continue; &#125; invalid_levels: ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid \\&quot;levels\\&quot; \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; if (ngx_strncmp(value[i].data, &quot;use_temp_path=&quot;, 14) == 0) &#123; if (ngx_strcmp(&amp;value[i].data[14], &quot;on&quot;) == 0) &#123; use_temp_path = 1; &#125; else if (ngx_strcmp(&amp;value[i].data[14], &quot;off&quot;) == 0) &#123; use_temp_path = 0; &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid use_temp_path value \\&quot;%V\\&quot;, &quot; &quot;it must be \\&quot;on\\&quot; or \\&quot;off\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;keys_zone=&quot;, 10) == 0) &#123; name.data = value[i].data + 10; p = (u_char *) ngx_strchr(name.data, &apos;:&apos;); if (p == NULL) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid keys zone size \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; name.len = p - name.data; s.data = p + 1; s.len = value[i].data + value[i].len - s.data; size = ngx_parse_size(&amp;s); if (size == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid keys zone size \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; if (size &lt; (ssize_t) (2 * ngx_pagesize)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;keys zone \\&quot;%V\\&quot; is too small&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;inactive=&quot;, 9) == 0) &#123; s.len = value[i].len - 9; s.data = value[i].data + 9; inactive = ngx_parse_time(&amp;s, 1); if (inactive == (time_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid inactive value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;max_size=&quot;, 9) == 0) &#123; s.len = value[i].len - 9; s.data = value[i].data + 9; max_size = ngx_parse_offset(&amp;s); if (max_size &lt; 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid max_size value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;loader_files=&quot;, 13) == 0) &#123; loader_files = ngx_atoi(value[i].data + 13, value[i].len - 13); if (loader_files == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid loader_files value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;loader_sleep=&quot;, 13) == 0) &#123; s.len = value[i].len - 13; s.data = value[i].data + 13; loader_sleep = ngx_parse_time(&amp;s, 0); if (loader_sleep == (ngx_msec_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid loader_sleep value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;loader_threshold=&quot;, 17) == 0) &#123; s.len = value[i].len - 17; s.data = value[i].data + 17; loader_threshold = ngx_parse_time(&amp;s, 0); if (loader_threshold == (ngx_msec_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid loader_threshold value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;manager_files=&quot;, 14) == 0) &#123; manager_files = ngx_atoi(value[i].data + 14, value[i].len - 14); if (manager_files == NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid manager_files value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;manager_sleep=&quot;, 14) == 0) &#123; s.len = value[i].len - 14; s.data = value[i].data + 14; manager_sleep = ngx_parse_time(&amp;s, 0); if (manager_sleep == (ngx_msec_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid manager_sleep value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; if (ngx_strncmp(value[i].data, &quot;manager_threshold=&quot;, 18) == 0) &#123; s.len = value[i].len - 18; s.data = value[i].data + 18; manager_threshold = ngx_parse_time(&amp;s, 0); if (manager_threshold == (ngx_msec_t) NGX_ERROR) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid manager_threshold value \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; continue; &#125; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid parameter \\&quot;%V\\&quot;&quot;, &amp;value[i]); return NGX_CONF_ERROR; &#125; if (name.len == 0 || size == 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;\\&quot;%V\\&quot; must have \\&quot;keys_zone\\&quot; parameter&quot;, &amp;cmd-&gt;name); return NGX_CONF_ERROR; &#125; cache-&gt;path-&gt;manager = ngx_http_file_cache_manager; cache-&gt;path-&gt;loader = ngx_http_file_cache_loader; cache-&gt;path-&gt;data = cache; cache-&gt;path-&gt;conf_file = cf-&gt;conf_file-&gt;file.name.data; cache-&gt;path-&gt;line = cf-&gt;conf_file-&gt;line; cache-&gt;loader_files = loader_files; cache-&gt;loader_sleep = loader_sleep; cache-&gt;loader_threshold = loader_threshold; cache-&gt;manager_files = manager_files; cache-&gt;manager_sleep = manager_sleep; cache-&gt;manager_threshold = manager_threshold; if (ngx_add_path(cf, &amp;cache-&gt;path) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; cache-&gt;shm_zone = ngx_shared_memory_add(cf, &amp;name, size, cmd-&gt;post); if (cache-&gt;shm_zone == NULL) &#123; return NGX_CONF_ERROR; &#125; if (cache-&gt;shm_zone-&gt;data) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;duplicate zone \\&quot;%V\\&quot;&quot;, &amp;name); return NGX_CONF_ERROR; &#125; cache-&gt;shm_zone-&gt;init = ngx_http_file_cache_init; cache-&gt;shm_zone-&gt;data = cache; cache-&gt;use_temp_path = use_temp_path; cache-&gt;inactive = inactive; cache-&gt;max_size = max_size; caches = (ngx_array_t *) (confp + cmd-&gt;offset); ce = ngx_array_push(caches); if (ce == NULL) &#123; return NGX_CONF_ERROR; &#125; *ce = cache; return NGX_CONF_OK;&#125;上述代码中我们只关注inactive，max_size参数解析、cache-&gt;path相关成员赋值以及loader和manager相关的赋值代码，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546cache-&gt;path-&gt;manager = ngx_http_file_cache_manager;cache-&gt;path-&gt;loader = ngx_http_file_cache_loader;cache-&gt;path-&gt;data = cache;cache-&gt;path-&gt;conf_file = cf-&gt;conf_file-&gt;file.name.data;cache-&gt;path-&gt;line = cf-&gt;conf_file-&gt;line;cache-&gt;loader_files = loader_files;cache-&gt;loader_sleep = loader_sleep;cache-&gt;loader_threshold = loader_threshold;cache-&gt;manager_files = manager_files;cache-&gt;manager_sleep = manager_sleep;cache-&gt;manager_threshold = manager_threshold;if (ngx_add_path(cf, &amp;cache-&gt;path) != NGX_OK) &#123; return NGX_CONF_ERROR;&#125;cache-&gt;shm_zone = ngx_shared_memory_add(cf, &amp;name, size, cmd-&gt;post);if (cache-&gt;shm_zone == NULL) &#123; return NGX_CONF_ERROR;&#125;if (cache-&gt;shm_zone-&gt;data) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;duplicate zone \\&quot;%V\\&quot;&quot;, &amp;name); return NGX_CONF_ERROR;&#125;cache-&gt;shm_zone-&gt;init = ngx_http_file_cache_init;cache-&gt;shm_zone-&gt;data = cache;cache-&gt;use_temp_path = use_temp_path;cache-&gt;inactive = inactive;cache-&gt;max_size = max_size;caches = (ngx_array_t *) (confp + cmd-&gt;offset);ce = ngx_array_push(caches);if (ce == NULL) &#123; return NGX_CONF_ERROR;&#125;*ce = cache;path结构体初始化完成之后，ngx_add_path函数将配置的路径添加到nginx全局路径管理器后，配置解析完成之后会统一管理，接下来我们来看看几个跟目录相关的回调函数。1234ngx_http_file_cache_managerngx_http_file_cache_loader首先来看看ngx_http_file_cache_manager函数的具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static ngx_msec_tngx_http_file_cache_manager(void *data)&#123; ngx_http_file_cache_t *cache = data; off_t size; time_t wait; ngx_msec_t elapsed, next; ngx_uint_t count, watermark; cache-&gt;last = ngx_current_msec; cache-&gt;files = 0; next = (ngx_msec_t) ngx_http_file_cache_expire(cache) * 1000; if (next == 0) &#123; next = cache-&gt;manager_sleep; goto done; &#125; for ( ;; ) &#123; ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); size = cache-&gt;sh-&gt;size; count = cache-&gt;sh-&gt;count; watermark = cache-&gt;sh-&gt;watermark; ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); ngx_log_debug3(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;log, 0, &quot;http file cache size: %O c:%ui w:%i&quot;, size, count, (ngx_int_t) watermark); if (size &lt; cache-&gt;max_size &amp;&amp; count &lt; watermark) &#123; break; &#125; wait = ngx_http_file_cache_forced_expire(cache); if (wait &gt; 0) &#123; next = (ngx_msec_t) wait * 1000; break; &#125; if (ngx_quit || ngx_terminate) &#123; break; &#125; if (++cache-&gt;files &gt;= cache-&gt;manager_files) &#123; next = cache-&gt;manager_sleep; break; &#125; ngx_time_update(); elapsed = ngx_abs((ngx_msec_int_t) (ngx_current_msec - cache-&gt;last)); if (elapsed &gt;= cache-&gt;manager_threshold) &#123; next = cache-&gt;manager_sleep; break; &#125; &#125;done: elapsed = ngx_abs((ngx_msec_int_t) (ngx_current_msec - cache-&gt;last)); ngx_log_debug3(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;log, 0, &quot;http file cache manager: %ui e:%M n:%M&quot;, cache-&gt;files, elapsed, next); return next;&#125;这个函数主要的功能就是遍历缓存结点数，找出过期结点，并删除，接下来看看ngx_http_file_cache_loader函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 static voidngx_http_file_cache_loader(void *data)&#123; ngx_http_file_cache_t *cache = data; ngx_tree_ctx_t tree; if (!cache-&gt;sh-&gt;cold || cache-&gt;sh-&gt;loading) &#123; return; &#125; if (!ngx_atomic_cmp_set(&amp;cache-&gt;sh-&gt;loading, 0, ngx_pid)) &#123; return; &#125; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;log, 0, &quot;http file cache loader&quot;); tree.init_handler = NULL; tree.file_handler = ngx_http_file_cache_manage_file; tree.pre_tree_handler = ngx_http_file_cache_manage_directory; tree.post_tree_handler = ngx_http_file_cache_noop; tree.spec_handler = ngx_http_file_cache_delete_file; tree.data = cache; tree.alloc = 0; tree.log = ngx_cycle-&gt;log; cache-&gt;last = ngx_current_msec; cache-&gt;files = 0; if (ngx_walk_tree(&amp;tree, &amp;cache-&gt;path-&gt;name) == NGX_ABORT) &#123; cache-&gt;sh-&gt;loading = 0; return; &#125; cache-&gt;sh-&gt;cold = 0; cache-&gt;sh-&gt;loading = 0; ngx_log_error(NGX_LOG_NOTICE, ngx_cycle-&gt;log, 0, &quot;http file cache: %V %.3fM, bsize: %uz&quot;, &amp;cache-&gt;path-&gt;name, ((double) cache-&gt;sh-&gt;size * cache-&gt;bsize) / (1024 * 1024), cache-&gt;bsize);&#125;&gt;6. 此函数功能就是绑定回调函数，然后遍历配置的目录，根据目录中不同的对象调用不同的回调函数 3、总结以上就是nginx缓存管理的主要代码，总的来说就是在解析配置时设置ngx_path_t结构体的回调函数，cache_manager进程定时启动扫描LRU队列，删除过期结点","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的return模块","slug":"Nginx的return模块","date":"2019-10-12T06:05:34.000Z","updated":"2020-04-07T12:15:54.310Z","comments":true,"path":"2019/10/12/Nginx的return模块/","link":"","permalink":"https://weeweetan.github.io/2019/10/12/Nginx的return模块/","excerpt":"","text":"1 相关配置return模块配置指令如下：1return value;详细用法参考nginx官方文档2 源码解析2.1 首先看看指令解析函数，这个函数的主要功能就是把return指令后面的文本以nginx变量的形式保存，绑定此阶段的处理函数。12345678910111213141516171819202122232425262728293031static char *ngx_stream_return(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_stream_return_srv_conf_t *rscf = conf; ngx_str_t *value; ngx_stream_core_srv_conf_t *cscf; ngx_stream_compile_complex_value_t ccv; if (rscf-&gt;text.value.data) &#123; return \"is duplicate\"; &#125; value = cf-&gt;args-&gt;elts; ngx_memzero(&amp;ccv, sizeof(ngx_stream_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = &amp;rscf-&gt;text; if (ngx_stream_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; cscf = ngx_stream_conf_get_module_srv_conf(cf, ngx_stream_core_module); cscf-&gt;handler = ngx_stream_return_handler; return NGX_CONF_OK;&#125;2.2 在上一步设置好处理函数后，nginx运行到此阶段就会调用ngx_stream_return_handler函数，并给客户端响应1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static voidngx_stream_return_handler(ngx_stream_session_t *s)&#123; ngx_str_t text; ngx_buf_t *b; ngx_connection_t *c; ngx_stream_return_ctx_t *ctx; ngx_stream_return_srv_conf_t *rscf; c = s-&gt;connection; c-&gt;log-&gt;action = \"returning text\"; rscf = ngx_stream_get_module_srv_conf(s, ngx_stream_return_module); if (ngx_stream_complex_value(s, &amp;rscf-&gt;text, &amp;text) != NGX_OK) &#123; ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR); return; &#125; ngx_log_debug1(NGX_LOG_DEBUG_STREAM, c-&gt;log, 0, \"stream return text: \\\"%V\\\"\", &amp;text); if (text.len == 0) &#123; ngx_stream_finalize_session(s, NGX_STREAM_OK); return; &#125; ctx = ngx_pcalloc(c-&gt;pool, sizeof(ngx_stream_return_ctx_t)); if (ctx == NULL) &#123; ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR); return; &#125; ngx_stream_set_ctx(s, ctx, ngx_stream_return_module); b = ngx_calloc_buf(c-&gt;pool); if (b == NULL) &#123; ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR); return; &#125; b-&gt;memory = 1; b-&gt;pos = text.data; b-&gt;last = text.data + text.len; b-&gt;last_buf = 1; ctx-&gt;out = ngx_alloc_chain_link(c-&gt;pool); if (ctx-&gt;out == NULL) &#123; ngx_stream_finalize_session(s, NGX_STREAM_INTERNAL_SERVER_ERROR); return; &#125; ctx-&gt;out-&gt;buf = b; ctx-&gt;out-&gt;next = NULL; c-&gt;write-&gt;handler = ngx_stream_return_write_handler; ngx_stream_return_write_handler(c-&gt;write);&#125;ngx_stream_return_handler函数首先解析出return指令后面的字符串值，然后为当前模块的ngx_stream_return_ctx_t申请内存，主要用来挂载发送数据的chain，再为发送数据的chain以及buf申请内存，设置写事件的handler，最后发送响应到客户端。3 总结return模块属于stream模块，在stream模块中处于第4阶段，所以需要绑定handler函数，将return指令后的变量或者纯文本响应给客户端。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的geo模块","slug":"Nginx的geo模块","date":"2019-10-12T01:26:55.000Z","updated":"2019-12-20T12:45:20.028Z","comments":true,"path":"2019/10/12/Nginx的geo模块/","link":"","permalink":"https://weeweetan.github.io/2019/10/12/Nginx的geo模块/","excerpt":"","text":"1、相关配置geo模块配置指令如下：12345geo $remote_addr $var &#123; &#125;详细用法参考nginx官方文档2、源码详解2.1 首先来看看geo指令配置解析函数，这个函数的主要功能就是解析geo指令之后的变量，然后再调用ngx_http_geo解析{}中的内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187static char *ngx_http_geo_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; char *rv; size_t len; ngx_str_t *value, name; ngx_uint_t i; ngx_conf_t save; ngx_pool_t *pool; ngx_array_t *a; ngx_http_variable_t *var; ngx_http_geo_ctx_t *geo; ngx_http_geo_conf_ctx_t ctx;#if (NGX_HAVE_INET6) static struct in6_addr zero;#endif value = cf-&gt;args-&gt;elts; geo = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_geo_ctx_t)); if (geo == NULL) &#123; return NGX_CONF_ERROR; &#125; name = value[1]; if (name.data[0] != '$') &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;name); return NGX_CONF_ERROR; &#125; name.len--; name.data++; if (cf-&gt;args-&gt;nelts == 3) &#123; geo-&gt;index = ngx_http_get_variable_index(cf, &amp;name); if (geo-&gt;index == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125; name = value[2]; if (name.data[0] != '$') &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;name); return NGX_CONF_ERROR; &#125; name.len--; name.data++; &#125; else &#123; geo-&gt;index = -1; &#125; var = ngx_http_add_variable(cf, &amp;name, NGX_HTTP_VAR_CHANGEABLE); if (var == NULL) &#123; return NGX_CONF_ERROR; &#125; pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf-&gt;log); if (pool == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;ctx, sizeof(ngx_http_geo_conf_ctx_t)); ctx.temp_pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf-&gt;log); if (ctx.temp_pool == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_rbtree_init(&amp;ctx.rbtree, &amp;ctx.sentinel, ngx_str_rbtree_insert_value); ctx.pool = cf-&gt;pool; ctx.data_size = sizeof(ngx_http_geo_header_t) + sizeof(ngx_http_variable_value_t) + 0x10000 * sizeof(ngx_http_geo_range_t *); ctx.allow_binary_include = 1; save = *cf; cf-&gt;pool = pool; cf-&gt;ctx = &amp;ctx; cf-&gt;handler = ngx_http_geo; cf-&gt;handler_conf = conf; rv = ngx_conf_parse(cf, NULL); *cf = save; geo-&gt;proxies = ctx.proxies; geo-&gt;proxy_recursive = ctx.proxy_recursive; if (ctx.ranges) &#123; if (ctx.high.low &amp;&amp; !ctx.binary_include) &#123; for (i = 0; i &lt; 0x10000; i++) &#123; a = (ngx_array_t *) ctx.high.low[i]; if (a == NULL || a-&gt;nelts == 0) &#123; continue; &#125; len = a-&gt;nelts * sizeof(ngx_http_geo_range_t); ctx.high.low[i] = ngx_palloc(cf-&gt;pool, len + sizeof(void *)); if (ctx.high.low[i] == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memcpy(ctx.high.low[i], a-&gt;elts, len); ctx.high.low[i][a-&gt;nelts].value = NULL; ctx.data_size += len + sizeof(void *); &#125; if (ctx.allow_binary_include &amp;&amp; !ctx.outside_entries &amp;&amp; ctx.entries &gt; 100000 &amp;&amp; ctx.includes == 1) &#123; ngx_http_geo_create_binary_base(&amp;ctx); &#125; &#125; if (ctx.high.default_value == NULL) &#123; ctx.high.default_value = &amp;ngx_http_variable_null_value; &#125; geo-&gt;u.high = ctx.high; var-&gt;get_handler = ngx_http_geo_range_variable; var-&gt;data = (uintptr_t) geo; ngx_destroy_pool(ctx.temp_pool); ngx_destroy_pool(pool); &#125; else &#123; if (ctx.tree == NULL) &#123; ctx.tree = ngx_radix_tree_create(cf-&gt;pool, -1); if (ctx.tree == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; geo-&gt;u.trees.tree = ctx.tree;#if (NGX_HAVE_INET6) if (ctx.tree6 == NULL) &#123; ctx.tree6 = ngx_radix_tree_create(cf-&gt;pool, -1); if (ctx.tree6 == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; geo-&gt;u.trees.tree6 = ctx.tree6;#endif var-&gt;get_handler = ngx_http_geo_cidr_variable; var-&gt;data = (uintptr_t) geo; ngx_destroy_pool(ctx.temp_pool); ngx_destroy_pool(pool); if (ngx_radix32tree_insert(ctx.tree, 0, 0, (uintptr_t) &amp;ngx_http_variable_null_value) == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125; /* NGX_BUSY is okay (default was set explicitly) */#if (NGX_HAVE_INET6) if (ngx_radix128tree_insert(ctx.tree6, zero.s6_addr, zero.s6_addr, (uintptr_t) &amp;ngx_http_variable_null_value) == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125;#endif &#125; return rv;&#125;2.2 ngx_http_geo解析{}中的内容，处理ranges等指令和IP地址段或者CIDR地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static char *ngx_http_geo(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)&#123; char *rv; ngx_str_t *value; ngx_cidr_t cidr; ngx_http_geo_conf_ctx_t *ctx; ctx = cf-&gt;ctx; value = cf-&gt;args-&gt;elts; if (cf-&gt;args-&gt;nelts == 1) &#123; if (ngx_strcmp(value[0].data, \"ranges\") == 0) &#123; if (ctx-&gt;tree#if (NGX_HAVE_INET6) || ctx-&gt;tree6#endif ) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"the \\\"ranges\\\" directive must be \" \"the first directive inside \\\"geo\\\" block\"); goto failed; &#125; ctx-&gt;ranges = 1; rv = NGX_CONF_OK; goto done; &#125; else if (ngx_strcmp(value[0].data, \"proxy_recursive\") == 0) &#123; ctx-&gt;proxy_recursive = 1; rv = NGX_CONF_OK; goto done; &#125; &#125; if (cf-&gt;args-&gt;nelts != 2) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid number of the geo parameters\"); goto failed; &#125; if (ngx_strcmp(value[0].data, \"include\") == 0) &#123; rv = ngx_http_geo_include(cf, ctx, &amp;value[1]); goto done; &#125; else if (ngx_strcmp(value[0].data, \"proxy\") == 0) &#123; if (ngx_http_geo_cidr_value(cf, &amp;value[1], &amp;cidr) != NGX_OK) &#123; goto failed; &#125; rv = ngx_http_geo_add_proxy(cf, ctx, &amp;cidr); goto done; &#125; if (ctx-&gt;ranges) &#123; rv = ngx_http_geo_range(cf, ctx, value); &#125; else &#123; rv = ngx_http_geo_cidr(cf, ctx, value); &#125;done: ngx_reset_pool(cf-&gt;pool); return rv;failed: ngx_reset_pool(cf-&gt;pool); return NGX_CONF_ERROR;&#125;2.3 处理range地址，调用ngx_http_geo_range函数实现，接下来看看这个函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110static char *ngx_http_geo_range(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx, ngx_str_t *value)&#123; u_char *p, *last; in_addr_t start, end; ngx_str_t *net; ngx_uint_t del; if (ngx_strcmp(value[0].data, &quot;default&quot;) == 0) &#123; if (ctx-&gt;high.default_value) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;duplicate default geo range value: \\&quot;%V\\&quot;, old value: \\&quot;%v\\&quot;&quot;, &amp;value[1], ctx-&gt;high.default_value); &#125; ctx-&gt;high.default_value = ngx_http_geo_value(cf, ctx, &amp;value[1]); if (ctx-&gt;high.default_value == NULL) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK; &#125; if (ctx-&gt;binary_include) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;binary geo range base \\&quot;%s\\&quot; cannot be mixed with usual entries&quot;, ctx-&gt;include_name.data); return NGX_CONF_ERROR; &#125; if (ctx-&gt;high.low == NULL) &#123; ctx-&gt;high.low = ngx_pcalloc(ctx-&gt;pool, 0x10000 * sizeof(ngx_http_geo_range_t *)); if (ctx-&gt;high.low == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125; ctx-&gt;entries++; ctx-&gt;outside_entries = 1; if (ngx_strcmp(value[0].data, &quot;delete&quot;) == 0) &#123; net = &amp;value[1]; del = 1; &#125; else &#123; net = &amp;value[0]; del = 0; &#125; last = net-&gt;data + net-&gt;len; p = ngx_strlchr(net-&gt;data, last, &apos;-&apos;); if (p == NULL) &#123; goto invalid; &#125; start = ngx_inet_addr(net-&gt;data, p - net-&gt;data); if (start == INADDR_NONE) &#123; goto invalid; &#125; start = ntohl(start); p++; end = ngx_inet_addr(p, last - p); if (end == INADDR_NONE) &#123; goto invalid; &#125; end = ntohl(end); if (start &gt; end) &#123; goto invalid; &#125; if (del) &#123; if (ngx_http_geo_delete_range(cf, ctx, start, end)) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;no address range \\&quot;%V\\&quot; to delete&quot;, net); &#125; return NGX_CONF_OK; &#125; ctx-&gt;value = ngx_http_geo_value(cf, ctx, &amp;value[1]); if (ctx-&gt;value == NULL) &#123; return NGX_CONF_ERROR; &#125; ctx-&gt;net = net; return ngx_http_geo_add_range(cf, ctx, start, end);invalid: ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid range \\&quot;%V\\&quot;&quot;, net); return NGX_CONF_ERROR;&#125;2.4 处理CIDR地址，调用ngx_http_geo_cidr函数实现，接下来看看这个函数的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static char *ngx_http_geo_cidr(ngx_conf_t *cf, ngx_http_geo_conf_ctx_t *ctx, ngx_str_t *value)&#123; char *rv; ngx_int_t rc, del; ngx_str_t *net; ngx_cidr_t cidr; if (ctx-&gt;tree == NULL) &#123; ctx-&gt;tree = ngx_radix_tree_create(ctx-&gt;pool, -1); if (ctx-&gt;tree == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125;#if (NGX_HAVE_INET6) if (ctx-&gt;tree6 == NULL) &#123; ctx-&gt;tree6 = ngx_radix_tree_create(ctx-&gt;pool, -1); if (ctx-&gt;tree6 == NULL) &#123; return NGX_CONF_ERROR; &#125; &#125;#endif if (ngx_strcmp(value[0].data, &quot;default&quot;) == 0) &#123; cidr.family = AF_INET; cidr.u.in.addr = 0; cidr.u.in.mask = 0; rv = ngx_http_geo_cidr_add(cf, ctx, &amp;cidr, &amp;value[1], &amp;value[0]); if (rv != NGX_CONF_OK) &#123; return rv; &#125;#if (NGX_HAVE_INET6) cidr.family = AF_INET6; ngx_memzero(&amp;cidr.u.in6, sizeof(ngx_in6_cidr_t)); rv = ngx_http_geo_cidr_add(cf, ctx, &amp;cidr, &amp;value[1], &amp;value[0]); if (rv != NGX_CONF_OK) &#123; return rv; &#125;#endif return NGX_CONF_OK; &#125; if (ngx_strcmp(value[0].data, &quot;delete&quot;) == 0) &#123; net = &amp;value[1]; del = 1; &#125; else &#123; net = &amp;value[0]; del = 0; &#125; if (ngx_http_geo_cidr_value(cf, net, &amp;cidr) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (cidr.family == AF_INET) &#123; cidr.u.in.addr = ntohl(cidr.u.in.addr); cidr.u.in.mask = ntohl(cidr.u.in.mask); &#125; if (del) &#123; switch (cidr.family) &#123;#if (NGX_HAVE_INET6) case AF_INET6: rc = ngx_radix128tree_delete(ctx-&gt;tree6, cidr.u.in6.addr.s6_addr, cidr.u.in6.mask.s6_addr); break;#endif default: /* AF_INET */ rc = ngx_radix32tree_delete(ctx-&gt;tree, cidr.u.in.addr, cidr.u.in.mask); break; &#125; if (rc != NGX_OK) &#123; ngx_conf_log_error(NGX_LOG_WARN, cf, 0, &quot;no network \\&quot;%V\\&quot; to delete&quot;, net); &#125; return NGX_CONF_OK; &#125; return ngx_http_geo_cidr_add(cf, ctx, &amp;cidr, &amp;value[1], net);&#125;2.5 获取解析好的变量值，调用ngx_http_geo_range_variable函数实现，接下来看看这个函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081static ngx_int_tngx_http_geo_range_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data)&#123; ngx_http_geo_ctx_t *ctx = (ngx_http_geo_ctx_t *) data; in_addr_t inaddr; ngx_addr_t addr; ngx_uint_t n; struct sockaddr_in *sin; ngx_http_geo_range_t *range;#if (NGX_HAVE_INET6) u_char *p; struct in6_addr *inaddr6;#endif *v = *ctx-&gt;u.high.default_value; if (ngx_http_geo_addr(r, ctx, &amp;addr) == NGX_OK) &#123; switch (addr.sockaddr-&gt;sa_family) &#123;#if (NGX_HAVE_INET6) case AF_INET6: inaddr6 = &amp;((struct sockaddr_in6 *) addr.sockaddr)-&gt;sin6_addr; if (IN6_IS_ADDR_V4MAPPED(inaddr6)) &#123; p = inaddr6-&gt;s6_addr; inaddr = p[12] &lt;&lt; 24; inaddr += p[13] &lt;&lt; 16; inaddr += p[14] &lt;&lt; 8; inaddr += p[15]; &#125; else &#123; inaddr = INADDR_NONE; &#125; break;#endif#if (NGX_HAVE_UNIX_DOMAIN) case AF_UNIX: inaddr = INADDR_NONE; break;#endif default: /* AF_INET */ sin = (struct sockaddr_in *) addr.sockaddr; inaddr = ntohl(sin-&gt;sin_addr.s_addr); break; &#125; &#125; else &#123; inaddr = INADDR_NONE; &#125; if (ctx-&gt;u.high.low) &#123; range = ctx-&gt;u.high.low[inaddr &gt;&gt; 16]; if (range) &#123; n = inaddr &amp; 0xffff; do &#123; if (n &gt;= (ngx_uint_t) range-&gt;start &amp;&amp; n &lt;= (ngx_uint_t) range-&gt;end) &#123; *v = *range-&gt;value; break; &#125; &#125; while ((++range)-&gt;value); &#125; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, &quot;http geo: %v&quot;, v); return NGX_OK;&#125;3、总结以上就是整个geo模块的核心，stream下的geo模块实现方式类似。s","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的map模块","slug":"Nginx的map模块","date":"2019-10-12T01:25:27.000Z","updated":"2019-12-31T11:47:17.757Z","comments":true,"path":"2019/10/12/Nginx的map模块/","link":"","permalink":"https://weeweetan.github.io/2019/10/12/Nginx的map模块/","excerpt":"","text":"1、相关配置geo模块配置指令如下：12345map $var1 $var2 &#123; &#125;详细用法参考nginx官方文档,此模块的功能是将$var1通过{}中的匹配条件生成$var2的值，支持正则表达式。2、代码详解2.1、首先来看看配置解析函数，负责解析map指令后的两个变量，并设置获取变量值的函数指针123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194static char *ngx_http_map_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_map_conf_t *mcf = conf; char *rv; ngx_str_t *value, name; ngx_conf_t save; ngx_pool_t *pool; ngx_hash_init_t hash; ngx_http_map_ctx_t *map; ngx_http_variable_t *var; ngx_http_map_conf_ctx_t ctx; ngx_http_compile_complex_value_t ccv; if (mcf-&gt;hash_max_size == NGX_CONF_UNSET_UINT) &#123; mcf-&gt;hash_max_size = 2048; &#125; if (mcf-&gt;hash_bucket_size == NGX_CONF_UNSET_UINT) &#123; mcf-&gt;hash_bucket_size = ngx_cacheline_size; &#125; else &#123; mcf-&gt;hash_bucket_size = ngx_align(mcf-&gt;hash_bucket_size, ngx_cacheline_size); &#125; map = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_map_ctx_t)); if (map == NULL) &#123; return NGX_CONF_ERROR; &#125; value = cf-&gt;args-&gt;elts; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = &amp;value[1]; ccv.complex_value = &amp;map-&gt;value; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; name = value[2]; if (name.data[0] != '$') &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;name); return NGX_CONF_ERROR; &#125; name.len--; name.data++; var = ngx_http_add_variable(cf, &amp;name, NGX_HTTP_VAR_CHANGEABLE); if (var == NULL) &#123; return NGX_CONF_ERROR; &#125; var-&gt;get_handler = ngx_http_map_variable; var-&gt;data = (uintptr_t) map; pool = ngx_create_pool(NGX_DEFAULT_POOL_SIZE, cf-&gt;log); if (pool == NULL) &#123; return NGX_CONF_ERROR; &#125; ctx.keys.pool = cf-&gt;pool; ctx.keys.temp_pool = pool; if (ngx_hash_keys_array_init(&amp;ctx.keys, NGX_HASH_LARGE) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; ctx.values_hash = ngx_pcalloc(pool, sizeof(ngx_array_t) * ctx.keys.hsize); if (ctx.values_hash == NULL) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125;#if (NGX_PCRE) if (ngx_array_init(&amp;ctx.regexes, cf-&gt;pool, 2, sizeof(ngx_http_map_regex_t)) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125;#endif ctx.default_value = NULL; ctx.cf = &amp;save; ctx.hostnames = 0; ctx.no_cacheable = 0; save = *cf; cf-&gt;pool = pool; cf-&gt;ctx = &amp;ctx; cf-&gt;handler = ngx_http_map; cf-&gt;handler_conf = conf; rv = ngx_conf_parse(cf, NULL); *cf = save; if (rv != NGX_CONF_OK) &#123; ngx_destroy_pool(pool); return rv; &#125; if (ctx.no_cacheable) &#123; var-&gt;flags |= NGX_HTTP_VAR_NOCACHEABLE; &#125; map-&gt;default_value = ctx.default_value ? ctx.default_value: &amp;ngx_http_variable_null_value; map-&gt;hostnames = ctx.hostnames; hash.key = ngx_hash_key_lc; hash.max_size = mcf-&gt;hash_max_size; hash.bucket_size = mcf-&gt;hash_bucket_size; hash.name = \"map_hash\"; hash.pool = cf-&gt;pool; if (ctx.keys.keys.nelts) &#123; hash.hash = &amp;map-&gt;map.hash.hash; hash.temp_pool = NULL; if (ngx_hash_init(&amp;hash, ctx.keys.keys.elts, ctx.keys.keys.nelts) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; &#125; if (ctx.keys.dns_wc_head.nelts) &#123; ngx_qsort(ctx.keys.dns_wc_head.elts, (size_t) ctx.keys.dns_wc_head.nelts, sizeof(ngx_hash_key_t), ngx_http_map_cmp_dns_wildcards); hash.hash = NULL; hash.temp_pool = pool; if (ngx_hash_wildcard_init(&amp;hash, ctx.keys.dns_wc_head.elts, ctx.keys.dns_wc_head.nelts) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; map-&gt;map.hash.wc_head = (ngx_hash_wildcard_t *) hash.hash; &#125; if (ctx.keys.dns_wc_tail.nelts) &#123; ngx_qsort(ctx.keys.dns_wc_tail.elts, (size_t) ctx.keys.dns_wc_tail.nelts, sizeof(ngx_hash_key_t), ngx_http_map_cmp_dns_wildcards); hash.hash = NULL; hash.temp_pool = pool; if (ngx_hash_wildcard_init(&amp;hash, ctx.keys.dns_wc_tail.elts, ctx.keys.dns_wc_tail.nelts) != NGX_OK) &#123; ngx_destroy_pool(pool); return NGX_CONF_ERROR; &#125; map-&gt;map.hash.wc_tail = (ngx_hash_wildcard_t *) hash.hash; &#125;#if (NGX_PCRE) if (ctx.regexes.nelts) &#123; map-&gt;map.regex = ctx.regexes.elts; map-&gt;map.nregex = ctx.regexes.nelts; &#125;#endif ngx_destroy_pool(pool); return rv;&#125;2.2、解析map块中的内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210static char *ngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)&#123; u_char *data; size_t len; ngx_int_t rv; ngx_str_t *value, v; ngx_uint_t i, key; ngx_http_map_conf_ctx_t *ctx; ngx_http_complex_value_t cv, *cvp; ngx_http_variable_value_t *var, **vp; ngx_http_compile_complex_value_t ccv; ctx = cf-&gt;ctx; value = cf-&gt;args-&gt;elts; if (cf-&gt;args-&gt;nelts == 1 &amp;&amp; ngx_strcmp(value[0].data, \"hostnames\") == 0) &#123; ctx-&gt;hostnames = 1; return NGX_CONF_OK; &#125; if (cf-&gt;args-&gt;nelts == 1 &amp;&amp; ngx_strcmp(value[0].data, \"volatile\") == 0) &#123; ctx-&gt;no_cacheable = 1; return NGX_CONF_OK; &#125; if (cf-&gt;args-&gt;nelts != 2) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid number of the map parameters\"); return NGX_CONF_ERROR; &#125; if (ngx_strcmp(value[0].data, \"include\") == 0) &#123; return ngx_conf_include(cf, dummy, conf); &#125; key = 0; for (i = 0; i &lt; value[1].len; i++) &#123; key = ngx_hash(key, value[1].data[i]); &#125; key %= ctx-&gt;keys.hsize; vp = ctx-&gt;values_hash[key].elts; if (vp) &#123; for (i = 0; i &lt; ctx-&gt;values_hash[key].nelts; i++) &#123; if (vp[i]-&gt;valid) &#123; data = vp[i]-&gt;data; len = vp[i]-&gt;len; &#125; else &#123; cvp = (ngx_http_complex_value_t *) vp[i]-&gt;data; data = cvp-&gt;value.data; len = cvp-&gt;value.len; &#125; if (value[1].len != len) &#123; continue; &#125; if (ngx_strncmp(value[1].data, data, len) == 0) &#123; var = vp[i]; goto found; &#125; &#125; &#125; else &#123; if (ngx_array_init(&amp;ctx-&gt;values_hash[key], cf-&gt;pool, 4, sizeof(ngx_http_variable_value_t *)) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125; var = ngx_palloc(ctx-&gt;keys.pool, sizeof(ngx_http_variable_value_t)); if (var == NULL) &#123; return NGX_CONF_ERROR; &#125; v.len = value[1].len; v.data = ngx_pstrdup(ctx-&gt;keys.pool, &amp;value[1]); if (v.data == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = ctx-&gt;cf; ccv.value = &amp;v; ccv.complex_value = &amp;cv; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (cv.lengths != NULL) &#123; cvp = ngx_palloc(ctx-&gt;keys.pool, sizeof(ngx_http_complex_value_t)); if (cvp == NULL) &#123; return NGX_CONF_ERROR; &#125; *cvp = cv; var-&gt;len = 0; var-&gt;data = (u_char *) cvp; var-&gt;valid = 0; &#125; else &#123; var-&gt;len = v.len; var-&gt;data = v.data; var-&gt;valid = 1; &#125; var-&gt;no_cacheable = 0; var-&gt;not_found = 0; vp = ngx_array_push(&amp;ctx-&gt;values_hash[key]); if (vp == NULL) &#123; return NGX_CONF_ERROR; &#125; *vp = var;found: if (ngx_strcmp(value[0].data, \"default\") == 0) &#123; if (ctx-&gt;default_value) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"duplicate default map parameter\"); return NGX_CONF_ERROR; &#125; ctx-&gt;default_value = var; return NGX_CONF_OK; &#125;#if (NGX_PCRE) if (value[0].len &amp;&amp; value[0].data[0] == '~') &#123; ngx_regex_compile_t rc; ngx_http_map_regex_t *regex; u_char errstr[NGX_MAX_CONF_ERRSTR]; regex = ngx_array_push(&amp;ctx-&gt;regexes); if (regex == NULL) &#123; return NGX_CONF_ERROR; &#125; value[0].len--; value[0].data++; ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t)); if (value[0].data[0] == '*') &#123; value[0].len--; value[0].data++; rc.options = NGX_REGEX_CASELESS; &#125; rc.pattern = value[0]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; regex-&gt;regex = ngx_http_regex_compile(ctx-&gt;cf, &amp;rc); if (regex-&gt;regex == NULL) &#123; return NGX_CONF_ERROR; &#125; regex-&gt;value = var; return NGX_CONF_OK; &#125;#endif if (value[0].len &amp;&amp; value[0].data[0] == '\\\\') &#123; value[0].len--; value[0].data++; &#125; rv = ngx_hash_add_key(&amp;ctx-&gt;keys, &amp;value[0], var, (ctx-&gt;hostnames) ? NGX_HASH_WILDCARD_KEY : 0); if (rv == NGX_OK) &#123; return NGX_CONF_OK; &#125; if (rv == NGX_DECLINED) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid hostname or wildcard \\\"%V\\\"\", &amp;value[0]); &#125; if (rv == NGX_BUSY) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"conflicting parameter \\\"%V\\\"\", &amp;value[0]); &#125; return NGX_CONF_ERROR;&#125;s3、总结map模块生成的变量遵循nginx的变量规则，获取变量值的方式也与nginx其他变量类似","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx变量详解","slug":"Nginx变量详解","date":"2019-10-12T01:19:08.000Z","updated":"2020-02-03T09:29:04.682Z","comments":true,"path":"2019/10/12/Nginx变量详解/","link":"","permalink":"https://weeweetan.github.io/2019/10/12/Nginx变量详解/","excerpt":"","text":"1、源码解析1.1 变量分类nginx变量分为两种，一种是nginx内置变量，可以通过官方网站查询到的含义，另外一种则是在nginx配置文件中通过set指令设置的变量，首先来看一下nginx的内置变量实现方式。1.1.1 nginx内置变量首先看看定义内置变量的结构体12345678struct ngx_http_variable_s &#123; ngx_str_t name; /* must be first to build the hash */ ngx_http_set_variable_pt set_handler; ngx_http_get_variable_pt get_handler; uintptr_t data; ngx_uint_t flags; ngx_uint_t index;&#125;;上面这个结构体中，name代表变量名称，比如$request_uri,$args等，set_handler暂时没有使用到，get_handler获取变量值，data一般表示为变量值来自于这里，flags表示此变量遵循的一些规则，比如NGX_HTTP_VAR_CHANGEABLE，index表示此变量在整个nginx变量系统中的索引。接下来就是将变量添加到nginx的变量系统中了，这里以http模块的核心变量为例进行说明。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778ngx_http_variable_t *ngx_http_add_variable(ngx_conf_t *cf, ngx_str_t *name, ngx_uint_t flags)&#123; ngx_int_t rc; ngx_uint_t i; ngx_hash_key_t *key; ngx_http_variable_t *v; ngx_http_core_main_conf_t *cmcf; if (name-&gt;len == 0) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"$\\\"\"); return NULL; &#125; if (flags &amp; NGX_HTTP_VAR_PREFIX) &#123; return ngx_http_add_prefix_variable(cf, name, flags); &#125; cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module); key = cmcf-&gt;variables_keys-&gt;keys.elts; for (i = 0; i &lt; cmcf-&gt;variables_keys-&gt;keys.nelts; i++) &#123; if (name-&gt;len != key[i].key.len || ngx_strncasecmp(name-&gt;data, key[i].key.data, name-&gt;len) != 0) &#123; continue; &#125; v = key[i].value; if (!(v-&gt;flags &amp; NGX_HTTP_VAR_CHANGEABLE)) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"the duplicate \\\"%V\\\" variable\", name); return NULL; &#125; if (!(flags &amp; NGX_HTTP_VAR_WEAK)) &#123; v-&gt;flags &amp;= ~NGX_HTTP_VAR_WEAK; &#125; return v; &#125; v = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_variable_t)); if (v == NULL) &#123; return NULL; &#125; v-&gt;name.len = name-&gt;len; v-&gt;name.data = ngx_pnalloc(cf-&gt;pool, name-&gt;len); if (v-&gt;name.data == NULL) &#123; return NULL; &#125; ngx_strlow(v-&gt;name.data, name-&gt;data, name-&gt;len); v-&gt;set_handler = NULL; v-&gt;get_handler = NULL; v-&gt;data = 0; v-&gt;flags = flags; v-&gt;index = 0; rc = ngx_hash_add_key(cmcf-&gt;variables_keys, &amp;v-&gt;name, v, 0); if (rc == NGX_ERROR) &#123; return NULL; &#125; if (rc == NGX_BUSY) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"conflicting variable name \\\"%V\\\"\", name); return NULL; &#125; return v;&#125;这个函数的作用就是将定义的变量添加到http核心配置中，为获取变量的值做好准备，其他变量类似。接下来就是如何获取变量值了，http的日志模块提供了一个很好的范本。1.1.2 配置文件变量配置文件变量是指set指令设置的变量，1set $a value;具体可以参考set，首先来看看set指令解析函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; ngx_int_t index; ngx_str_t *value; ngx_http_variable_t *v; ngx_http_script_var_code_t *vcode; ngx_http_script_var_handler_code_t *vhcode; value = cf-&gt;args-&gt;elts; if (value[1].data[0] != '$') &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;value[1]); return NGX_CONF_ERROR; &#125; value[1].len--; value[1].data++; v = ngx_http_add_variable(cf, &amp;value[1], NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_WEAK); if (v == NULL) &#123; return NGX_CONF_ERROR; &#125; index = ngx_http_get_variable_index(cf, &amp;value[1]); if (index == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125; if (v-&gt;get_handler == NULL) &#123; v-&gt;get_handler = ngx_http_rewrite_var; v-&gt;data = index; &#125; if (ngx_http_rewrite_value(cf, lcf, &amp;value[2]) != NGX_CONF_OK) &#123; return NGX_CONF_ERROR; &#125; if (v-&gt;set_handler) &#123; vhcode = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_var_handler_code_t)); if (vhcode == NULL) &#123; return NGX_CONF_ERROR; &#125; vhcode-&gt;code = ngx_http_script_var_set_handler_code; vhcode-&gt;handler = v-&gt;set_handler; vhcode-&gt;data = v-&gt;data; return NGX_CONF_OK; &#125; vcode = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_var_code_t)); if (vcode == NULL) &#123; return NGX_CONF_ERROR; &#125; vcode-&gt;code = ngx_http_script_set_var_code; vcode-&gt;index = (uintptr_t) index; return NGX_CONF_OK;&#125;这个函数首先解析出第一个变量的名字，并将其加入到nginx的变量系统中，其次解析作为第一个值的变量(第二个变量)，但是第二个变量可能是一个普通的字符串也有可能是多个变量组成的字符串，都是在ngx_http_rewrite_value函数中进行处理，接下来看看ngx_http_rewrite_value函数实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static char *ngx_http_rewrite_value(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value)&#123; ngx_int_t n; ngx_http_script_compile_t sc; ngx_http_script_value_code_t *val; ngx_http_script_complex_value_code_t *complex; n = ngx_http_script_variables_count(value); if (n == 0) &#123; val = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_value_code_t)); if (val == NULL) &#123; return NGX_CONF_ERROR; &#125; n = ngx_atoi(value-&gt;data, value-&gt;len); if (n == NGX_ERROR) &#123; n = 0; &#125; val-&gt;code = ngx_http_script_value_code; val-&gt;value = (uintptr_t) n; val-&gt;text_len = (uintptr_t) value-&gt;len; val-&gt;text_data = (uintptr_t) value-&gt;data; return NGX_CONF_OK; &#125; //带有$的变量，value也是变量，如set $aa $bb，这里的$bb就是变量， complex = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_complex_value_code_t)); if (complex == NULL) &#123; return NGX_CONF_ERROR; &#125; complex-&gt;code = ngx_http_script_complex_value_code; complex-&gt;lengths = NULL; ngx_memzero(&amp;sc, sizeof(ngx_http_script_compile_t)); sc.cf = cf; sc.source = value; sc.lengths = &amp;complex-&gt;lengths; sc.values = &amp;lcf-&gt;codes; sc.variables = n; sc.complete_lengths = 1; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK;&#125;这个函数中，n为0表示value不包含变量，为纯字符串，否则表示value中包含变量，采用复杂变量解析方式。2、总结以上就是Nginx变量的相关解释，Nginx变量在nginx.conf配置文件中有着至关重要的作用，可定制性强。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的轮询算法","slug":"Nginx的轮询算法","date":"2019-09-15T10:27:13.000Z","updated":"2020-02-12T09:49:37.064Z","comments":true,"path":"2019/09/15/Nginx的轮询算法/","link":"","permalink":"https://weeweetan.github.io/2019/09/15/Nginx的轮询算法/","excerpt":"","text":"1、概述Nginx轮询算法应用于http模块和stream模块的upstream块，根据权重选择相应的服务器进行负载均衡。1.1、相关配置1234567891011http &#123; upstream backend &#123; server 127.0.0.1:8080 weight=10; server 192.168.1.2:8080 weight=10; &#125;&#125;&gt;若upstream块中没有指定负载均衡算法，则默认使用轮询算法。2、算法实现Nginx中http_upstream_module跟stream_upstream_module模块都使用了轮询算法，这里以stream_upstrean模块为例2.1、相关结构体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566typedef struct &#123; ngx_stream_upstream_rr_peers_t *peers; ngx_stream_upstream_rr_peer_t *current; uintptr_t *tried; uintptr_t data; //若后端服务器数量小于32，则使用此字段表示各个服务器是否使用&#125; ngx_stream_upstream_rr_peer_data_t;typedef struct ngx_stream_upstream_rr_peer_s ngx_stream_upstream_rr_peer_t;struct ngx_stream_upstream_rr_peer_s &#123; struct sockaddr *sockaddr; socklen_t socklen; ngx_str_t name; ngx_str_t server; ngx_int_t current_weight; ngx_int_t effective_weight; //RR算法权重，初始值与weight相同 ngx_int_t weight; //配置的权重 ngx_uint_t conns; //该后端peer上面的成功连接数 ngx_uint_t fails; //已尝试失败次数 time_t accessed; time_t checked; ngx_uint_t max_fails; time_t fail_timeout; ngx_uint_t down; /* unsigned down:1; */#if (NGX_STREAM_SSL) void *ssl_session; int ssl_session_len;#endif ngx_stream_upstream_rr_peer_t *next;#if (NGX_STREAM_UPSTREAM_ZONE) ngx_atomic_t lock;#endif&#125;;typedef struct ngx_stream_upstream_rr_peers_s ngx_stream_upstream_rr_peers_t;struct ngx_stream_upstream_rr_peers_s &#123; ngx_uint_t number; //服务器数量 为后端配置了多少个服务器 #if (NGX_STREAM_UPSTREAM_ZONE) ngx_slab_pool_t *shpool; ngx_atomic_t rwlock;#endif ngx_uint_t total_weight; //所有服务器的权重和 unsigned single:1; //是否只有一个服务器 unsigned weighted:1; ngx_str_t *name; ngx_stream_upstream_rr_peers_t *next; ngx_stream_upstream_rr_peer_t *peer; //服务器信息 //所有的peer[]服务器信息通过peers-&gt;peer连接在一起&#125;;上述3个结构体是整个轮询算法的核心，ngx_stream_upstream_rr_peer_data_t结构体保存已经选择过的服务器以及当前选择的服务器，ngx_stream_upstream_rr_peers_t结构体中几个weight成员用来选择服务器。2.1 初始化ngx_stream_upstream_rr_peer_t结构体Nginx在解析配置文件时，当解析到upstream块时，会调用ngx_stream_upstream_init_round_robin函数，将配置文件中的server保存在ngx_stream_upstream_rr_peer_t结构体中。接下来看看ngx_stream_upstream_init_round_robin函数定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210ngx_int_tngx_stream_upstream_init_round_robin(ngx_conf_t *cf, ngx_stream_upstream_srv_conf_t *us)&#123; ngx_url_t u; ngx_uint_t i, j, n, w; ngx_stream_upstream_server_t *server; ngx_stream_upstream_rr_peer_t *peer, **peerp; ngx_stream_upstream_rr_peers_t *peers, *backup;//一个是正常的servers，一个是backup servers us-&gt;peer.init = ngx_stream_upstream_init_round_robin_peer;//upstream中服务器节点的初始化赋值 if (us-&gt;servers) &#123; server = us-&gt;servers-&gt;elts; n = 0; w = 0; for (i = 0; i &lt; us-&gt;servers-&gt;nelts; i++) &#123; if (server[i].backup) &#123; continue; &#125; n += server[i].naddrs; w += server[i].naddrs * server[i].weight; &#125; if (n == 0) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, \"no servers in upstream \\\"%V\\\" in %s:%ui\", &amp;us-&gt;host, us-&gt;file_name, us-&gt;line); return NGX_ERROR; &#125; peers = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peers_t)); if (peers == NULL) &#123; return NGX_ERROR; &#125; peer = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peer_t) * n); if (peer == NULL) &#123; return NGX_ERROR; &#125; peers-&gt;single = (n == 1); peers-&gt;number = n; peers-&gt;weighted = (w != n); peers-&gt;total_weight = w; peers-&gt;name = &amp;us-&gt;host; n = 0; peerp = &amp;peers-&gt;peer; for (i = 0; i &lt; us-&gt;servers-&gt;nelts; i++) &#123; if (server[i].backup) &#123; continue; &#125; for (j = 0; j &lt; server[i].naddrs; j++) &#123; peer[n].sockaddr = server[i].addrs[j].sockaddr; peer[n].socklen = server[i].addrs[j].socklen; peer[n].name = server[i].addrs[j].name; peer[n].weight = server[i].weight; peer[n].effective_weight = server[i].weight; peer[n].current_weight = 0; peer[n].max_fails = server[i].max_fails; peer[n].fail_timeout = server[i].fail_timeout; peer[n].down = server[i].down; peer[n].server = server[i].name; *peerp = &amp;peer[n]; peerp = &amp;peer[n].next; n++; &#125; &#125; us-&gt;peer.data = peers; /* backup servers */ n = 0; w = 0; for (i = 0; i &lt; us-&gt;servers-&gt;nelts; i++) &#123; if (!server[i].backup) &#123; continue; &#125; n += server[i].naddrs; w += server[i].naddrs * server[i].weight; &#125; if (n == 0) &#123; return NGX_OK; &#125; backup = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peers_t)); if (backup == NULL) &#123; return NGX_ERROR; &#125; peer = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peer_t) * n); if (peer == NULL) &#123; return NGX_ERROR; &#125; peers-&gt;single = 0; backup-&gt;single = 0; backup-&gt;number = n; backup-&gt;weighted = (w != n); backup-&gt;total_weight = w; backup-&gt;name = &amp;us-&gt;host; n = 0; peerp = &amp;backup-&gt;peer; for (i = 0; i &lt; us-&gt;servers-&gt;nelts; i++) &#123; if (!server[i].backup) &#123; continue; &#125; for (j = 0; j &lt; server[i].naddrs; j++) &#123; peer[n].sockaddr = server[i].addrs[j].sockaddr; peer[n].socklen = server[i].addrs[j].socklen; peer[n].name = server[i].addrs[j].name; peer[n].weight = server[i].weight; peer[n].effective_weight = server[i].weight; peer[n].current_weight = 0; peer[n].max_fails = server[i].max_fails; peer[n].fail_timeout = server[i].fail_timeout; peer[n].down = server[i].down; peer[n].server = server[i].name; *peerp = &amp;peer[n]; peerp = &amp;peer[n].next; n++; &#125; &#125; peers-&gt;next = backup; return NGX_OK; &#125; /* an upstream implicitly defined by proxy_pass, etc. */ if (us-&gt;port == 0) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, \"no port in upstream \\\"%V\\\" in %s:%ui\", &amp;us-&gt;host, us-&gt;file_name, us-&gt;line); return NGX_ERROR; &#125; ngx_memzero(&amp;u, sizeof(ngx_url_t)); u.host = us-&gt;host; u.port = us-&gt;port; if (ngx_inet_resolve_host(cf-&gt;pool, &amp;u) != NGX_OK) &#123; if (u.err) &#123; ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, 0, \"%s in upstream \\\"%V\\\" in %s:%ui\", u.err, &amp;us-&gt;host, us-&gt;file_name, us-&gt;line); &#125; return NGX_ERROR; &#125; n = u.naddrs; peers = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peers_t)); if (peers == NULL) &#123; return NGX_ERROR; &#125; peer = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_stream_upstream_rr_peer_t) * n); if (peer == NULL) &#123; return NGX_ERROR; &#125; peers-&gt;single = (n == 1); peers-&gt;number = n; peers-&gt;weighted = 0; peers-&gt;total_weight = n; peers-&gt;name = &amp;us-&gt;host; peerp = &amp;peers-&gt;peer; for (i = 0; i &lt; u.naddrs; i++) &#123; peer[i].sockaddr = u.addrs[i].sockaddr; peer[i].socklen = u.addrs[i].socklen; peer[i].name = u.addrs[i].name; peer[i].weight = 1; peer[i].effective_weight = 1; peer[i].current_weight = 0; peer[i].max_fails = 1; peer[i].fail_timeout = 10; *peerp = &amp;peer[i]; peerp = &amp;peer[i].next; &#125; us-&gt;peer.data = peers; /* implicitly defined upstream has no backup servers */ return NGX_OK;&#125;如果没有指定其他负载均衡算法，则此函数在配置解析阶段执行，由ngx_stream_upstream_init_main_conf函数调用执行。将配置中的后端服务器使用peer连接起来，对backup服务器采取同样的操作。3、总结","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx链接自定义静态库","slug":"Nginx链接自定义静态库","date":"2019-08-13T02:06:23.000Z","updated":"2019-08-30T07:27:44.819Z","comments":true,"path":"2019/08/13/Nginx链接自定义静态库/","link":"","permalink":"https://weeweetan.github.io/2019/08/13/Nginx链接自定义静态库/","excerpt":"","text":"1.准备静态库1.1 编译静态库使用gcc将源代码编译为目标文件123gcc -c test.c-c选项只编译不链接，生成目标对象文件，编译成功会生成test.o文件，接着对test.o文件进行打包1.2 打包静态库使用ar命令将test.o打包为静态库文件123ar -crv libtest.a test.o在定义静态库文件文件名时，需要遵从命名规则。2.配置静态库将生成的libtest.a 复制到/usr/lib64目录下，如有头文件，则复制到/usr/include目录下3.修改Nginx编译脚本在auto/unix脚本中修改变量CORE_LIBS的值123CORE_LIBS =\"$CORE_LIBS -ltest\"4. 使用第三方开发库4.1 安装第三方开发库123yum -y install xxx xxx-devel安装成功后，在/usr/include/目录下能找到相应的头文件，在/usr/lib64/目录下能找到类似于libxxx.so的文件4.2 在源码中包含第三方库的头文件，就可以使用相应的函数了4.3 修改Nginx编译脚本在auto/unix脚本中修改变量CORE_LIBS的值123CORE_LIBS =\"$CORE_LIBS -lxxx\"","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的rewrite模块详解","slug":"Nginx的rewrite模块详解","date":"2019-08-09T06:06:55.000Z","updated":"2019-09-01T13:47:08.189Z","comments":true,"path":"2019/08/09/Nginx的rewrite模块详解/","link":"","permalink":"https://weeweetan.github.io/2019/08/09/Nginx的rewrite模块详解/","excerpt":"","text":"1.相关指令1.1 if指令1Context: server, location依据指定的条件决定是否执行 if 块语句中的内容1.2 break指令1Context: server, location, if停止执行 ngx_http_rewrite_module 的指令集，但是其他模块指令是不受影响的1.3 rewrite指令123Context: server, location, ifrewrite regex replacement [flag];rewrite 指令是使用指定的正则表达式regex来匹配请求的urI，如果匹配成功，则使用replacement更改URI。rewrite指令按照它们在配置文件中出现的顺序执行。可以使用flag标志来终止指令的进一步处理。如果替换字符串replacement以http：//，https：//或$scheme开头，则停止处理后续内容，并直接重定向返回给客户端。1.4 return指令123456Context: server, location, ifreturn code [text];return code URL;return URL;停止处理并将指定的code码返回给客户端。 非标准code码 444 关闭连接而不发送响应报头2.源码解析2.1 rewrite指令源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139static char *ngx_http_rewrite(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; ngx_str_t *value; ngx_uint_t last; ngx_regex_compile_t rc; ngx_http_script_code_pt *code; ngx_http_script_compile_t sc; ngx_http_script_regex_code_t *regex; ngx_http_script_regex_end_code_t *regex_end; u_char errstr[NGX_MAX_CONF_ERRSTR]; regex = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_regex_code_t)); if (regex == NULL) &#123; return NGX_CONF_ERROR; &#125; ngx_memzero(regex, sizeof(ngx_http_script_regex_code_t)); value = cf-&gt;args-&gt;elts; ngx_memzero(&amp;rc, sizeof(ngx_regex_compile_t)); rc.pattern = value[1]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; /* TODO: NGX_REGEX_CASELESS */ //解析正则表达式，填写ngx_http_regex_t结构并返回。正则句柄，命名子模式等都在里面了。 regex-&gt;regex = ngx_http_regex_compile(cf, &amp;rc); if (regex-&gt;regex == NULL) &#123; return NGX_CONF_ERROR; &#125; //将其设置为第一个code函数，求出目标字符串大小。尾部还有ngx_http_script_regex_end_code regex-&gt;code = ngx_http_script_regex_start_code; regex-&gt;uri = 1; regex-&gt;name = value[1]; if (value[2].data[value[2].len - 1] == '?') &#123; /* the last \"?\" drops the original arguments */ value[2].len--; &#125; else &#123; regex-&gt;add_args = 1; &#125; last = 0; if (ngx_strncmp(value[2].data, \"http://\", sizeof(\"http://\") - 1) == 0 || ngx_strncmp(value[2].data, \"https://\", sizeof(\"https://\") - 1) == 0 || ngx_strncmp(value[2].data, \"$scheme\", sizeof(\"$scheme\") - 1) == 0) &#123; regex-&gt;status = NGX_HTTP_MOVED_TEMPORARILY; regex-&gt;redirect = 1; last = 1; &#125; if (cf-&gt;args-&gt;nelts == 4) &#123; if (ngx_strcmp(value[3].data, \"last\") == 0) &#123; last = 1; &#125; else if (ngx_strcmp(value[3].data, \"break\") == 0) &#123; regex-&gt;break_cycle = 1; last = 1; &#125; else if (ngx_strcmp(value[3].data, \"redirect\") == 0) &#123; regex-&gt;status = NGX_HTTP_MOVED_TEMPORARILY; regex-&gt;redirect = 1; last = 1; &#125; else if (ngx_strcmp(value[3].data, \"permanent\") == 0) &#123; regex-&gt;status = NGX_HTTP_MOVED_PERMANENTLY; regex-&gt;redirect = 1; last = 1; &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid parameter \\\"%V\\\"\", &amp;value[3]); return NGX_CONF_ERROR; &#125; &#125; ngx_memzero(&amp;sc, sizeof(ngx_http_script_compile_t)); sc.cf = cf; sc.source = &amp;value[2]; sc.lengths = &amp;regex-&gt;lengths; sc.values = &amp;lcf-&gt;codes; sc.variables = ngx_http_script_variables_count(&amp;value[2]); sc.main = regex; sc.complete_lengths = 1; sc.compile_args = !regex-&gt;redirect; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; regex = sc.main; regex-&gt;size = sc.size; regex-&gt;args = sc.args; if (sc.variables == 0 &amp;&amp; !sc.dup_capture) &#123; regex-&gt;lengths = NULL; &#125; regex_end = ngx_http_script_add_code(lcf-&gt;codes, sizeof(ngx_http_script_regex_end_code_t), &amp;regex); if (regex_end == NULL) &#123; return NGX_CONF_ERROR; &#125; regex_end-&gt;code = ngx_http_script_regex_end_code; //结束回调，对应前面的开始。 regex_end-&gt;uri = regex-&gt;uri; regex_end-&gt;args = regex-&gt;args; regex_end-&gt;add_args = regex-&gt;add_args; regex_end-&gt;redirect = regex-&gt;redirect; if (last) &#123; code = ngx_http_script_add_code(lcf-&gt;codes, sizeof(uintptr_t), &amp;regex); if (code == NULL) &#123; return NGX_CONF_ERROR; &#125; *code = NULL; &#125; //下一个解析句柄组的地址。如果匹配失败，则会直接跳过该regex匹配相关的所有code regex-&gt;next = (u_char *) lcf-&gt;codes-&gt;elts + lcf-&gt;codes-&gt;nelts - (u_char *) regex; return NGX_CONF_OK;&#125;2.2 return指令源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static char *ngx_http_rewrite_return(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; u_char *p; ngx_str_t *value, *v; ngx_http_script_return_code_t *ret; ngx_http_compile_complex_value_t ccv; ret = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_return_code_t)); if (ret == NULL) &#123; return NGX_CONF_ERROR; &#125; value = cf-&gt;args-&gt;elts; ngx_memzero(ret, sizeof(ngx_http_script_return_code_t)); //注册code为ngx_http_script_return_code ret-&gt;code = ngx_http_script_return_code; p = value[1].data; ret-&gt;status = ngx_atoi(p, value[1].len); if (ret-&gt;status == (uintptr_t) NGX_ERROR) &#123; if (cf-&gt;args-&gt;nelts == 2 &amp;&amp; (ngx_strncmp(p, \"http://\", sizeof(\"http://\") - 1) == 0 || ngx_strncmp(p, \"https://\", sizeof(\"https://\") - 1) == 0 || ngx_strncmp(p, \"$scheme\", sizeof(\"$scheme\") - 1) == 0)) &#123; ret-&gt;status = NGX_HTTP_MOVED_TEMPORARILY; v = &amp;value[1]; &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid return code \\\"%V\\\"\", &amp;value[1]); return NGX_CONF_ERROR; &#125; &#125; else &#123; if (ret-&gt;status &gt; 999) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid return code \\\"%V\\\"\", &amp;value[1]); return NGX_CONF_ERROR; &#125; if (cf-&gt;args-&gt;nelts == 2) &#123; return NGX_CONF_OK; &#125; v = &amp;value[2]; &#125; ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t)); ccv.cf = cf; ccv.value = v; ccv.complex_value = &amp;ret-&gt;text; if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; return NGX_CONF_OK;&#125;2.3 break指令源码解析123456789101112131415161718static char *ngx_http_rewrite_break(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; ngx_http_script_code_pt *code; code = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(uintptr_t)); if (code == NULL) &#123; return NGX_CONF_ERROR; &#125; *code = ngx_http_script_break_code; return NGX_CONF_OK;&#125;配合ngx_http_rewrite_handler读代码，可以看到如果设置一个code节点到codes数组，那么在ngx_http_rewrite_handler的for循环执行到该节点code的时候，就会把e-&gt;ip置为NULL，这样就直接退出while ((uintptr_t ) e-&gt;ip){}循环2.4 if指令源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120static char * ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; void *mconf; char *rv; u_char *elts; ngx_uint_t i; ngx_conf_t save; ngx_http_module_t *module; ngx_http_conf_ctx_t *ctx, *pctx; ngx_http_core_loc_conf_t *clcf, *pclcf; ngx_http_script_if_code_t *if_code; ngx_http_rewrite_loc_conf_t *nlcf; //if的解析过程和location&#123;&#125;解析过程差不多,也有ctx ctx = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_conf_ctx_t)); if (ctx == NULL) &#123; return NGX_CONF_ERROR; &#125; pctx = cf-&gt;ctx; //父块&#123;&#125;的上下文ctx ctx-&gt;main_conf = pctx-&gt;main_conf; ctx-&gt;srv_conf = pctx-&gt;srv_conf; ctx-&gt;loc_conf = ngx_pcalloc(cf-&gt;pool, sizeof(void *) * ngx_http_max_module); if (ctx-&gt;loc_conf == NULL) &#123; return NGX_CONF_ERROR; &#125; for (i = 0; ngx_modules[i]; i++) &#123; if (ngx_modules[i]-&gt;type != NGX_HTTP_MODULE) &#123; continue; &#125; module = ngx_modules[i]-&gt;ctx; if (module-&gt;create_loc_conf) &#123; /* 在解析if时， nginx会把它当做一个location来对待的，并且它的location type为noname。通过ngx_http_add_location将该“location”添 加到上层的locations中。这里将if看做location自然有它的合理性，因为if的配置也是需要进行url匹配的。 */ mconf = module-&gt;create_loc_conf(cf); if (mconf == NULL) &#123; return NGX_CONF_ERROR; &#125; ctx-&gt;loc_conf[ngx_modules[i]-&gt;ctx_index] = mconf; &#125; &#125; pclcf = pctx-&gt;loc_conf[ngx_http_core_module.ctx_index];//该if&#123;&#125;所在location&#123;&#125;的配置信息 clcf = ctx-&gt;loc_conf[ngx_http_core_module.ctx_index]; //if&#123;&#125;的配置信息 clcf-&gt;loc_conf = ctx-&gt;loc_conf; clcf-&gt;name = pclcf-&gt;name; clcf-&gt;noname = 1; //if配置被作为location的noname形式 if (ngx_http_add_location(cf, &amp;pclcf-&gt;locations, clcf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; if (ngx_http_rewrite_if_condition(cf, lcf) != NGX_CONF_OK) &#123; return NGX_CONF_ERROR; &#125; if_code = ngx_array_push_n(lcf-&gt;codes, sizeof(ngx_http_script_if_code_t)); if (if_code == NULL) &#123; return NGX_CONF_ERROR; &#125; if_code-&gt;code = ngx_http_script_if_code; elts = lcf-&gt;codes-&gt;elts; /* the inner directives must be compiled to the same code array */ nlcf = ctx-&gt;loc_conf[ngx_http_rewrite_module.ctx_index]; nlcf-&gt;codes = lcf-&gt;codes; save = *cf; cf-&gt;ctx = ctx; if (pclcf-&gt;name.len == 0) &#123; if_code-&gt;loc_conf = NULL; cf-&gt;cmd_type = NGX_HTTP_SIF_CONF; &#125; else &#123; if_code-&gt;loc_conf = ctx-&gt;loc_conf; cf-&gt;cmd_type = NGX_HTTP_LIF_CONF; &#125; rv = ngx_conf_parse(cf, NULL); *cf = save; if (rv != NGX_CONF_OK) &#123; return rv; &#125; if (elts != lcf-&gt;codes-&gt;elts) &#123; if_code = (ngx_http_script_if_code_t *) ((u_char *) if_code + ((u_char *) lcf-&gt;codes-&gt;elts - elts)); &#125; if_code-&gt;next = (u_char *) lcf-&gt;codes-&gt;elts + lcf-&gt;codes-&gt;nelts - (u_char *) if_code; /* the code array belong to parent block */ nlcf-&gt;codes = NULL; return NGX_CONF_OK;&#125;2.5 set指令源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*Syntax: set $variable value1. 将$variable加入到变量系统中，cmcf-&gt;variables_keys-&gt;keys和cmcf-&gt;variables。a. 如果value是简单字符串，那么解析之后，lcf-&gt;codes就会追加这样的到后面: ngx_http_script_value_code 直接简单字符串指向一下就行，都不用拷贝了。b. 如果value是复杂的包含变量的串，那么lcf-&gt;codes就会追加如下的进去 : ngx_http_script_complex_value_code 调用lengths的lcode获取组合字符串的总长度，并且申请内存 lengths values，这里根据表达式的不同而不同。 分别将value代表的复杂表达式拆分成语法单元，进行一个个求值，并合并在一起。 ngx_http_script_set_var_code 负责将上述合并出的最终结果设置到variables[]数组中去。*/static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_rewrite_loc_conf_t *lcf = conf; ngx_int_t index; ngx_str_t *value; ngx_http_variable_t *v; ngx_http_script_var_code_t *vcode; ngx_http_script_var_handler_code_t *vhcode; value = cf-&gt;args-&gt;elts; if (value[1].data[0] != '$') &#123;//变量必须以$开头 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, \"invalid variable name \\\"%V\\\"\", &amp;value[1]); return NGX_CONF_ERROR; &#125; value[1].len--; value[1].data++; //下面根据这个变量名，将其加入到cmcf-&gt;variables_keys-&gt;keys里面。 v = ngx_http_add_variable(cf, &amp;value[1], NGX_HTTP_VAR_CHANGEABLE); if (v == NULL) &#123; return NGX_CONF_ERROR; &#125; //将其加入到cmcf-&gt;variables里面，并返回其下标 index = ngx_http_get_variable_index(cf, &amp;value[1]); if (index == NGX_ERROR) &#123; return NGX_CONF_ERROR; &#125; //set $variable value中的第一个参数$variable对应的在这里或者ngx_http_variables_init_vars设置ngx_http_variable_t的get_handler和data成员 if (v-&gt;get_handler == NULL &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"http_\", 5) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"sent_http_\", 10) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"upstream_http_\", 14) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"cookie_\", 7) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"upstream_cookie_\", 16) != 0 &amp;&amp; ngx_strncasecmp(value[1].data, (u_char *) \"arg_\", 4) != 0) //如果变量名称不是以上开头，则其get_handler为ngx_http_rewrite_var，data为index 。 &#123; //设置一个默认的handler。在ngx_http_variables_init_vars里面其实是会将上面这些\"http_\" \"sent_http_\"这些变量get_hendler的 v-&gt;get_handler = ngx_http_rewrite_var; v-&gt;data = index; &#125;/* 脚本引擎是一系列的凹调函数以及相关数据（它们被组织成ngx_httpscript_ xxx_codet这样的结构体，代表各种不同功能的操作步骤），被保存在变量lcf-&gt;codes数组内，而ngx_httprewrite_loc_conf_t类型变量Icf是与当前location相关联的，所以这个脚本引擎只有当客户端请求访问当前这个location时才会被启动执行。如下配置中，“set $file t_a;”构建的脚本引擎只有当客户端请求访问/t日录时才会被触发，如果当客户端请求访问根目录时则与它毫无关系。 location / &#123; root web; &#125; location /t &#123; set $file t_a; &#125;*/ //ngx_http_rewrite_handler中会移除执行lcf-&gt;codes数组中的各个ngx_http_script_xxx_code_t-&gt;code函数， //set $variable value的value参数在这里处理 , /* 从下面可以看出没set一次就会创建一个ngx_http_script_var_code_t和ngx_http_script_xxx_value_code_t但是如果连续多次设置同样的 变量不同的值，那么就会有多个var_code_t和value_code_t对，实际上在ngx_http_rewrite_handler变量执行的时候，以最后面的为准，例如: 50： location / &#123; 51： root web; 52: set $file indexl.html; 53： index $file; 54： 65: set $file index2.html; &#125; 上面的例子追踪访问到的是index2.html */ /* 如果set $variable value中的value是普通字符串，则下面的ngx_http_rewrite_value从ngx_http_rewrite_loc_conf_t-&gt;codes数组中获取ngx_http_script_value_code_t空间，紧接着在后面的ngx_http_script_start_code函数同样从ngx_http_rewrite_loc_conf_t-&gt;codes数组中获取ngx_http_script_var_code_t空间，因此在codes数组中存放变量值value的ngx_http_script_value_code_t空间与存放var变量名的ngx_http_script_var_code_t在空间上是靠着的，图形化见&lt;深入剖析nginx 图8-4&gt; 如果set $variable value中的value是变量名，则下面的ngx_http_rewrite_value从ngx_http_rewrite_loc_conf_t-&gt;codes数组中获取ngx_http_script_complex_value_code_t空间，紧接着在后面的 ngx_http_script_start_code函数同样从ngx_http_rewrite_loc_conf_t-&gt;codes数组中获取ngx_http_script_complex_value_code_t空间，因此在codes数组中 存放变量值value的ngx_http_script_value_code_t空间与存放var变量名的ngx_http_script_var_code_t在空间上是靠着的，图形化见&lt;深入剖析nginx 图8-4&gt; */// if (ngx_http_rewrite_value(cf, lcf, &amp;value[2]) != NGX_CONF_OK) &#123; return NGX_CONF_ERROR; &#125; if (v-&gt;set_handler) &#123; vhcode = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_var_handler_code_t)); if (vhcode == NULL) &#123; return NGX_CONF_ERROR; &#125; vhcode-&gt;code = ngx_http_script_var_set_handler_code; vhcode-&gt;handler = v-&gt;set_handler; vhcode-&gt;data = v-&gt;data; return NGX_CONF_OK; &#125; vcode = ngx_http_script_start_code(cf-&gt;pool, &amp;lcf-&gt;codes, sizeof(ngx_http_script_var_code_t)); if (vcode == NULL) &#123; return NGX_CONF_ERROR; &#125; vcode-&gt;code = ngx_http_script_set_var_code; vcode-&gt;index = (uintptr_t) index; return NGX_CONF_OK;&#125;3.总结","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx的upstream模块","slug":"Nginx的upstream模块","date":"2019-07-16T14:58:54.000Z","updated":"2020-04-05T02:38:28.851Z","comments":true,"path":"2019/07/16/Nginx的upstream模块/","link":"","permalink":"https://weeweetan.github.io/2019/07/16/Nginx的upstream模块/","excerpt":"","text":"1.相关配置upstream模块的典型应用是反向代理，这里就以ngx_http_proxy_module模块为例。假定我们有如下这样的实例环境，客户端对服务器80端口的请求都被Nginx Proxy Server转发到另外两个真实的Nginx Web Server实例上进行处理（下图是实验环境，Web Server和Proxy Server都只是Nginx进程，并且运行在同一台服务器）：那么，Nginx Proxy Server的核心配置多半是这样：123456789101112131415161718 Filename : nginx.conf …http &#123; … upstream load_balance &#123; server localhost:8001; server localhost:8002; &#125; server &#123; listen 80; location / &#123; proxy_buffering off; proxy_pass http://load_balance; &#125; &#125; &#125;上面的proxy_buffering off;配置是为了禁用nginx反向代理的缓存功能，保证客户端的每次请求都被转发到后端真实服务器，以便我们每次跟踪分析的nginx执行流程更加简单且完整。而另外两个配置指令upstream和proxy_pass在此处显得更为重要，其中upstream配置指令的回调处理函数为ngx_http_upstream()，该函数除了申请内存、设置初始值等之外，最主要的动作就是切换配置上下文并调用ngx_conf_parse()函数继续进行配置解析：2.源码解析12345678Filename : ngx_http_upstream.c pcf = *cf; cf-&gt;ctx = ctx; cf-&gt;cmd_type = NGX_HTTP_UPS_CONF; rv = ngx_conf_parse(cf, NULL); … if (uscf-&gt;servers == NULL) &#123;进入到upstream配置块内，最主要的配置指令也就是server，其对应的处理函数为ngx_http_upstream_server()，对于每一个后端真实服务器，除了其uri地址外，还有诸如down、weight、max_fails、fail_timeout、backup这样的可选参数，所有这些都需要ngx_http_upstream_server()函数来处理。在ngx_http_upstream.c的第4173行下个断点，我们可以看到这里给出示例的解析结果：另外一个重要配置指令proxy_pass主要出现在location配置上下文中，而其对应的处理函数为ngx_http_proxy_pass()，抹去该函数内的众多细节，我们重点关注两个赋值语句：12345678Filename : ngx_http_proxy_module.c static char * ngx_http_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) &#123; … clcf-&gt;handler = ngx_http_proxy_handler; … plcf-&gt;upstream.upstream = ngx_http_upstream_add(cf, &amp;u, 0);上面片段代码里的第一个赋值语句给当前location的http处理设置回调函数，而第二个赋值语句则是查找（没有找到则会创建，比如如果配置文件中upstream指令出现在proxy_pass指令的后面）其对应的upstream配置，我们这里就一个名为load_balance的upstream，所以找到的配置就是它了：前面曾提到，Nginx将对客户端的http请求处理分为多个阶段，而其中有个NGX_HTTP_FIND_CONFIG_PHASE阶段主要就是做配置查找处理，如果当前请求location设置了upstream，即回调函数指针clcf-&gt;handler不为空，则表示对该location的请求需要后端真实服务器来处理：12345678910111213141516Filename : ngx_http_core_module.c ngx_int_t ngx_http_core_find_config_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph) &#123; … ngx_http_update_location_config(r); … void ngx_http_update_location_config(ngx_http_request_t *r) &#123; … if (clcf-&gt;handler) &#123; r-&gt;content_handler = clcf-&gt;handler; &#125; &#125;在其它有location更新的情况下，比如redirect重定向location或named命名location或if条件location等，此时也会调用ngx_http_update_location_config()函数进行location配置更新。我们知道upstream模块的主要功能是产生响应数据，虽然这些响应数据来自后端真实服务器，所以在NGX_HTTP_CONTENT_PHASE 阶段的checker函数ngx_http_core_content_phase()内，我们可以看到在r-&gt;content_handler不为空的情况下会优先对r-&gt;content_handler函数指针进行回调：123456789101112Filename : ngx_http_core_module.c ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph) &#123; … if (r-&gt;content_handler) &#123; r-&gt;write_event_handler = ngx_http_request_empty_handler; ngx_http_finalize_request(r, r-&gt;content_handler(r)); return NGX_OK; &#125; …如果r-&gt;content_handler不为空，即存在upstream，那么进入处理，注意第1397行直接返回NGX_OK，也即不再调用挂在该阶段的其它模块回调函数，所以说upstream模块的优先级是最高的。根据前面的回调赋值，调用r-&gt;content_handler()指针函数，实质上就是执行函数ngx_http_proxy_handler()，直到这里，我们才真正走进upstream代理模块的处理逻辑里。3.回调函数对于任何一个Upstream模块而言，最核心的实现主要是7个回调函数，upstream代理模块自然也不例外，它实现并注册了这7个回调函数：回调指针函数功能upstream代理模块create_request根据nginx与后端服务器通信协议（比如HTTP、Memcache），将客户端的HTTP请求信息转换为对应的发送到后端服务器的真实请求ngx_http_proxy_create_request 由于nginx与后端服务器通信协议也为HTTP，所以直接拷贝客户端的请求头、请求体（如果有）到变量r-&gt;upstream-&gt;request_bufs内。process_header根据nginx与后端服务器通信协议，将后端服务器返回的头部信息转换为对客户端响应的HTTP响应头。ngx_http_proxy_process_status_line 此时后端服务器返回的头部信息已经保存在变量r-&gt;upstream-&gt;buffer内，将这串字符串解析为HTTP响应头存储到变量r-&gt;upstream-&gt;headers_in内。input_filter_init根据前面获得的后端服务器返回的头部信息，为进一步处理后端服务器将返回的响应体做初始准备工作。ngx_http_proxy_input_filter_init 根据已解析的后端服务器返回的头部信息，设置需进一步处理的后端服务器将返回的响应体的长度，该值保存在变量r-&gt;upstream-&gt;length内。input_filter正式处理后端服务器返回的响应体ngx_http_proxy_non_buffered_copy_filter 本次收到的响应体数据长度为bytes，数据长度存储在r-&gt;upstream-&gt;buffer内，把它加入到r-&gt;upstream-&gt;out_bufs响应数据链等待发送给客户端。finalize_request正常结束与后端服务器的交互，比如剩余待取数据长度为0或读到EOF等，之后就会调用该函数。由于nginx会自动完成与后端服务器交互的清理工作，所以该函数一般仅做下日志，标识响应正常结束。ngx_http_proxy_finalize_request 记录一条日志，标识正常结束与后端服务器的交互，然后函数返回。reinit_request对交互重新初始化，比如当nginx发现一台后端服务器出错无法正常完成处理，需要尝试请求另一台后端服务器时就会调用该函数。ngx_http_proxy_reinit_request设置初始值，设置回调指针，处理比较简单。abort_request异常结束与后端服务器的交互后就会调用该函数。大部分情况下，该函数仅做下日志，标识响应异常结束。ngx_http_proxy_abort_request记录一条日志，标识异常结束与后端服务器的交互，然后函数返回。上表格中前面5个函数执行的先后次序如下图所示，由于在Client/Proxy/Server之间，一次请求/响应数据可以发送多次（下图中只画出一次就发送完毕的情况），所以下图中对应的函数也可能被执行多次，不过一般情况下，这5个函数执行的先后次序就是这样了。4.总结这些回调函数如何夹杂到nginx中被调用并不需要完全搞清楚，要写一个Upstream模块，我们只要实现上面提到的这7个函数即可，当然，可以看到最主要的也就是create_request、process_header和input_filter这三个回调，它们实现从HTTP协议到Nginx与后端服务器之间交互协议的来回转换，使得在用户看来，他访问的就是一台功能完整的Web服务器，而也许事实上，显示在他面前的数据来自Memcache或别的什么服务器。参考文献：nginx核心讲解","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx缓存详解","slug":"Nginx缓存详解","date":"2019-06-27T12:56:57.000Z","updated":"2019-09-12T08:40:11.814Z","comments":true,"path":"2019/06/27/Nginx缓存详解/","link":"","permalink":"https://weeweetan.github.io/2019/06/27/Nginx缓存详解/","excerpt":"","text":"1. 相关配置1.1 配置指令Nginx缓存由proxy_cache_path指令开启1proxy_cache_path D:\\output levels=1:2 keys_zone=my_cache:10m max_size=2g inactive=60m use_temp_path=off;对于每个参数的具体含义可以参考nginx官方文档，对于缓存文件名则需要proxy_cache_key指令指定1proxy_cache my_cache;对于该指令的具体用法可以参考nginx官方文档1proxy_cache_valid 200 1h;需要注意的是，如果没有这条指令，nginx将不会缓存上游的数据。对于该指令的具体用法可以参考nginx官方文档2. 源码解析Nginx与文件缓存相关的代码在src/http/ngx_http_file_cache.c2.1 关键结构体与缓存相关的结构体有ngx_path_t、ngx_http_file_cache_sh_t、ngx_http_file_cache_s 、ngx_http_file_cache_node_t、 ngx_http_file_cache_header_t，来看看这几个结构体的定义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158typedef struct &#123; ngx_str_t name; size_t len; size_t level[3]; ngx_path_manager_pt manager; //决定是否启用cache manager进程 ngx_path_loader_pt loader; //决定是否启用cache loader进程 void *data; u_char *conf_file; //nginx配置文件路径 ngx_uint_t line;&#125; ngx_path_t;typedef struct &#123; ngx_rbtree_t rbtree; ngx_rbtree_node_t sentinel; ngx_queue_t queue; ngx_atomic_t cold; ngx_atomic_t loading; off_t size; ngx_uint_t count; ngx_uint_t watermark;&#125; ngx_http_file_cache_sh_t;struct ngx_http_file_cache_s &#123; ngx_http_file_cache_sh_t *sh; ngx_slab_pool_t *shpool; /* shpool是用于管理共享内存的 slab allocator ，所有缓存节点占用空间都由它进行分配 */ ngx_path_t *path; /* ngx_http_file_cache_set_slot中创建ngx_path_t空间 */ off_t max_size; size_t bsize; time_t inactive; /* 触发LRU算法阈值 */ time_t fail_time; ngx_uint_t files; ngx_uint_t loader_files; /* 阈值，当load的文件个数大于这个值之后，load进程会短暂的休眠(时间位loader_sleep) */ ngx_msec_t last; ngx_msec_t loader_sleep; /* 阈值，执行一次缓存文件到共享内存后 , 进程的休眠时间 , 默认200 */ ngx_msec_t loader_threshold; ngx_uint_t manager_files; ngx_msec_t manager_sleep; ngx_msec_t manager_threshold; ngx_shm_zone_t *shm_zone; ngx_uint_t use_temp_path; /* unsigned use_temp_path:1 */&#125;;typedef struct &#123; ngx_rbtree_node_t node; /* 缓存查询树的节点 */ ngx_queue_t queue; /* LRU页面置换算法 队列中的节点 */ u_char key[NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t)]; unsigned count:20; unsigned uses:10; unsigned valid_msec:10; unsigned error:10; unsigned exists:1; unsigned updating:1; unsigned deleting:1; unsigned purged:1; /* 10 unused bits */ ngx_file_uniq_t uniq; time_t expire; time_t valid_sec; size_t body_start; off_t fs_size; ngx_msec_t lock_time;&#125; ngx_http_file_cache_node_t;//在写缓存文件时会将这个结构体写入typedef struct &#123; ngx_uint_t version; time_t valid_sec; time_t updating_sec; time_t error_sec; time_t last_modified; time_t date; uint32_t crc32; u_short valid_msec; u_short header_start; /* 缓存文件中http头开始的偏移 */ u_short body_start; u_char etag_len; u_char etag[NGX_HTTP_CACHE_ETAG_LEN]; u_char vary_len; u_char vary[NGX_HTTP_CACHE_VARY_LEN]; u_char variant[NGX_HTTP_CACHE_KEY_LEN];&#125; ngx_http_file_cache_header_t;struct ngx_http_cache_s &#123; ngx_file_t file; /* 缓存文件描述结构体 */ ngx_array_t keys; /* 存放proxy_cache_key指令的值 */ uint32_t crc32; u_char key[NGX_HTTP_CACHE_KEY_LEN]; /* 存放计算md5后的值 */ u_char main[NGX_HTTP_CACHE_KEY_LEN]; /* 跟key相同 */ ngx_file_uniq_t uniq; time_t valid_sec; time_t updating_sec; time_t error_sec; time_t last_modified; time_t date; ngx_str_t etag; ngx_str_t vary; u_char variant[NGX_HTTP_CACHE_KEY_LEN]; size_t header_start; /* http头在缓存中的偏移位置 */ size_t body_start; /* http响应体在缓存中的偏移位置 */ off_t length; /* 缓存文件的大小，见ngx_http_file_cache_open */ off_t fs_size; ngx_uint_t min_uses; ngx_uint_t error; ngx_uint_t valid_msec; ngx_uint_t vary_tag; ngx_buf_t *buf; /* 存储缓存文件头 */ ngx_http_file_cache_t *file_cache; ngx_http_file_cache_node_t *node; //ngx_http_file_cache_exists中创建空间和赋值#if (NGX_THREADS || NGX_COMPAT) ngx_thread_task_t *thread_task;#endif ngx_msec_t lock_timeout; ngx_msec_t lock_age; ngx_msec_t lock_time; ngx_msec_t wait_time; ngx_event_t wait_event; unsigned lock:1; unsigned waiting:1; unsigned updated:1; unsigned updating:1; unsigned exists:1; unsigned temp_file:1; unsigned purged:1; unsigned reading:1; unsigned secondary:1; unsigned background:1; unsigned stale_updating:1; unsigned stale_error:1;&#125;;部分字段含义见注释2.2 生成标记缓存文件的key生成标记缓存文件的key由ngx_http_file_cache_create_key函数实现，我们来看看具体实现12345678910111213141516171819202122232425262728293031323334353637voidngx_http_file_cache_create_key(ngx_http_request_t *r)&#123; size_t len; ngx_str_t *key; ngx_uint_t i; ngx_md5_t md5; ngx_http_cache_t *c; c = r-&gt;cache; len = 0; ngx_crc32_init(c-&gt;crc32); ngx_md5_init(&amp;md5); key = c-&gt;keys.elts; for (i = 0; i &lt; c-&gt;keys.nelts; i++) &#123; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http cache key: \\\"%V\\\"\", &amp;key[i]); len += key[i].len; ngx_crc32_update(&amp;c-&gt;crc32, key[i].data, key[i].len); ngx_md5_update(&amp;md5, key[i].data, key[i].len); &#125; c-&gt;header_start = sizeof(ngx_http_file_cache_header_t) + sizeof(ngx_http_file_cache_key) + len + 1; ngx_crc32_final(c-&gt;crc32); ngx_md5_final(c-&gt;key, &amp;md5); ngx_memcpy(c-&gt;main, c-&gt;key, NGX_HTTP_CACHE_KEY_LEN);&#125;该函数实现较简单，主要是计算proxy_cache_key指令值的md5值，并保存，然后初始化header_start成员的值，这个地方需要注意一下缓存文件头部信息[ngx_http_file_cache_header_t][“\\nKEY: “][orig_key][“\\n”][header][body]2.3 缓存文件名生成生成缓存文件名主要由ngx_http_file_cache_name实现，现在来看看源码1234567891011121314151617181920212223242526272829303132333435static ngx_int_tngx_http_file_cache_name(ngx_http_request_t *r, ngx_path_t *path)&#123; u_char *p; ngx_http_cache_t *c; c = r-&gt;cache; if (c-&gt;file.name.len) &#123; return NGX_OK; &#125; c-&gt;file.name.len = path-&gt;name.len + 1 + path-&gt;len + 2 * NGX_HTTP_CACHE_KEY_LEN; c-&gt;file.name.data = ngx_pnalloc(r-&gt;pool, c-&gt;file.name.len + 1); if (c-&gt;file.name.data == NULL) &#123; return NGX_ERROR; &#125; ngx_memcpy(c-&gt;file.name.data, path-&gt;name.data, path-&gt;name.len); p = c-&gt;file.name.data + path-&gt;name.len + 1 + path-&gt;len; p = ngx_hex_dump(p, c-&gt;key, NGX_HTTP_CACHE_KEY_LEN); *p = '\\0'; ngx_create_hashed_filename(path, c-&gt;file.name.data, c-&gt;file.name.len); ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"cache file: \\\"%s\\\"\", c-&gt;file.name.data); return NGX_OK;&#125;该函数首先判断当前缓存文件名是否已经生成成功，若已生成，则直接返回，代码如下：123if (c-&gt;file.name.len) &#123; return NGX_OK;&#125;接下来计算缓存文件名长度，其中path-&gt;name.len为proxy_cache_path指令第一个参数，path-&gt;len为levels长度，比如level=1:2则path-&gt;len为5，包含两个/，代码如下：12c-&gt;file.name.len = path-&gt;name.len + 1 + path-&gt;len + 2 * NGX_HTTP_CACHE_KEY_LEN;接着为缓存文件名申请内存，代码如下：1c-&gt;file.name.data = ngx_pnalloc(r-&gt;pool, c-&gt;file.name.len + 1);接着将proxy_cache_path指令设置的路径复制到c-&gt;file.name.data最前端，完成后c-&gt;file.name.data的值为:D:\\output,代码如下：1ngx_memcpy(c-&gt;file.name.data, path-&gt;name.data, path-&gt;name.len);接着将p指向c-&gt;file.name.data偏移 path-&gt;name.len + 1 + path-&gt;len的位置处，这样做的目的是准备生成32位长的md5文件名，并预留level设置的目录123p = c-&gt;file.name.data + path-&gt;name.len + 1 + path-&gt;len;p = ngx_hex_dump(p, c-&gt;key, NGX_HTTP_CACHE_KEY_LEN);*p = '\\0';这一步完成之后c-&gt;file.name.data的值为D:\\output屯屯屯md5(proxy_cache_key)调用ngx_create_hashed_filename函数补全第5步预留的level目录1ngx_create_hashed_filename(path, c-&gt;file.name.data, c-&gt;file.name.len);2.4 生成由levels参数指定的目录层级生成由levels参数指定的目录层级由ngx_create_hashed_filename实现，现在来看看源码1234567891011121314151617181920212223voidngx_create_hashed_filename(ngx_path_t *path, u_char *file, size_t len)&#123; size_t i, level; ngx_uint_t n; i = path-&gt;name.len + 1; file[path-&gt;name.len + path-&gt;len] = '/'; for (n = 0; n &lt; NGX_MAX_PATH_LEVEL; n++) &#123; level = path-&gt;level[n]; if (level == 0) &#123; break; &#125; len -= level; file[i - 1] = '/'; ngx_memcpy(&amp;file[i], &amp;file[len], level); i += level + 1; &#125;&#125;从上一节中我们知道参数file的值为D:\\output屯屯屯md5(proxy_cache_key)，该函数首先用一个变量i保存path长度加1，这个设计非常巧妙，在后续中会使用到，代码如下：1i = path-&gt;name.len + 1;接着修改file的值，在层级目录后添加一个反斜杠，修改后为D:\\output屯屯屯/md5(proxy_cache_key)1file[path-&gt;name.len + path-&gt;len] = '/';接下来进入一个for循环，填充file中的屯屯屯，在第一次循环中首先获取levels=1：2中的1，接着用变量len减去变量level，接着在output后添加一个’/‘，然后将file中从len位置复制1个字符到output/后，修改i的值；第二次循环，首先获取levels=1：2中的2，接着用len减去2，接着在第一次缓存复制的字符后添加一个’/‘，然后把file从len处复制2个字符到上一步的’/‘后，修改i的值；第三次跳出循环，至此填充完成，代码如下：123456789101112for (n = 0; n &lt; NGX_MAX_PATH_LEVEL; n++) &#123; level = path-&gt;level[n]; if (level == 0) &#123; break; &#125; len -= level; file[i - 1] = '/'; ngx_memcpy(&amp;file[i], &amp;file[len], level); i += level + 1;&#125;2.5 从红黑树中查找缓存节点缓存key跟缓存文件名生成好之后，紧接着根据生成好的key从红黑树中查找，若不存在则插入，找到则返回对应的缓存节点，这个功能由ngx_http_file_cache_exists函数实现，我们看看具体实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113static ngx_int_tngx_http_file_cache_exists(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)&#123; ngx_int_t rc; ngx_http_file_cache_node_t *fcn; ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); fcn = c-&gt;node;//后面没找到则会创建node节点 if (fcn == NULL) &#123; fcn = ngx_http_file_cache_lookup(cache, c-&gt;key); //以 c-&gt;key 为查找条件从缓存中查找缓存节点： &#125; if (fcn) &#123; //cache中存在该key ngx_queue_remove(&amp;fcn-&gt;queue); //该客户端在新建连接后，如果之前有缓存该文件，则c-&gt;node为NULL，表示这个连接请求第一次走到这里，有一个客户端在获取数据，如果在 //连接范围内(还没有断开连接)多次获取该缓存文件，则也只会加1，表示当前有多少个客户端连接在获取该缓存 if (c-&gt;node == NULL) &#123; //如果该请求第一次使用此缓存节点，则增加相关引用和使用次数 fcn-&gt;uses++; fcn-&gt;count++; &#125; if (fcn-&gt;error) &#123; if (fcn-&gt;valid_sec &lt; ngx_time()) &#123; goto renew; //缓存已过期 &#125; rc = NGX_OK; goto done; &#125; if (fcn-&gt;exists || fcn-&gt;uses &gt;= c-&gt;min_uses) &#123; //该请求的缓存已经存在，并且对该缓存的请求次数达到了最低要求次数min_uses //表示该缓存文件是否存在，Proxy_cache_min_uses 3，则第3次后开始获取后端数据，获取完毕后在ngx_http_file_cache_update中置1，但是只有在地4次请求的时候才会在ngx_http_file_cache_exists赋值为1 c-&gt;exists = fcn-&gt;exists; if (fcn-&gt;body_start) &#123; c-&gt;body_start = fcn-&gt;body_start; &#125; rc = NGX_OK; goto done; &#125; //例如配置Proxy_cache_min_uses 5，则需要客户端请求5才才能从缓存中取，如果现在只有4次，则都需要从后端获取数据 rc = NGX_AGAIN; goto done; &#125; //没找到，则在下面创建node节点，添加到ngx_http_file_cache_t-&gt;sh-&gt;rbtree红黑树中 fcn = ngx_slab_calloc_locked(cache-&gt;shpool, sizeof(ngx_http_file_cache_node_t)); if (fcn == NULL) &#123; ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); (void) ngx_http_file_cache_forced_expire(cache); ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); fcn = ngx_slab_calloc_locked(cache-&gt;shpool, sizeof(ngx_http_file_cache_node_t)); if (fcn == NULL) &#123; ngx_log_error(NGX_LOG_ALERT, ngx_cycle-&gt;log, 0, &quot;could not allocate node%s&quot;, cache-&gt;shpool-&gt;log_ctx); rc = NGX_ERROR; goto failed; &#125; &#125; ngx_memcpy((u_char *) &amp;fcn-&gt;node.key, c-&gt;key, sizeof(ngx_rbtree_key_t)); ngx_memcpy(fcn-&gt;key, &amp;c-&gt;key[sizeof(ngx_rbtree_key_t)], NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t)); ngx_rbtree_insert(&amp;cache-&gt;sh-&gt;rbtree, &amp;fcn-&gt;node); //把该节点添加到红黑树中 fcn-&gt;uses = 1; fcn-&gt;count = 1;renew: rc = NGX_DECLINED; //uri第一次请求的时候创建node节点，同时返回NGX_DECLINED。或者缓存过期需要把该节点相关信息恢复为默认值 fcn-&gt;valid_msec = 0; fcn-&gt;error = 0; fcn-&gt;exists = 0; fcn-&gt;valid_sec = 0; fcn-&gt;uniq = 0; fcn-&gt;body_start = 0; fcn-&gt;fs_size = 0;done: fcn-&gt;expire = ngx_time() + cache-&gt;inactive; ngx_queue_insert_head(&amp;cache-&gt;sh-&gt;queue, &amp;fcn-&gt;queue); //新创建的node节点添加到cache-&gt;sh-&gt;queue头部 c-&gt;uniq = fcn-&gt;uniq;//文件的uniq 赋值见ngx_http_file_cache_update c-&gt;error = fcn-&gt;error; c-&gt;node = fcn; //把新创建的fcn赋值给c-&gt;nodefailed: ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); return rc;&#125;2.6 打开缓存文件上一节中介绍了如何从红黑树中查找缓存节点，找到缓存节点之后，就要需要根据缓存节点中的缓存文件路径去打开缓存文件了，Nginx使用ngx_http_file_cache_open函数实现，接下来我们来看看实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137ngx_int_tngx_http_file_cache_open(ngx_http_request_t *r)&#123; ngx_int_t rc, rv; ngx_uint_t test; ngx_http_cache_t *c; ngx_pool_cleanup_t *cln; ngx_open_file_info_t of; ngx_http_file_cache_t *cache; ngx_http_core_loc_conf_t *clcf; c = r-&gt;cache; if (c-&gt;waiting) &#123; return NGX_AGAIN; &#125; if (c-&gt;reading) &#123; return ngx_http_file_cache_read(r, c); &#125; cache = c-&gt;file_cache; if (c-&gt;node == NULL) &#123; cln = ngx_pool_cleanup_add(r-&gt;pool, 0); if (cln == NULL) &#123; return NGX_ERROR; &#125; cln-&gt;handler = ngx_http_file_cache_cleanup; cln-&gt;data = c; &#125; rc = ngx_http_file_cache_exists(cache, c); ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http file cache exists: %i e:%d\", rc, c-&gt;exists); if (rc == NGX_ERROR) &#123; return rc; &#125; if (rc == NGX_AGAIN) &#123; return NGX_HTTP_CACHE_SCARCE; &#125; if (rc == NGX_OK) &#123; if (c-&gt;error) &#123; return c-&gt;error; &#125; c-&gt;temp_file = 1; test = c-&gt;exists ? 1 : 0; rv = NGX_DECLINED; &#125; else &#123; /* rc == NGX_DECLINED */ test = cache-&gt;sh-&gt;cold ? 1 : 0; if (c-&gt;min_uses &gt; 1) &#123; if (!test) &#123; return NGX_HTTP_CACHE_SCARCE; &#125; rv = NGX_HTTP_CACHE_SCARCE; &#125; else &#123; c-&gt;temp_file = 1; rv = NGX_DECLINED; &#125; &#125; if (ngx_http_file_cache_name(r, cache-&gt;path) != NGX_OK) &#123; return NGX_ERROR; &#125; if (!test) &#123; goto done; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); ngx_memzero(&amp;of, sizeof(ngx_open_file_info_t)); of.uniq = c-&gt;uniq; of.valid = clcf-&gt;open_file_cache_valid; of.min_uses = clcf-&gt;open_file_cache_min_uses; of.events = clcf-&gt;open_file_cache_events; of.directio = NGX_OPEN_FILE_DIRECTIO_OFF; of.read_ahead = clcf-&gt;read_ahead; if (ngx_open_cached_file(clcf-&gt;open_file_cache, &amp;c-&gt;file.name, &amp;of, r-&gt;pool) != NGX_OK) &#123; switch (of.err) &#123; case 0: return NGX_ERROR; case NGX_ENOENT: case NGX_ENOTDIR: goto done; default: ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, of.err, ngx_open_file_n \" \\\"%s\\\" failed\", c-&gt;file.name.data); return NGX_ERROR; &#125; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http file cache fd: %d\", of.fd); c-&gt;file.fd = of.fd; c-&gt;file.log = r-&gt;connection-&gt;log; c-&gt;uniq = of.uniq; c-&gt;length = of.size; c-&gt;fs_size = (of.fs_size + cache-&gt;bsize - 1) / cache-&gt;bsize; c-&gt;buf = ngx_create_temp_buf(r-&gt;pool, c-&gt;body_start); if (c-&gt;buf == NULL) &#123; return NGX_ERROR; &#125; return ngx_http_file_cache_read(r, c);done: if (rv == NGX_DECLINED) &#123; return ngx_http_file_cache_lock(r, c); &#125; return rv;&#125;2.7 读缓存文件若缓存文件存在，则会读取缓存文件头部，并根据读取出的头部信息进行下一步操作，nginx使用ngx_http_file_cache_read函数实现这个功能，我们来看一下具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144static ngx_int_tngx_http_file_cache_read(ngx_http_request_t *r, ngx_http_cache_t *c)&#123; u_char *p; time_t now; ssize_t n; ngx_str_t *key; ngx_int_t rc; ngx_uint_t i; ngx_http_file_cache_t *cache; ngx_http_file_cache_header_t *h; n = ngx_http_file_cache_aio_read(r, c); if (n &lt; 0) &#123; return n; &#125; //写缓冲区封装过程参考:ngx_http_upstream_process_header //缓存文件中前面部分格式:[ngx_http_file_cache_header_t][\"\\nKEY: \"][orig_key][\"\\n\"][header] if ((size_t) n &lt; c-&gt;header_start) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" is too small\", c-&gt;file.name.data); return NGX_DECLINED; &#125; h = (ngx_http_file_cache_header_t *) c-&gt;buf-&gt;pos; if (h-&gt;version != NGX_HTTP_CACHE_VERSION) &#123; ngx_log_error(NGX_LOG_INFO, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" version mismatch\", c-&gt;file.name.data); return NGX_DECLINED; //如果返回这个NGX_DECLINED，会把cached置0，返回出去后只有从后端从新获取数据 &#125; if (h-&gt;crc32 != c-&gt;crc32 || (size_t) h-&gt;header_start != c-&gt;header_start) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" has md5 collision\", c-&gt;file.name.data); return NGX_DECLINED; &#125; p = c-&gt;buf-&gt;pos + sizeof(ngx_http_file_cache_header_t) + sizeof(ngx_http_file_cache_key); key = c-&gt;keys.elts; for (i = 0; i &lt; c-&gt;keys.nelts; i++) &#123; if (ngx_memcmp(p, key[i].data, key[i].len) != 0) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" has md5 collision\", c-&gt;file.name.data); return NGX_DECLINED; &#125; p += key[i].len; &#125; if ((size_t) h-&gt;body_start &gt; c-&gt;body_start) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" has too long header\", c-&gt;file.name.data); return NGX_DECLINED; &#125; if (h-&gt;vary_len &gt; NGX_HTTP_CACHE_VARY_LEN) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" has incorrect vary length\", c-&gt;file.name.data); return NGX_DECLINED; &#125; if (h-&gt;vary_len) &#123; ngx_http_file_cache_vary(r, h-&gt;vary, h-&gt;vary_len, c-&gt;variant); if (ngx_memcmp(c-&gt;variant, h-&gt;variant, NGX_HTTP_CACHE_KEY_LEN) != 0) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http file cache vary mismatch\"); return ngx_http_file_cache_reopen(r, c); &#125; &#125; c-&gt;buf-&gt;last += n; c-&gt;valid_sec = h-&gt;valid_sec; c-&gt;updating_sec = h-&gt;updating_sec; c-&gt;error_sec = h-&gt;error_sec; c-&gt;last_modified = h-&gt;last_modified; c-&gt;date = h-&gt;date; c-&gt;valid_msec = h-&gt;valid_msec; c-&gt;body_start = h-&gt;body_start; c-&gt;etag.len = h-&gt;etag_len; c-&gt;etag.data = h-&gt;etag; r-&gt;cached = 1; cache = c-&gt;file_cache; if (cache-&gt;sh-&gt;cold) &#123; ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); if (!c-&gt;node-&gt;exists) &#123; c-&gt;node-&gt;uses = 1; c-&gt;node-&gt;body_start = c-&gt;body_start; c-&gt;node-&gt;exists = 1; c-&gt;node-&gt;uniq = c-&gt;uniq; c-&gt;node-&gt;fs_size = c-&gt;fs_size; cache-&gt;sh-&gt;size += c-&gt;fs_size; &#125; ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); &#125; now = ngx_time(); if (c-&gt;valid_sec &lt; now) &#123; c-&gt;stale_updating = c-&gt;valid_sec + c-&gt;updating_sec &gt;= now; c-&gt;stale_error = c-&gt;valid_sec + c-&gt;error_sec &gt;= now; ngx_shmtx_lock(&amp;cache-&gt;shpool-&gt;mutex); if (c-&gt;node-&gt;updating) &#123; rc = NGX_HTTP_CACHE_UPDATING; &#125; else &#123; c-&gt;node-&gt;updating = 1; c-&gt;updating = 1; c-&gt;lock_time = c-&gt;node-&gt;lock_time; rc = NGX_HTTP_CACHE_STALE; &#125; ngx_shmtx_unlock(&amp;cache-&gt;shpool-&gt;mutex); ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, \"http file cache expired: %i %T %T\", rc, c-&gt;valid_sec, now); return rc; &#125; return NGX_OK;&#125;调用ngx_http_file_cache_aio_read函数读取缓存文件，读取大小为c-&gt;header_start，读取完成后，对返回值进行校验，确定是否读取成功，代码如下：12345678910111213n = ngx_http_file_cache_aio_read(r, c);if (n &lt; 0) &#123; return n;&#125;if ((size_t) n &lt; c-&gt;header_start) &#123; ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" is too small\", c-&gt;file.name.data); return NGX_DECLINED;&#125;取出缓存文件头部，并对其字段进行校验，封包过程参考ngx_http_file_cache_set_header函数123h = (ngx_http_file_cache_header_t *) c-&gt;buf-&gt;pos;使用读出的缓存文件头部，更新内存中缓存节点信息12345678910111213c-&gt;buf-&gt;last += n; //buf后续会被用来存放http头，所以这个地方移动last指针c-&gt;valid_sec = h-&gt;valid_sec;c-&gt;updating_sec = h-&gt;updating_sec;c-&gt;error_sec = h-&gt;error_sec;c-&gt;last_modified = h-&gt;last_modified;c-&gt;date = h-&gt;date;c-&gt;valid_msec = h-&gt;valid_msec;c-&gt;body_start = h-&gt;body_start;c-&gt;etag.len = h-&gt;etag_len;c-&gt;etag.data = h-&gt;etag;2.8 发送缓存若2.7节读取缓存文件成功，而且缓存校验也成功，则开始发送缓存内容，该功能由ngx_http_upstream_cache_send函数实现，接下来我们看看源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static ngx_int_tngx_http_upstream_cache_send(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; ngx_int_t rc; ngx_http_cache_t *c; r-&gt;cached = 1; c = r-&gt;cache; if (c-&gt;header_start == c-&gt;body_start) &#123; r-&gt;http_version = NGX_HTTP_VERSION_9; return ngx_http_cache_send(r); &#125; /* TODO: cache stack */ u-&gt;buffer = *c-&gt;buf; u-&gt;buffer.pos += c-&gt;header_start; ngx_memzero(&amp;u-&gt;headers_in, sizeof(ngx_http_upstream_headers_in_t)); u-&gt;headers_in.content_length_n = -1; u-&gt;headers_in.last_modified_time = -1; if (ngx_list_init(&amp;u-&gt;headers_in.headers, r-&gt;pool, 8, sizeof(ngx_table_elt_t)) != NGX_OK) &#123; return NGX_ERROR; &#125; if (ngx_list_init(&amp;u-&gt;headers_in.trailers, r-&gt;pool, 2, sizeof(ngx_table_elt_t)) != NGX_OK) &#123; return NGX_ERROR; &#125; rc = u-&gt;process_header(r); if (rc == NGX_OK) &#123; if (ngx_http_upstream_process_headers(r, u) != NGX_OK) &#123; return NGX_DONE; &#125; return ngx_http_cache_send(r); &#125; if (rc == NGX_ERROR) &#123; return NGX_ERROR; &#125; if (rc == NGX_AGAIN) &#123; rc = NGX_HTTP_UPSTREAM_INVALID_HEADER; &#125; /* rc == NGX_HTTP_UPSTREAM_INVALID_HEADER */ ngx_log_error(NGX_LOG_CRIT, r-&gt;connection-&gt;log, 0, \"cache file \\\"%s\\\" contains invalid header\", c-&gt;file.name.data); /* TODO: delete file */ return rc;&#125;2.9 向上游回源若缓存不存在，nginx则向上游回源，那么整个流程就走到ngx_http_upstream_init_request函数的#if (NGX_HTTP_CACHE)块后，我们来看看其源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269static voidngx_http_upstream_init_request(ngx_http_request_t *r)&#123; ngx_str_t *host; ngx_uint_t i; ngx_resolver_ctx_t *ctx, temp; ngx_http_cleanup_t *cln; ngx_http_upstream_t *u; ngx_http_core_loc_conf_t *clcf; ngx_http_upstream_srv_conf_t *uscf, **uscfp; ngx_http_upstream_main_conf_t *umcf; if (r-&gt;aio) &#123; return; &#125; u = r-&gt;upstream;#if (NGX_HTTP_CACHE) if (u-&gt;conf-&gt;cache) &#123; ngx_int_t rc; rc = ngx_http_upstream_cache(r, u); if (rc == NGX_BUSY) &#123; r-&gt;write_event_handler = ngx_http_upstream_init_request; return; &#125; r-&gt;write_event_handler = ngx_http_request_empty_handler; if (rc == NGX_ERROR) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (rc == NGX_OK) &#123; rc = ngx_http_upstream_cache_send(r, u); if (rc == NGX_DONE) &#123; return; &#125; if (rc == NGX_HTTP_UPSTREAM_INVALID_HEADER) &#123; rc = NGX_DECLINED; r-&gt;cached = 0; u-&gt;buffer.start = NULL; u-&gt;cache_status = NGX_HTTP_CACHE_MISS; u-&gt;request_sent = 1; &#125; if (ngx_http_upstream_cache_background_update(r, u) != NGX_OK) &#123; rc = NGX_ERROR; &#125; &#125; if (rc != NGX_DECLINED) &#123; ngx_http_finalize_request(r, rc); return; &#125; &#125;#endif u-&gt;store = u-&gt;conf-&gt;store; /* *设置Nginx与下游客户端之间TCP连接的检查方法 *实际上，这两个方法都会通过ngx_http_upstream_check_broken_connection方法检查Nginx与下游的连接是否正常，如果出现错误，就会立即终止连接。 */ if (!u-&gt;store &amp;&amp; !r-&gt;post_action &amp;&amp; !u-&gt;conf-&gt;ignore_client_abort) &#123; //注意这时候的r还是客户端的连接，与上游服务器的连接r还没有建立 r-&gt;read_event_handler = ngx_http_upstream_rd_check_broken_connection; r-&gt;write_event_handler = ngx_http_upstream_wr_check_broken_connection; &#125; //有接收到客户端包体，则把包体结构赋值给u-&gt;request_bufs，在后面的if (u-&gt;create_request(r) != NGX_OK) &#123;会用到 if (r-&gt;request_body) &#123; u-&gt;request_bufs = r-&gt;request_body-&gt;bufs; &#125; if (u-&gt;create_request(r) != NGX_OK) &#123; //ngx_http_proxy_create_request ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ngx_http_upstream_set_local(r, u, u-&gt;conf-&gt;local) != NGX_OK) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (u-&gt;conf-&gt;socket_keepalive) &#123; u-&gt;peer.so_keepalive = 1; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); /* 初始化ngx_http_upstream_t结构中成员output向下游发送响应的方式 */ u-&gt;output.alignment = clcf-&gt;directio_alignment; u-&gt;output.pool = r-&gt;pool; u-&gt;output.bufs.num = 1; u-&gt;output.bufs.size = clcf-&gt;client_body_buffer_size; if (u-&gt;output.output_filter == NULL) &#123; u-&gt;output.output_filter = ngx_chain_writer; u-&gt;output.filter_ctx = &amp;u-&gt;writer; &#125; u-&gt;writer.pool = r-&gt;pool; /* 添加用于表示上游响应的状态，例如：错误编码、包体长度等 */ if (r-&gt;upstream_states == NULL) &#123; r-&gt;upstream_states = ngx_array_create(r-&gt;pool, 1, sizeof(ngx_http_upstream_state_t)); if (r-&gt;upstream_states == NULL) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; &#125; else &#123; u-&gt;state = ngx_array_push(r-&gt;upstream_states); if (u-&gt;state == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; ngx_memzero(u-&gt;state, sizeof(ngx_http_upstream_state_t)); &#125; cln = ngx_http_cleanup_add(r, 0); if (cln == NULL) &#123; ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; cln-&gt;handler = ngx_http_upstream_cleanup; //当请求结束时，一定会调用ngx_http_upstream_cleanup方法 cln-&gt;data = r; u-&gt;cleanup = &amp;cln-&gt;handler; if (u-&gt;resolved == NULL) &#123; uscf = u-&gt;conf-&gt;upstream; &#125; else &#123;#if (NGX_HTTP_SSL) u-&gt;ssl_name = u-&gt;resolved-&gt;host;#endif host = &amp;u-&gt;resolved-&gt;host; umcf = ngx_http_get_module_main_conf(r, ngx_http_upstream_module); uscfp = umcf-&gt;upstreams.elts; for (i = 0; i &lt; umcf-&gt;upstreams.nelts; i++) &#123; uscf = uscfp[i]; if (uscf-&gt;host.len == host-&gt;len &amp;&amp; ((uscf-&gt;port == 0 &amp;&amp; u-&gt;resolved-&gt;no_port) || uscf-&gt;port == u-&gt;resolved-&gt;port) &amp;&amp; ngx_strncasecmp(uscf-&gt;host.data, host-&gt;data, host-&gt;len) == 0) &#123; goto found; &#125; &#125; if (u-&gt;resolved-&gt;sockaddr) &#123; if (u-&gt;resolved-&gt;port == 0 &amp;&amp; u-&gt;resolved-&gt;sockaddr-&gt;sa_family != AF_UNIX) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"no port in upstream \\\"%V\\\"\", host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ngx_http_upstream_create_round_robin_peer(r, u-&gt;resolved) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; ngx_http_upstream_connect(r, u); return; &#125; if (u-&gt;resolved-&gt;port == 0) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"no port in upstream \\\"%V\\\"\", host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; temp.name = *host; // 初始化域名解析器 ctx = ngx_resolve_start(clcf-&gt;resolver, &amp;temp); if (ctx == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; if (ctx == NGX_NO_RESOLVER) &#123; ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, \"no resolver defined to resolve %V\", host); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_BAD_GATEWAY); return; &#125; ctx-&gt;name = *host; ctx-&gt;handler = ngx_http_upstream_resolve_handler; //设置域名解析完成后的回调函数。 ctx-&gt;data = r; ctx-&gt;timeout = clcf-&gt;resolver_timeout; u-&gt;resolved-&gt;ctx = ctx; //开始域名解析，没有完成也会返回的。 if (ngx_resolve_name(ctx) != NGX_OK) &#123; u-&gt;resolved-&gt;ctx = NULL; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; return; // 域名还没有解析完成，则直接返回 &#125;found: if (uscf == NULL) &#123; ngx_log_error(NGX_LOG_ALERT, r-&gt;connection-&gt;log, 0, \"no upstream configuration\"); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; u-&gt;upstream = uscf;#if (NGX_HTTP_SSL) u-&gt;ssl_name = uscf-&gt;host;#endif if (uscf-&gt;peer.init(r, uscf) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_HTTP_INTERNAL_SERVER_ERROR); return; &#125; u-&gt;peer.start_time = ngx_current_msec; if (u-&gt;conf-&gt;next_upstream_tries &amp;&amp; u-&gt;peer.tries &gt; u-&gt;conf-&gt;next_upstream_tries) &#123; u-&gt;peer.tries = u-&gt;conf-&gt;next_upstream_tries; &#125; ngx_http_upstream_connect(r, u);&#125;2.10 接受上游返回的数据该功能由ngx_http_upstream_send_response函数实现，我们来看看源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343static voidngx_http_upstream_send_response(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; ssize_t n; ngx_int_t rc; ngx_event_pipe_t *p; ngx_connection_t *c; ngx_http_core_loc_conf_t *clcf; rc = ngx_http_send_header(r); if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;post_action) &#123; ngx_http_upstream_finalize_request(r, u, rc); return; &#125; u-&gt;header_sent = 1; if (u-&gt;upgrade) &#123;#if (NGX_HTTP_CACHE) if (r-&gt;cache) &#123; ngx_http_file_cache_free(r-&gt;cache, u-&gt;pipe-&gt;temp_file); &#125;#endif ngx_http_upstream_upgrade(r, u); return; &#125; c = r-&gt;connection; if (r-&gt;header_only) &#123; if (!u-&gt;buffering) &#123; ngx_http_upstream_finalize_request(r, u, rc); return; &#125; if (!u-&gt;cacheable &amp;&amp; !u-&gt;store) &#123; ngx_http_upstream_finalize_request(r, u, rc); return; &#125; u-&gt;pipe-&gt;downstream_error = 1; &#125; if (r-&gt;request_body &amp;&amp; r-&gt;request_body-&gt;temp_file &amp;&amp; r == r-&gt;main &amp;&amp; !r-&gt;preserve_body &amp;&amp; !u-&gt;conf-&gt;preserve_output) &#123; ngx_pool_run_cleanup_file(r-&gt;pool, r-&gt;request_body-&gt;temp_file-&gt;file.fd); r-&gt;request_body-&gt;temp_file-&gt;file.fd = NGX_INVALID_FILE; &#125; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); if (!u-&gt;buffering) &#123;#if (NGX_HTTP_CACHE) if (r-&gt;cache) &#123; ngx_http_file_cache_free(r-&gt;cache, u-&gt;pipe-&gt;temp_file); &#125;#endif if (u-&gt;input_filter == NULL) &#123; u-&gt;input_filter_init = ngx_http_upstream_non_buffered_filter_init; u-&gt;input_filter = ngx_http_upstream_non_buffered_filter; u-&gt;input_filter_ctx = r; &#125; u-&gt;read_event_handler = ngx_http_upstream_process_non_buffered_upstream; r-&gt;write_event_handler = ngx_http_upstream_process_non_buffered_downstream; r-&gt;limit_rate = 0; if (u-&gt;input_filter_init(u-&gt;input_filter_ctx) == NGX_ERROR) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; if (clcf-&gt;tcp_nodelay &amp;&amp; ngx_tcp_nodelay(c) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; n = u-&gt;buffer.last - u-&gt;buffer.pos; if (n) &#123; u-&gt;buffer.last = u-&gt;buffer.pos; u-&gt;state-&gt;response_length += n; if (u-&gt;input_filter(u-&gt;input_filter_ctx, n) == NGX_ERROR) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; ngx_http_upstream_process_non_buffered_downstream(r); &#125; else &#123; u-&gt;buffer.pos = u-&gt;buffer.start; u-&gt;buffer.last = u-&gt;buffer.start; if (ngx_http_send_special(r, NGX_HTTP_FLUSH) == NGX_ERROR) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; if (u-&gt;peer.connection-&gt;read-&gt;ready || u-&gt;length == 0) &#123; ngx_http_upstream_process_non_buffered_upstream(r, u); &#125; &#125; return; &#125; /* TODO: preallocate event_pipe bufs, look \"Content-Length\" */#if (NGX_HTTP_CACHE) if (r-&gt;cache &amp;&amp; r-&gt;cache-&gt;file.fd != NGX_INVALID_FILE) &#123; ngx_pool_run_cleanup_file(r-&gt;pool, r-&gt;cache-&gt;file.fd); r-&gt;cache-&gt;file.fd = NGX_INVALID_FILE; &#125; switch (ngx_http_test_predicates(r, u-&gt;conf-&gt;no_cache)) &#123; case NGX_ERROR: ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; case NGX_DECLINED: u-&gt;cacheable = 0; break; default: /* NGX_OK */ if (u-&gt;cache_status == NGX_HTTP_CACHE_BYPASS) &#123; /* create cache if previously bypassed */ if (ngx_http_file_cache_create(r) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; &#125; break; &#125; if (u-&gt;cacheable) &#123; time_t now, valid; now = ngx_time(); valid = r-&gt;cache-&gt;valid_sec; if (valid == 0) &#123; valid = ngx_http_file_cache_valid(u-&gt;conf-&gt;cache_valid, u-&gt;headers_in.status_n); if (valid) &#123; r-&gt;cache-&gt;valid_sec = now + valid; &#125; &#125; //如果没有配置proxy_cache_valid，valid的值为0 if (valid) &#123; r-&gt;cache-&gt;date = now; r-&gt;cache-&gt;body_start = (u_short) (u-&gt;buffer.pos - u-&gt;buffer.start); if (u-&gt;headers_in.status_n == NGX_HTTP_OK || u-&gt;headers_in.status_n == NGX_HTTP_PARTIAL_CONTENT) &#123; r-&gt;cache-&gt;last_modified = u-&gt;headers_in.last_modified_time; if (u-&gt;headers_in.etag) &#123; r-&gt;cache-&gt;etag = u-&gt;headers_in.etag-&gt;value; &#125; else &#123; ngx_str_null(&amp;r-&gt;cache-&gt;etag); &#125; &#125; else &#123; r-&gt;cache-&gt;last_modified = -1; ngx_str_null(&amp;r-&gt;cache-&gt;etag); &#125; if (ngx_http_file_cache_set_header(r, u-&gt;buffer.start) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; &#125; else &#123; u-&gt;cacheable = 0; &#125; &#125; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, \"http cacheable: %d\", u-&gt;cacheable); if (u-&gt;cacheable == 0 &amp;&amp; r-&gt;cache) &#123; ngx_http_file_cache_free(r-&gt;cache, u-&gt;pipe-&gt;temp_file); &#125; if (r-&gt;header_only &amp;&amp; !u-&gt;cacheable &amp;&amp; !u-&gt;store) &#123; ngx_http_upstream_finalize_request(r, u, 0); return; &#125;#endif p = u-&gt;pipe; p-&gt;output_filter = ngx_http_upstream_output_filter; p-&gt;output_ctx = r; p-&gt;tag = u-&gt;output.tag; p-&gt;bufs = u-&gt;conf-&gt;bufs; p-&gt;busy_size = u-&gt;conf-&gt;busy_buffers_size; p-&gt;upstream = u-&gt;peer.connection; p-&gt;downstream = c; p-&gt;pool = r-&gt;pool; p-&gt;log = c-&gt;log; p-&gt;limit_rate = u-&gt;conf-&gt;limit_rate; p-&gt;start_sec = ngx_time(); p-&gt;cacheable = u-&gt;cacheable || u-&gt;store; p-&gt;temp_file = ngx_pcalloc(r-&gt;pool, sizeof(ngx_temp_file_t)); if (p-&gt;temp_file == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; p-&gt;temp_file-&gt;file.fd = NGX_INVALID_FILE; p-&gt;temp_file-&gt;file.log = c-&gt;log; p-&gt;temp_file-&gt;path = u-&gt;conf-&gt;temp_path; //u-&gt;conf-&gt;temp_path的值在ngx_http_proxy_handler函数中赋值，赋值流程为ngx_http_proxy_merge_loc_conf-&gt;ngx_conf_merge_path_value p-&gt;temp_file-&gt;pool = r-&gt;pool; if (p-&gt;cacheable) &#123; p-&gt;temp_file-&gt;persistent = 1;#if (NGX_HTTP_CACHE) if (r-&gt;cache &amp;&amp; !r-&gt;cache-&gt;file_cache-&gt;use_temp_path) &#123; p-&gt;temp_file-&gt;path = r-&gt;cache-&gt;file_cache-&gt;path; p-&gt;temp_file-&gt;file.name = r-&gt;cache-&gt;file.name; &#125;#endif &#125; else &#123; p-&gt;temp_file-&gt;log_level = NGX_LOG_WARN; p-&gt;temp_file-&gt;warn = \"an upstream response is buffered \" \"to a temporary file\"; &#125; p-&gt;max_temp_file_size = u-&gt;conf-&gt;max_temp_file_size; p-&gt;temp_file_write_size = u-&gt;conf-&gt;temp_file_write_size;#if (NGX_THREADS) if (clcf-&gt;aio == NGX_HTTP_AIO_THREADS &amp;&amp; clcf-&gt;aio_write) &#123; p-&gt;thread_handler = ngx_http_upstream_thread_handler; p-&gt;thread_ctx = r; &#125;#endif p-&gt;preread_bufs = ngx_alloc_chain_link(r-&gt;pool); if (p-&gt;preread_bufs == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; p-&gt;preread_bufs-&gt;buf = &amp;u-&gt;buffer; p-&gt;preread_bufs-&gt;next = NULL; u-&gt;buffer.recycled = 1; p-&gt;preread_size = u-&gt;buffer.last - u-&gt;buffer.pos; if (u-&gt;cacheable) &#123; p-&gt;buf_to_file = ngx_calloc_buf(r-&gt;pool); if (p-&gt;buf_to_file == NULL) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; p-&gt;buf_to_file-&gt;start = u-&gt;buffer.start; p-&gt;buf_to_file-&gt;pos = u-&gt;buffer.start; p-&gt;buf_to_file-&gt;last = u-&gt;buffer.pos; p-&gt;buf_to_file-&gt;temporary = 1; &#125; if (ngx_event_flags &amp; NGX_USE_IOCP_EVENT) &#123; /* the posted aio operation may corrupt a shadow buffer */ p-&gt;single_buf = 1; &#125; /* TODO: p-&gt;free_bufs = 0 if use ngx_create_chain_of_bufs() */ p-&gt;free_bufs = 1; /* * event_pipe would do u-&gt;buffer.last += p-&gt;preread_size * as though these bytes were read */ u-&gt;buffer.last = u-&gt;buffer.pos; if (u-&gt;conf-&gt;cyclic_temp_file) &#123; /* * we need to disable the use of sendfile() if we use cyclic temp file * because the writing a new data may interfere with sendfile() * that uses the same kernel file pages (at least on FreeBSD) */ p-&gt;cyclic_temp_file = 1; c-&gt;sendfile = 0; &#125; else &#123; p-&gt;cyclic_temp_file = 0; &#125; p-&gt;read_timeout = u-&gt;conf-&gt;read_timeout; p-&gt;send_timeout = clcf-&gt;send_timeout; p-&gt;send_lowat = clcf-&gt;send_lowat; p-&gt;length = -1; if (u-&gt;input_filter_init &amp;&amp; u-&gt;input_filter_init(p-&gt;input_ctx) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; u-&gt;read_event_handler = ngx_http_upstream_process_upstream; r-&gt;write_event_handler = ngx_http_upstream_process_downstream; ngx_http_upstream_process_upstream(r, u);&#125;读取数据的具体操作在ngx_http_upstream_process_upstream函数中实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546static voidngx_http_upstream_process_upstream(ngx_http_request_t *r, ngx_http_upstream_t *u)&#123; ngx_event_t *rev; ngx_event_pipe_t *p; ngx_connection_t *c; c = u-&gt;peer.connection; p = u-&gt;pipe; rev = c-&gt;read; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, \"http upstream process upstream\"); c-&gt;log-&gt;action = \"reading upstream\"; if (rev-&gt;timedout) &#123; p-&gt;upstream_error = 1; ngx_connection_error(c, NGX_ETIMEDOUT, \"upstream timed out\"); &#125; else &#123; //请求没有超时，那么对后端，处理一下读事件。ngx_event_pipe开始处理 if (rev-&gt;delayed) &#123; ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, \"http upstream delayed\"); if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); &#125; return; &#125; if (ngx_event_pipe(p, 0) == NGX_ABORT) &#123; ngx_http_upstream_finalize_request(r, u, NGX_ERROR); return; &#125; &#125; //注意走到这里的时候，后端发送的头部行信息已经在前面的ngx_http_upstream_send_response-&gt;ngx_http_send_header已经把头部行部分发送给客户端了 //该函数处理的只是后端放回过来的网页包体部分 ngx_http_upstream_process_request(r, u);&#125;接下来分析一下ngx_event_pipe这个函数，在有buffering的时候，使用event_pipe进行数据的转发，调用ngx_event_pipe_write_to_downstream函数读取数据，或者发送数据给客户端。ngx_event_pipe将upstream响应发送回客户端。do_write代表是否要往客户端发送，写数据。如果设置了，那么会先发给客户端，再读upstream数据，当然，如果读取了数据，也会调用这里的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677ngx_int_tngx_event_pipe(ngx_event_pipe_t *p, ngx_int_t do_write)&#123; ngx_int_t rc; ngx_uint_t flags; ngx_event_t *rev, *wev; for ( ;; ) &#123; if (do_write) &#123; p-&gt;log-&gt;action = \"sending to client\"; rc = ngx_event_pipe_write_to_downstream(p); if (rc == NGX_ABORT) &#123; return NGX_ABORT; &#125; if (rc == NGX_BUSY) &#123; return NGX_OK; &#125; &#125; p-&gt;read = 0; p-&gt;upstream_blocked = 0; p-&gt;log-&gt;action = \"reading upstream\"; if (ngx_event_pipe_read_upstream(p) == NGX_ABORT) &#123; return NGX_ABORT; &#125; if (!p-&gt;read &amp;&amp; !p-&gt;upstream_blocked) &#123; break; &#125; do_write = 1; &#125; if (p-&gt;upstream-&gt;fd != (ngx_socket_t) -1) &#123; rev = p-&gt;upstream-&gt;read; flags = (rev-&gt;eof || rev-&gt;error) ? NGX_CLOSE_EVENT : 0; if (ngx_handle_read_event(rev, flags) != NGX_OK) &#123; return NGX_ABORT; &#125; if (!rev-&gt;delayed) &#123; if (rev-&gt;active &amp;&amp; !rev-&gt;ready) &#123; ngx_add_timer(rev, p-&gt;read_timeout); &#125; else if (rev-&gt;timer_set) &#123; ngx_del_timer(rev); &#125; &#125; &#125; if (p-&gt;downstream-&gt;fd != (ngx_socket_t) -1 &amp;&amp; p-&gt;downstream-&gt;data == p-&gt;output_ctx) &#123; wev = p-&gt;downstream-&gt;write; if (ngx_handle_write_event(wev, p-&gt;send_lowat) != NGX_OK) &#123; return NGX_ABORT; &#125; if (!wev-&gt;delayed) &#123; if (wev-&gt;active &amp;&amp; !wev-&gt;ready) &#123; ngx_add_timer(wev, p-&gt;send_timeout); &#125; else if (wev-&gt;timer_set) &#123; ngx_del_timer(wev); &#125; &#125; &#125; return NGX_OK;&#125;这个函数中最重要的就是ngx_event_pipe_write_to_downstream跟ngx_event_pipe_read_upstream，这两个函数将处理来自上游的数据以及将数据转发到客户端。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx反向代理详解","slug":"Nginx反向代理详解","date":"2019-06-17T12:59:19.000Z","updated":"2020-04-06T13:47:50.306Z","comments":true,"path":"2019/06/17/Nginx反向代理详解/","link":"","permalink":"https://weeweetan.github.io/2019/06/17/Nginx反向代理详解/","excerpt":"","text":"1. 相关配置Nginx实现反向代理功能主要由proxy_pass、upstream指令实现，配置指令如下：1234567891011121314151617http &#123; ... upstream proxy &#123; server 127.0.0.1:8080 &#125; ... server &#123; ... location / &#123; proxy_pass http://proxy &#125; ... &#125;&#125;具体配置可以参考ngx_http_proxy_module2. 源码解析Nginx实现反向代理功能的源码在src/http/modules/ngx_http_proxy_module.c，因为反向代理模块是一种upstream模块，所以还有一些基础代码在src/http/ngx_http_upstream.c中2.1 入口函数反向代理模块的入口函数是ngx_http_proxy_handler，我们看一下源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static ngx_int_tngx_http_proxy_handler(ngx_http_request_t *r)&#123; ngx_int_t rc; ngx_http_upstream_t *u; ngx_http_proxy_ctx_t *ctx; ngx_http_proxy_loc_conf_t *plcf;#if (NGX_HTTP_CACHE) ngx_http_proxy_main_conf_t *pmcf;#endif if (ngx_http_upstream_create(r) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_proxy_ctx_t)); if (ctx == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; ngx_http_set_ctx(r, ctx, ngx_http_proxy_module); plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module); u = r-&gt;upstream; if (plcf-&gt;proxy_lengths == NULL) &#123; ctx-&gt;vars = plcf-&gt;vars; u-&gt;schema = plcf-&gt;vars.schema;#if (NGX_HTTP_SSL) u-&gt;ssl = (plcf-&gt;upstream.ssl != NULL);#endif &#125; else &#123; if (ngx_http_proxy_eval(r, ctx, plcf) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; &#125; u-&gt;output.tag = (ngx_buf_tag_t) &amp;ngx_http_proxy_module; u-&gt;conf = &amp;plcf-&gt;upstream;#if (NGX_HTTP_CACHE) pmcf = ngx_http_get_module_main_conf(r, ngx_http_proxy_module); u-&gt;caches = &amp;pmcf-&gt;caches; u-&gt;create_key = ngx_http_proxy_create_key;#endif u-&gt;create_request = ngx_http_proxy_create_request; u-&gt;reinit_request = ngx_http_proxy_reinit_request; u-&gt;process_header = ngx_http_proxy_process_status_line; u-&gt;abort_request = ngx_http_proxy_abort_request; u-&gt;finalize_request = ngx_http_proxy_finalize_request; r-&gt;state = 0; if (plcf-&gt;redirects) &#123; u-&gt;rewrite_redirect = ngx_http_proxy_rewrite_redirect; &#125; if (plcf-&gt;cookie_domains || plcf-&gt;cookie_paths) &#123; u-&gt;rewrite_cookie = ngx_http_proxy_rewrite_cookie; &#125; u-&gt;buffering = plcf-&gt;upstream.buffering; u-&gt;pipe = ngx_pcalloc(r-&gt;pool, sizeof(ngx_event_pipe_t)); if (u-&gt;pipe == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR; &#125; u-&gt;pipe-&gt;input_filter = ngx_http_proxy_copy_filter; u-&gt;pipe-&gt;input_ctx = r; u-&gt;input_filter_init = ngx_http_proxy_input_filter_init; u-&gt;input_filter = ngx_http_proxy_non_buffered_copy_filter; u-&gt;input_filter_ctx = r; u-&gt;accel = 1; if (!plcf-&gt;upstream.request_buffering &amp;&amp; plcf-&gt;body_values == NULL &amp;&amp; plcf-&gt;upstream.pass_request_body &amp;&amp; (!r-&gt;headers_in.chunked || plcf-&gt;http_version == NGX_HTTP_VERSION_11)) &#123; r-&gt;request_body_no_buffering = 1; &#125; rc = ngx_http_read_client_request_body(r, ngx_http_upstream_init); if (rc &gt;= NGX_HTTP_SPECIAL_RESPONSE) &#123; return rc; &#125; return NGX_DONE;&#125;该函数首先调用ngx_http_upstream_create函数从内存池中创建ngx_http_upstream_s结构体；123if (ngx_http_upstream_create(r) != NGX_OK) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR;&#125;接下来初始化ngx_http_upstream_s各成员，应当注意ngx_http_upstream_s结构体的几个回调函数，这个是实现反向代理的重要功能123456789101112131415161718192021222324252627282930u-&gt;create_request = ngx_http_proxy_create_request;u-&gt;reinit_request = ngx_http_proxy_reinit_request;u-&gt;process_header = ngx_http_proxy_process_status_line;u-&gt;abort_request = ngx_http_proxy_abort_request;u-&gt;finalize_request = ngx_http_proxy_finalize_request;r-&gt;state = 0; if (plcf-&gt;redirects) &#123; u-&gt;rewrite_redirect = ngx_http_proxy_rewrite_redirect;&#125; if (plcf-&gt;cookie_domains || plcf-&gt;cookie_paths) &#123; u-&gt;rewrite_cookie = ngx_http_proxy_rewrite_cookie;&#125; u-&gt;buffering = plcf-&gt;upstream.buffering; u-&gt;pipe = ngx_pcalloc(r-&gt;pool, sizeof(ngx_event_pipe_t));if (u-&gt;pipe == NULL) &#123; return NGX_HTTP_INTERNAL_SERVER_ERROR;&#125; u-&gt;pipe-&gt;input_filter = ngx_http_proxy_copy_filter;u-&gt;pipe-&gt;input_ctx = r; u-&gt;input_filter_init = ngx_http_proxy_input_filter_init;u-&gt;input_filter = ngx_http_proxy_non_buffered_copy_filter;u-&gt;input_filter_ctx = r; u-&gt;accel = 1;2.2 绑定入口函数nginx在解析配置文件时，遇到proxy_pass指令时将上述的入口函数绑定到content阶段的handler上，解析proxy_pass执行后的参数，确定上游服务器，那么当请求到达时，进入到入口函数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122static char *ngx_http_proxy_pass(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; ngx_http_proxy_loc_conf_t *plcf = conf; size_t add; u_short port; ngx_str_t *value, *url; ngx_url_t u; ngx_uint_t n; ngx_http_core_loc_conf_t *clcf; ngx_http_script_compile_t sc; if (plcf-&gt;upstream.upstream || plcf-&gt;proxy_lengths) &#123; return &quot;is duplicate&quot;; &#125; clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); clcf-&gt;handler = ngx_http_proxy_handler; if (clcf-&gt;name.len &amp;&amp; clcf-&gt;name.data[clcf-&gt;name.len - 1] == &apos;/&apos;) &#123; clcf-&gt;auto_redirect = 1; &#125; value = cf-&gt;args-&gt;elts; url = &amp;value[1]; n = ngx_http_script_variables_count(url); if (n) &#123; ngx_memzero(&amp;sc, sizeof(ngx_http_script_compile_t)); sc.cf = cf; sc.source = url; sc.lengths = &amp;plcf-&gt;proxy_lengths; sc.values = &amp;plcf-&gt;proxy_values; sc.variables = n; sc.complete_lengths = 1; sc.complete_values = 1; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125;#if (NGX_HTTP_SSL) plcf-&gt;ssl = 1;#endif return NGX_CONF_OK; &#125; if (ngx_strncasecmp(url-&gt;data, (u_char *) &quot;http://&quot;, 7) == 0) &#123; add = 7; port = 80; &#125; else if (ngx_strncasecmp(url-&gt;data, (u_char *) &quot;https://&quot;, 8) == 0) &#123;#if (NGX_HTTP_SSL) plcf-&gt;ssl = 1; add = 8; port = 443;#else ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;https protocol requires SSL support&quot;); return NGX_CONF_ERROR;#endif &#125; else &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;invalid URL prefix&quot;); return NGX_CONF_ERROR; &#125; ngx_memzero(&amp;u, sizeof(ngx_url_t)); u.url.len = url-&gt;len - add; u.url.data = url-&gt;data + add; u.default_port = port; u.uri_part = 1; u.no_resolve = 1; plcf-&gt;upstream.upstream = ngx_http_upstream_add(cf, &amp;u, 0); if (plcf-&gt;upstream.upstream == NULL) &#123; return NGX_CONF_ERROR; &#125; plcf-&gt;vars.schema.len = add; plcf-&gt;vars.schema.data = url-&gt;data; plcf-&gt;vars.key_start = plcf-&gt;vars.schema; ngx_http_proxy_set_vars(&amp;u, &amp;plcf-&gt;vars); plcf-&gt;location = clcf-&gt;name; if (clcf-&gt;named#if (NGX_PCRE) || clcf-&gt;regex#endif || clcf-&gt;noname) &#123; if (plcf-&gt;vars.uri.len) &#123; ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;\\&quot;proxy_pass\\&quot; cannot have URI part in &quot; &quot;location given by regular expression, &quot; &quot;or inside named location, &quot; &quot;or inside \\&quot;if\\&quot; statement, &quot; &quot;or inside \\&quot;limit_except\\&quot; block&quot;); return NGX_CONF_ERROR; &#125; plcf-&gt;location.len = 0; &#125; plcf-&gt;url = *url; return NGX_CONF_OK;&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx日志详解","slug":"Nginx日志详解","date":"2019-06-15T12:59:00.000Z","updated":"2019-08-07T03:10:04.761Z","comments":true,"path":"2019/06/15/Nginx日志详解/","link":"","permalink":"https://weeweetan.github.io/2019/06/15/Nginx日志详解/","excerpt":"","text":"1. 相关配置Nginx日志系统由两条指令开启error_log、access_log12345678error_log logs/error.log debug;http &#123; ... access_log logs/access.log main; ...&#125;具体配置可以参考error_log跟access_log2. 源码解析首先来看一下关于日志的几个宏定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546filename:log.h#if (NGX_HAVE_C99_VARIADIC_MACROS)#define NGX_HAVE_VARIADIC_MACROS 1#define ngx_log_error(level, log, ...) \\ if ((log)-&gt;log_level &gt;= level) ngx_log_error_core(level, log, __VA_ARGS__)void ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...);#define ngx_log_debug(level, log, ...) \\ if ((log)-&gt;log_level &amp; level) \\ ngx_log_error_core(NGX_LOG_DEBUG, log, __VA_ARGS__)/*********************************/#elif (NGX_HAVE_GCC_VARIADIC_MACROS)#define NGX_HAVE_VARIADIC_MACROS 1#define ngx_log_error(level, log, args...) \\ if ((log)-&gt;log_level &gt;= level) ngx_log_error_core(level, log, args)void ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...);#define ngx_log_debug(level, log, args...) \\ if ((log)-&gt;log_level &amp; level) \\ ngx_log_error_core(NGX_LOG_DEBUG, log, args)/*********************************/#else /* no variadic macros */#define NGX_HAVE_VARIADIC_MACROS 0void ngx_cdecl ngx_log_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...);void ngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, va_list args);void ngx_cdecl ngx_log_debug_core(ngx_log_t *log, ngx_err_t err, const char *fmt, ...);#endif /* variadic macros */从上面的定义可以看出，实现日志功能的核心在于ngx_log_error_core函数，接下来我们就来看看这个函数的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#if (NGX_HAVE_VARIADIC_MACROS)voidngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, ...)#elsevoidngx_log_error_core(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, const char *fmt, va_list args)#endif&#123;#if (NGX_HAVE_VARIADIC_MACROS) va_list args;#endif u_char *p, *last, *msg; ssize_t n; ngx_uint_t wrote_stderr, debug_connection; u_char errstr[NGX_MAX_ERROR_STR]; last = errstr + NGX_MAX_ERROR_STR; p = ngx_cpymem(errstr, ngx_cached_err_log_time.data, ngx_cached_err_log_time.len); p = ngx_slprintf(p, last, \" [%V] \", &amp;err_levels[level]); /* pid#tid */ p = ngx_slprintf(p, last, \"%P#\" NGX_TID_T_FMT \": \", ngx_log_pid, ngx_log_tid); if (log-&gt;connection) &#123; p = ngx_slprintf(p, last, \"*%uA \", log-&gt;connection); &#125; msg = p;#if (NGX_HAVE_VARIADIC_MACROS) va_start(args, fmt); p = ngx_vslprintf(p, last, fmt, args); va_end(args);#else p = ngx_vslprintf(p, last, fmt, args);#endif if (err) &#123; p = ngx_log_errno(p, last, err); &#125; if (level != NGX_LOG_DEBUG &amp;&amp; log-&gt;handler) &#123; p = log-&gt;handler(log, p, last - p); &#125; if (p &gt; last - NGX_LINEFEED_SIZE) &#123; p = last - NGX_LINEFEED_SIZE; &#125; ngx_linefeed(p); wrote_stderr = 0; debug_connection = (log-&gt;log_level &amp; NGX_LOG_DEBUG_CONNECTION) != 0; while (log) &#123; if (log-&gt;log_level &lt; level &amp;&amp; !debug_connection) &#123; break; &#125; if (log-&gt;writer) &#123; log-&gt;writer(log, level, errstr, p - errstr); goto next; &#125; if (ngx_time() == log-&gt;disk_full_time) &#123; /* * on FreeBSD writing to a full filesystem with enabled softupdates * may block process for much longer time than writing to non-full * filesystem, so we skip writing to a log for one second */ goto next; &#125; n = ngx_write_fd(log-&gt;file-&gt;fd, errstr, p - errstr); if (n == -1 &amp;&amp; ngx_errno == NGX_ENOSPC) &#123; log-&gt;disk_full_time = ngx_time(); &#125; if (log-&gt;file-&gt;fd == ngx_stderr) &#123; wrote_stderr = 1; &#125; next: log = log-&gt;next; &#125; if (!ngx_use_stderr || level &gt; NGX_LOG_WARN || wrote_stderr) &#123; return; &#125; msg -= (7 + err_levels[level].len + 3); (void) ngx_sprintf(msg, \"nginx: [%V] \", &amp;err_levels[level]); (void) ngx_write_console(ngx_stderr, msg, p - msg);&#125;从代码中可以看出，nginx的作者对于变参处理还是很细心的，把各种情况都考虑到了，在处理好变参定义之后，就开始初始化字符串格式：1234567891011121314p = ngx_cpymem(errstr, ngx_cached_err_log_time.data, ngx_cached_err_log_time.len);p = ngx_slprintf(p, last, &quot; [%V] &quot;, &amp;err_levels[level]);/* pid#tid */p = ngx_slprintf(p, last, &quot;%P#&quot; NGX_TID_T_FMT &quot;: &quot;, ngx_log_pid, ngx_log_tid);if (log-&gt;connection) &#123; p = ngx_slprintf(p, last, &quot;*%uA &quot;, log-&gt;connection);&#125;处理变参参数，将变参的值复制到日志串中：1234567891011#if (NGX_HAVE_VARIADIC_MACROS) va_start(args, fmt); p = ngx_vslprintf(p, last, fmt, args); va_end(args);#else p = ngx_vslprintf(p, last, fmt, args);#endif处理错误号跟换行：12345678910111213if (err) &#123; p = ngx_log_errno(p, last, err);&#125;if (level != NGX_LOG_DEBUG &amp;&amp; log-&gt;handler) &#123; p = log-&gt;handler(log, p, last - p);&#125;if (p &gt; last - NGX_LINEFEED_SIZE) &#123; p = last - NGX_LINEFEED_SIZE;&#125;ngx_linefeed(p);最后就是将日志串输出到文件或者标准错误流3. 总结","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Nginx模块详解","slug":"Nginx模块详解","date":"2019-06-05T12:58:43.000Z","updated":"2019-07-20T03:15:19.597Z","comments":true,"path":"2019/06/05/Nginx模块详解/","link":"","permalink":"https://weeweetan.github.io/2019/06/05/Nginx模块详解/","excerpt":"","text":"1. Nginx模块综述nginx的模块非常之多，可以认为所有代码都是以模块的形式组织，这包括核心模块和功能模块，针对不同的应用场合，并非所有的功能模块都要被用到，附录A给出的是默认configure（即简单的http服务器应用）下被连接的模块，这里虽说是模块连接，但nginx不会像apache或lighttpd那样在编译时生成so动态库而在程序执行时再进行动态加载，nginx模块源文件会在生成nginx时就直接被编译到其二进制执行文件中，所以如果要选用不同的功能模块，必须对nginx做重新配置和编译。对于功能模块的选择，如果要修改默认值，需要在进行configure时进行指定，比如新增http_flv功能模块（默认是没有这个功能的，各个选项的默认值可以在文件auto/options内看到）：1[root@localhost nginx-1.2.0]# ./configure --with-http_flv_module执行后，生成的objs/ngx_modules.c文件内就包含有对ngx_http_flv_module模块的引用了，要再去掉http_flv功能模块，则需要重新configure，即不带–with-http_flv_module配置后再编译生成新的nginx执行程序。通过执行./configure –help，我们可以看到更多的配置选项。虽然Nginx模块有很多，并且每个模块实现的功能各不相同，但是根据模块的功能性质，可以将它们分为四个类别：1， handlers：处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。2， filters：对handlers产生的响应内容做各种过滤处理（即是增删改），比如模块ngx_http_not_modified_filter_module，对待响应内容进行过滤检测，如果通过时间戳判断出前后两次请求的响应内容没有发生任何改变，那么可以直接响应 “304 Not Modified”状态标识，让客户端使用缓存即可，而原本待发送的响应内容将被清除掉。3， upstream：如果存在后端真实服务器，nginx可利用upstream模块充当反向代理（Proxy）的角色，对客户端发起的请求只负责进行转发（当然也包括后端真实服务器响应的回转），比如ngx_http_proxy_module就为标准的代理模块。4， load-balance：在nginx充当中间代理时，由于后端真实服务器往往多于一个，对于某一次客户端的请求，如何选择对应的后端真实服务器来进行处理，这就有类似于ngx_http_upstream_ip_hash_module这样的模块来实现不同的负载均衡算法（Load Balance）。对于这几类模块，我们马上会分别进行详细介绍并分析各自典型代表模块，不过在此之前先从nginx模块源码上来进行直观认识。前面讲过nginx的所有代码都是以模块形式进行组织，而封装nginx模块的结构体为ngx_module_s，定义如下：1234567891011121314151617Filename : ngx_conf_file.hstruct ngx_module_s &#123; ngx_uint_t ctx_index; //当前模块在同类模块中的序号 ngx_uint_t index; //当前模块在所有模块中的序号 … ngx_uint_t version; //当前模块版本号 void *ctx; //指向当前模块特有的数据 ngx_command_t *commands; //指向当前模块配置项解析数组 ngx_uint_t type; //模块类型 //以下为模块回调函数，回调时机可根据函数名看出 ngx_int_t (*init_master)(ngx_log_t *log); …&#125;;Filename : ngx_core.htypedef struct ngx_module_s ngx_module_t;结构体ngx_module_s值得关注的几个字段分别为ctx、commands、type，其中commands字段表示当前模块可以解析的配置项目，这在配置文件解析一章做过详细描述；表示模块类型的type值只有5种可能的值，而同一类型模块的ctx指向的数据类型也相同：序号type值ctx指向数据类型1NGX_CORE_MODULEngx_core_module_t2NGX_EVENT_MODULEngx_event_module_t3NGX_CONF_MODULENULL4NGX_HTTP_MODULEngx_http_module_t5NGX_MAIL_MODULEngx_mail_module_t上表中第三列里的数据类型非常重要，它们的字段基本都是一些回调函数，这些回调函数会在其模块对应的配置文件解析过程前/中/后会适时的被调用，做一些内存准备、初始化、配置值检查、初始值填充与合并、回调函数挂载等初始工作，以ngx_http_core_module模块为例，该模块type类型为NGX_HTTP_MODULE，ctx指向的ngx_http_module_t结构体变量ngx_http_core_module_ctx：123456789101112131415Filename : ngx_http_core_module.cstatic ngx_http_module_t ngx_http_core_module_ctx = &#123; ngx_http_core_preconfiguration, /* preconfiguration */ NULL, /* postconfiguration */ ngx_http_core_create_main_conf, /* create main configuration */ ngx_http_core_init_main_conf, /* init main configuration */ ngx_http_core_create_srv_conf, /* create server configuration */ ngx_http_core_merge_srv_conf, /* merge server configuration */ ngx_http_core_create_loc_conf, /* create location configuration */ ngx_http_core_merge_loc_conf /* merge location configuration */&#125;;根据上面代码注释，可以很明显的看出各个回调函数的回调时机，比如函数ngx_http_core_preconfiguration()将在进行http块配置解析前被调用，所以在ngx_http_block()函数里可以看到这样的代码：12345678910111213141516171819Filename : ngx_http.cstatic char *ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)… if (module-&gt;preconfiguration) &#123; if (module-&gt;preconfiguration(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125;… rv = ngx_conf_parse(cf, NULL);… if (module-&gt;postconfiguration) &#123; if (module-&gt;postconfiguration(cf) != NGX_OK) &#123; return NGX_CONF_ERROR; &#125; &#125;…至于这些回调函数内的具体逻辑，如前所述一般是一些初始或默认值填充工作，但也有回调函数挂载的设置，比如ngx_http_static_module模块的postconfiguration字段回调函数ngx_http_static_init()就是将自己的处理函数ngx_http_static_handler()挂载在http处理状态机上，但总体来看这毕竟都只是一些简单的初始准备工作，值得一提的还有ngx_http_core_create_main_conf、ngx_http_core_create_srv_conf、ngx_http_core_create_loc_conf这三个回调函数用来创建存储位于http块、server块、location块配置项的内存。参考文献：nginx核心讲解","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"Dos常用命令","slug":"Dos常用命令","date":"2019-05-26T05:56:27.000Z","updated":"2020-02-13T14:21:44.953Z","comments":true,"path":"2019/05/26/Dos常用命令/","link":"","permalink":"https://weeweetan.github.io/2019/05/26/Dos常用命令/","excerpt":"","text":"scsc命令可用于卸载windows服务，如下所示：sc delete serv 其中serv为服务名，可在服务中查看xcopyxcopy命令用于Dos下复制文件夹及子文件夹，如下所示：xcopy d:\\abc\\aaa\\*.* c:\\windows\\system /s 其中第一个参数是源位置，第二个参数是目标位置/s：复制目录和子目录，除了空的。taskkilltaskkill命令用于杀进程，可根据pid，也可根据进程名。taskkill /im nginx.exe /f taskkill /pid {pid}","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"Dos","slug":"Dos","permalink":"https://weeweetan.github.io/tags/Dos/"}]},{"title":"中国菜翻译方法","slug":"中国菜翻译方法","date":"2019-05-18T02:27:42.000Z","updated":"2019-05-18T02:32:50.166Z","comments":true,"path":"2019/05/18/中国菜翻译方法/","link":"","permalink":"https://weeweetan.github.io/2019/05/18/中国菜翻译方法/","excerpt":"","text":"以主料为主配料或配汁为辅的翻译原则菜肴的主料和配料主料（名称/形状）+ with + 配料如：松仁香菇 Chinese Mushrooms with Pine Nuts菜肴的主料和配汁主料 + with / in + 汤汁（Sauce）如：冰梅凉瓜 Bitter Melon in Plum Sauc以烹制方法为主原料为辅的翻译原则菜肴的做法和主料做法（动词过去分词）+ 主料（名称/形状）如：拌双耳 Tossed Black and White Fungus菜肴的做法、主料和汤汁做法(动词过去分词) + 主料（名称/形状）+ with / in + 汤汁如：京酱肉丝 Sautéed Shredded Pork in Sweet Bean Sauce以形状、口感为主原料为辅的翻译原则菜肴形状或口感以及主配料形状/口感 + 主料如：玉兔馒头 Rabbit-Shaped Mantou菜肴的做法、形状或口感、做法以及主配料做法（动词过去分词）+ 形状/口感 + 主料 + 配料如： 小炒黑山羊 Sautéed Sliced Lamb with Pepper and Parsley","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://weeweetan.github.io/tags/翻译/"}]},{"title":"C语言编程常见错误及技巧","slug":"C语言编程常见错误","date":"2019-05-17T15:21:03.000Z","updated":"2020-04-14T12:37:43.952Z","comments":true,"path":"2019/05/17/C语言编程常见错误/","link":"","permalink":"https://weeweetan.github.io/2019/05/17/C语言编程常见错误/","excerpt":"","text":"1. 使用close函数出现bad file descriptor错误出现这种错误一般是两次close导致，仔细检查代码，调用close关闭文件描述符后，应该将文件描述符置为0，避免重复调用close，切记切记。2. 守护程序闪退问题出现这个问题一般是两次释放同一块内存，仔细检查释放内存与指针赋值相关代码，释放内存后，应将指针置为NULL，避免重复调用close，切记切记。3. 四字节对齐4. 什么是四字节对齐现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。4.1 四字节对齐作用定义结构体成员时应当注意四字节对齐，保证内存利用最大化。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。5. 柔性数组定义结构体时，最后一个成员定义为struct test { int a; char b[0]; } b[0]就称为柔性数组，使用sizeof(struct test); 返回值为4，即b[0]不占用内存空间。6. 数字转字符C语言书籍上可能出现过如下代码将数字转为字符int a = 0; char b = a + &apos;0&apos;; 这个操作有局限性，当a的值超过9的时候就会得到你意向不到的结果，int a = 10; char b = a + &apos;0&apos;; 这个时候字符b的值为’:’7. fork函数注意事项fork函数用来产生一个子进程，而且会复制父进程的资源（包括打开的文件描述符，变量等），无论是在子进程还是父进程对打开的文件描述符都需要谨慎对待，调用close函数关闭文件描述符可能不会报错，但是删除文件的时候就会出问题。8. 变参宏定义C99定义了一种变参宏定义#define LOG(format, ...) fprintf(stdout, format, __VA_ARGS__) …表示可变参数列表，VA_ARGS在预处理中，会被实际的参数集（实参列表）所替换。同时gcc还支持带可以变参数名的方式（注意：VC不支持,即在vs环境下无法使用）：#define LOG(format, args...) fprintf(stdout, format, args) 同样，args在预处理过程中，会被实际的参数集所替换。其用法和上面的方式一样，只是参数的符号有变。9. 整数相除C语言中，两个int型相除只能得到int型，若结果分子小于分母，则结果为0。必要时，将分子或者分母强转为float型，则结果为float型。10. 屏蔽gcc编译函数未使用错误函数定义了未使用在visual studio中，不会报错，但是使用gcc编译时就要报错，如下所示：1warning: 'xxx_handler' defined but not used [-Wunused-function]这个时候需要添加一个编译标志如下1CFLAGS=\"$CFLAGS -Wno-unused-function\"添加上这个标志以后，就不会报错了，常见标志可以参考gcc官网，要特别注意的是no这个标志，如果编译出现其他类似错误，又不想改代码，就可以加对应的标志，不同版本的gcc对于同一份代码可能出现错误。11. 大端机与小端机所谓大端就是指高位值在内存中放低位地址，所谓小端是指低位值在内存中放低位地址。比如0x12345678在大端机上是12345678，在小端机上是78563412，而一个主机是大端还是小端要看cpu类型以及运行在上面的操作系统。同一款cpu在不同的操作系统使用的大小端情况是不同的。个人理解0x1234是我们的书写习惯，转成二进制就是‭0001001000110100‬，读数从右往左读，所以0100是低位值，0001是高位值，在计算机中，内存地址增长方向是从左到右，所以左边是低位地址，右边是高位地址，如果计算机的低位地址存的是书写习惯的高位值，那么就是小端机，大小端机对单字节没影响。12. 主机字节序与网络字节序主机字节序就是大端序与小端序，网络字节序与大端序相同。在编写网络相关代码时，需要使用函数转换字节序，比如htons,htonl,ntohs,ntohl。13. 管道管道是一种把两个进程之间的标准输入和标准输出连接起来的机制，从而提供一种让多个进程间通信的方法，pipe（无名管道）和fifo（命名管道）两种。管道为半双工通信方式，也就是说只能一端读，一端写。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"C","slug":"C","permalink":"https://weeweetan.github.io/tags/C/"}]},{"title":"Nginx学习笔记","slug":"Nginx学习笔记","date":"2019-05-08T02:49:55.000Z","updated":"2019-08-16T08:26:32.125Z","comments":true,"path":"2019/05/08/Nginx学习笔记/","link":"","permalink":"https://weeweetan.github.io/2019/05/08/Nginx学习笔记/","excerpt":"","text":"1. 编译步骤1.1 configure原理configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。1.2 auto脚本auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。1.2.1 auto/options脚本auto/options主是处理用户输入的configure选项，以及输出帮助信息等。auto/options的目的主要是处理用户选项，并由选项生成一些全局变量的值，这些值在其它文件中会用到。该文件也会输出configure的帮助信息。应当注意如下代码123for optiondo opt=\"$opt `echo $option | sed -e \\\"s/\\(--[^=]*=\\)\\(.* .*\\)/\\1'\\2'/\\\"`\"for后面可以省略要遍历的变量,这时,表示在遍历$@,即用户传入的所有变量组合1.2.2 auto/init脚本该文件的目录在于初始化一些临时文件的路径，检查echo的兼容性，并创建最原始的Makefile文件。淘宝Nginx开发从入门到精通注意：这里生成的Makefile文件与configure文件在同一目录，真正执行编译指令的Makefile在objs目录下1.2.3 auto/sources脚本该文件从文件名中就可以看出，它的主要功能是跟源文件相关的。它的主要作用是定义不同功能或系统所需要的文件的变量。根据功能，分为CORE/REGEX/EVENT/UNIX/FREEBSD/HTTP等。每一个功能将会由四个变量组成，”_MODULES”表示此功能相关的模块，最终会输出到ngx_modules.c文件中，即动态生成需要编译到nginx中的模块；”INCS”表示此功能依赖的源码目录，查找头文件的时候会用到，在编译选项中，会出现在”-I”中；”DEPS”显示指明在Makefile中需要依赖的文件名，即编译时，需要检查这些文件的更新时间；”SRCS”表示需要此功能编译需要的源文件。淘宝Nginx开发从入门到精通根据上面的描述，所以如果需要对nginx进行功能扩展，添加相应的C文件后，修改这个脚本就可以将自己的功能编译进nginx。2. 源码解析2.1 模块相关在ngx_module.h中引用了两个至关重要的外部变量12extern ngx_module_t *ngx_modules[];extern char *ngx_module_names[];ngx_modules跟ngx_module_names定义在ngx_modules.c中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用ngx_cycle_modules函数，原型如下：1ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle)此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下：main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules 2.2 数据结构2.2.1 ngx_str_tNginx开发从入门到精通已经对ngx_str_t的定义以及相关api进行了非常详细的讲解，以下为定义：1234typedef struct &#123; size_t len; u_char *data;&#125; ngx_str_t;注意事项：不要试图复制char *到data所指向的内存，可能导致coredump初始化相关api都是基于常量字符串，char *类型慎用如果非要复制char *到data所指向的内存，一定先分配内存2.2.2 ngx_array_tNginx开发从入门到精通已经对ngx_array_t的定义以及相关api进行了非常详细的讲解，以下为定义：12345678typedef struct ngx_array_s ngx_array_t;struct ngx_array_s &#123; void *elts; ngx_uint_t nelts; size_t size; ngx_uint_t nalloc; ngx_pool_t *pool;&#125;;注意事项如果使用ngx_array_t作为字符串容器，在调用ngx_array_create时，使用字符串长度最后一个参数ngx_array_push返回第n个元素首地址，要注意指针运算3. handler模块的编写步骤编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量：123static ngx_command_t ngx_http_module_name_commands[] = &#123;&#125;;static ngx_http_module_t ngx_http_module_name_module_ctx = &#123;&#125;;ngx_module_t ngx_http_module_name_module = &#123;&#125;;实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数：1static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)；编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数：1static ngx_int_t ngx_http_module_name_handler(ngx_http_request_t *r);3.1 模块编译对于开发一个模块，我们是需要把这个模块的C代码组织到一个目录里，同时需要编写一个config文件。这个config文件的内容就是告诉nginx的编译脚本，该如何进行编译。淘宝Nginx开发从入门到精通1234 ngx_addon_name=ngx_http_hello_moduleHTTP_MODULES=&quot;$HTTP_MODULES ngx_http_hello_module&quot;NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_hello_module.c&quot;执行如下命令进行编译1./configure –add-module=/home/jizhao/open_source/book_module 4. 部分功能简介4.1 日志系统Nginx的日志系统分为两个部分，一个是Nginx核心的错误日志（包括debug日志），一个是各模块的访问日志，整个Nginx框架中主要以核心的错误日志为主，各模块的访问日志根据模块调用顺序使用，下面分别介绍两种日志系统。4.1.1 错误日志关于错误日志的配置指令可以参考error_log，分析Nginx源码可以发现，源码中多处使用ngx_log_debug0，ngx_log_debug1等类似的宏定义，启用这些宏定义需要在configure的时候执行–with-debug。错误日志初始化分为两个阶段，一个是ngx_log_init函数中初始化日志对象，另外一个就是在解析配置文件的时候会新建一个日志对象。4.1.2 访问日志目前实现了访问日志的官方模块有http模块，stream模块，其中http模块的配置指令可以参考ngx_http_log_module。http模块的日志系统是以http第三方模块的形式存在，所以编写的时候遵循第3节的规则，Nginx将HTTP请求划分为11个阶段，访问日志是最后一个阶段，所以访问日志在HTTP请求完成时写入。4.2 upstream机制upstream机制使得nginx能够作为代理服务器，或者负载均衡服务器，将来自客户端的请求转发到上游，并将上游响应转发到客户端。参考配置如下#位于http上下文中 upstream local { server 127.0.0.1:8080 weight=5; server 127.0.0.1:80 weight=2; } 4.3 反向代理nginx反向代理实际上是一个upstream模块，实现upstream机制的几个回调函数。参考配置如下：location / { proxy_pass http://local } 5. 编码过程中遇到的问题5.1 使用ngx_sprintf遇到的问题ngx_sprintf函数用于向缓冲区中复制格式化字符串，跟标准C的sprintf函数一样，Nginx增加了一些格式，具体可以看ngx_string.c的源码，接下来结合代码说明一些问题：1234567 size_t a;off_t b;u_char c[20] = &#123;\"0\"&#125;;ngx_sprintf(c, \"a:%z,b:%O\", a, b); 上面这段代码是正确示范，若a也为off_t类型，在执行ngx_sprintf时一定要使用%O，否者b的值会受影响。结语此博文只粗略记录笔记，在后续会写详细的博客对nginx进行分析","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"libxml2使用心得","slug":"libxml2使用心得","date":"2019-05-04T14:21:35.000Z","updated":"2019-05-15T07:04:26.805Z","comments":true,"path":"2019/05/04/libxml2使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/05/04/libxml2使用心得/","excerpt":"","text":"背景由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考C++的XML编程经验――LIBXML2库使用指南，这篇博文讲得很详细，我在这里只是做出一点补充。问题xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。举例说明我使用GLib2的g_locale_from_utf8将内容转换为本地程序默认的编码格式，在写入xml内容时使用g_locale_to_utf8将内容转换为UTF-8.总结总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。","categories":[{"name":"libxml","slug":"libxml","permalink":"https://weeweetan.github.io/categories/libxml/"}],"tags":[{"name":"libxml","slug":"libxml","permalink":"https://weeweetan.github.io/tags/libxml/"}]},{"title":"GLib使用心得","slug":"GLib使用心得","date":"2019-04-28T05:51:59.000Z","updated":"2019-07-11T03:11:05.932Z","comments":true,"path":"2019/04/28/GLib使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/04/28/GLib使用心得/","excerpt":"","text":"前言关于GLib的介绍这里就不赘述了，具体API介绍可以去GLib API Reference查阅，这里只是记录一下使用相关API所遇到的一些坑。相关API字符串相关API12345 GString *g_string_new(const gchar *init);GString *g_string_append(GString *string, const gchar *val);GString *g_string_prepend(GString *string, const gchar *val);gchar *g_string_free(GString *string, gboolean free_segment);如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。注意 g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。g_string_append跟g_string_prepend都是直接在原字符串上操作，这点要切记。字符转换相关API123gchar *g_filename_display_basename(const gchar *filename);gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error);g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8下面看个例子, 比如我们有个含中文的文件名 /data/test/哈哈.txt如果想获得 哈哈.txt，则必须首先使用 g_locale_to_utf8函数转换一次, 然后再去获取basename123GString *string = g_string_new(\"/data/test/哈哈.txt\");gchar *str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL);gchar *basename = g_filename_display_basename(str);如果想使用GString 类型保存basename，则必须重新申请内存块1GString *basename_string = g_string_new(basename); 千万别像下面这样做12GString *string = g_string_new(\"/data/test/哈哈.txt\");string-&gt;str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); 如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，g_locale_from_utf8 同理注意 g_locale_to_utf8返回的char 需要手动释放内存解析key-value文件API12345GKeyFile *g_key_file_new(void);gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error);gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error);void g_key_file_free(GKeyFile *key_file);这几个API很好理解,用来解析具有键值对特征的文件,g_key_file_new跟g_key_file_free配套使用;g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;","categories":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/categories/GLib/"}],"tags":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/tags/GLib/"}]},{"title":"调用glib库出现0xc000007b解决办法","slug":"调用glib库出现0xc000007b解决办法","date":"2019-04-18T14:47:29.000Z","updated":"2019-05-18T01:22:38.363Z","comments":true,"path":"2019/04/18/调用glib库出现0xc000007b解决办法/","link":"","permalink":"https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/","excerpt":"","text":"背景之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示：网上的解决办法都试过，没能解决问题。出现转机出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。开始分析我使用depends分析libglib-2.0.dll，结果如下图所示从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。1、网上下载libintl-8.dll2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下问题解决上述步骤完成之后，再次使用depends检查，如下图所示：程序也正常运行注意我这里只是说明解决问题的方法，图中dll版本问题自行忽略","categories":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/categories/GLib/"}],"tags":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/tags/GLib/"}]},{"title":"安装vCenter Server出现1603错误的一种解决方法","slug":"安装vCenter-Server出现1603错误的一种解决方法","date":"2018-11-29T02:04:37.000Z","updated":"2019-05-15T14:12:39.771Z","comments":true,"path":"2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/","link":"","permalink":"https://weeweetan.github.io/2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/","excerpt":"","text":"背景vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配置，导致vCenter Server相关服务无法启动，查找解决方法无果后，就打算重装vCenter Server。遇到的问题部署过程主要参考VMware Vsphere 6.0安装部署 （三） vCenter Server安装。在这里我主要说明一下我所遇到的问题以及解决方法。在安装过程中遇到Encountered an internal error，Install-parameter rhttpproxy.ext.port1 not set具体错误信息如下图所示：出现这个错误后，会退出安装，在最后会报‘安装组件VCSServiceManager失败并显示错误代码1603’，如下图所示：出现这个错误，首先应当排查在安装vCenter Server 过程中配置的http端口是否被占用(使用命令netstat -nao)，如果端口没有被占用，则使用如下方法：删除C:\\Program Files\\VMware\\vCenter Server目录；重启虚拟机，重新安装总结这个方法不一定能解决所有这类问题，这只是其中一种解决方法。","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"VMware虚拟机备份与恢复","slug":"VMware虚拟机备份与恢复","date":"2018-10-31T08:05:03.000Z","updated":"2019-06-03T14:12:21.114Z","comments":true,"path":"2018/10/31/VMware虚拟机备份与恢复/","link":"","permalink":"https://weeweetan.github.io/2018/10/31/VMware虚拟机备份与恢复/","excerpt":"","text":"前言本文主要是根据自己实际项目经验对云与备份之（1）：VMware虚机备份和恢复这篇文章进行补充说明。本文将以部分引用，部分说明的方式进行组织，加粗部分为我自己总结的内容。原文中提到两套SDK（vddk跟Web service SDK），整个虚拟机备份流程需要着两套SDK配合使用，我把这两套SDK整理了一下，使之能够在clion跟idea中运行，地址如下：VMwareProjectvix_disklib_sample1. 与备份有关的VMWare基础知识1.1 VMware 虚机磁盘在 ESXi 宿主机上的文件简单来说，虚机的每个虚拟磁盘由ESXi 宿主机上的三个文件组成（这里的虚机名字是 sammy-target-win-small，下面是其第一个磁盘对应的三个文件）：sammy-target-win-small.vmdk （配置文件，大小 633 字节）sammy-target-win-small-flat.vmdk （二进制文件，大小 12884901888 字节）sammy-target-win-small-ctk.vmdk （二进制文件，大小 78694 字节）其中，第一个文件保存的是该磁盘的元数据，其中包括另外两个文件的信息# Extent description RW 25165824 VMFS &quot;sammy-target-win-small-flat.vmdk&quot; # Change Tracking File changeTrackPath=&quot;sammy-target-win-small-ctk.vmdk&quot; 第二个文件是 Extent description 文件，二进制数据保存在这个文件中。下面会介绍使用API获取该文件中数据的方法。第三个文件是 CTK 文件。下面讲到 CTK 的时候再说。@刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)1.2 虚拟磁盘类型上一节中的磁盘组织形式并不是唯一的，早期版本的Esxi不是以这种方式组织。vddk文档中定义了8种磁盘类型，在创建虚拟磁盘时，使用不同磁盘类型，则虚拟磁盘的组织方式不同。8中磁盘类型如下：VIXDISKLIB_DISK_MONOLITHIC_SPARSE – Growable virtual disk contained in a single virtual disk file. This is the default type for hosted disk, and the only setting in the Virtual Disk API Sample Code sample program.VIXDISKLIB_DISK_MONOLITHIC_FLAT – Preallocated virtual disk contained in a single virtual disk file. This takes time to create and occupies a lot of space, but might perform better than sparse.VIXDISKLIB_DISK_SPLIT_SPARSE – Growable virtual disk split into 2GB extents ( s sequence). These files can to 2GB, then continue growing in a new extent. This type works on older file systems.VIXDISKLIB_DISK_SPLIT_FLAT – Preallocated virtual disk split into 2GB extents ( f sequence). These files start at 2GB, so they take a while to create, but available space can grow in 2GB increments.VIXDISKLIB_DISK_VMFS_FLAT – Preallocated virtual disk compatible with ESX 3 and later. Also known as thick disk. This managed disk type is discussed in Managed Disk and Hosted Disk.VIXDISKLIB_DISK_VMFS_SPARSE – Employs a copy-on-write (COW) mechanism to save storage space.VIXDISKLIB_DISK_VMFS_THIN – Growable virtual disk that consumes only as much space as needed, compatible with ESX 3 or later, supported by VDDK 1.1 or later, and highly recommended.VIXDISKLIB_DISK_STREAM_OPTIMIZED – Monolithic sparse format compressed for streaming. Stream optimized format does not support random reads or writes.只有vddk使用VIXDISKLIB_DISK_VMFS_FLAT类型创建虚拟磁盘时才会生成1.1节中所示的虚拟磁盘文件，使用Web Service SDK创建虚拟磁盘则不受此限制。1.3 虚拟磁盘模式虚拟磁盘模式分为持久跟非持久，以下为vddk中对持久的定义持久模式(persistent)：In persistent disk mode, changes are immediately and permanently written to the virtual disk, so that they survive even through to the next power on.非持久模式(nonpersistent)：In nonpersistent mode, changes to the virtual disk are discarded when the virtual machine powers off. The VMDK files revert to their original state.使用vSphere client创建虚拟磁盘跟vddk的选项可能会有区别独立持久：持久模式磁盘的行为与物理机上常规磁盘的行为相似。写入持久模式磁盘的所有数据都会永久性地写入磁盘。独立非持久：关闭虚拟机电源或重置虚拟机时，对非持久模式磁盘的更改将丢失。使用非持久模式，您可以每次使用相同的虚拟磁盘状态重新启动虚拟机。对磁盘的更改会写入重做日志文件并从中读取，重做日志文件会在关闭虚拟机电源或重置虚拟机时被删除。1.4 vCenter ServervCenter Server相当于一套管理多台Esxi服务器的系统，如果需要对虚拟机进行备份，则需要部署这么一套系统，具体怎么部署可以参考VMware Vsphere 6.0安装部署 （三） vCenter Server安装。备份所使用的Web serviceSDK依赖这套系统，对于这套系统的使用可以参考我其他关于vSphere的文章。1.5 vSphere Web ClientvSphere Web Client为vCenter Server提供一个web管理界面，文中关于对vCenter的操作都是在这界面上完成。1.5 虚拟机注册在vCenter Server中，Esxi服务器以及虚拟机以实体对象的形式存在，已有的虚拟机文件可以通过注册功能，将虚拟机文件激活成虚拟机，这里涉及到虚拟机的其他文件，可以参考什么是虚拟机?。在vCenter Server中将.vmx文件作为虚拟机，所以在vCenter Server中找到虚拟机文件，右键注册就可以了。2. 备份要点原文中对备份流程进行了详细说明，我这里就不再赘述，我将从以下几个方面说明备份要点。其中具体代码实现可以去我的csdn查看相关文章2.1 如何确定虚拟机对象？这个时候就需要使用Web service SDK去遍历vCenter Server中的虚拟机对象，并返回虚拟机的名称和在vCenter中的id，有了这两个变量，就可以确定虚拟机对象了。2.2 如何获取虚拟机相关配置？这一步中最重要的是拿到虚拟机磁盘对象，对虚拟机的备份，实际上是对虚拟磁盘的备份，这里还是使用Web ServiceSDk进行获取2.3 如何获取变化数据？原文中有提到一个API：QueryChangedDiskAreas获取 CBT 变化块的函数的定义为：QueryChangedDiskAreas(snapshot, deviceKey, startOffSet, changeID)。其中，snapshot 代表当前的快照，也就是“变化”时间段的后端点；deviceKey 是目标虚拟磁盘的 device ID；startOffSet 是开始获取变化块的offset；changeID 是指“变化”时间段的前端点，即老的快照的 changeID。其结果类似 “(117768192, 65536),(132120576, 65536),(145096704, 43122688),(265289728, 65536),(958398464, 65536)”，每项的格式为 （offset，length），表示一个发生变化的数据块。@刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)使用QueryChangedDiskAreas获取到变化数据后，需要将这些数据保存下来，以供后续使用。2.4 如何下载变化数据？这个时候就需要vddk，vddk可以连接到远程的虚拟磁盘，并根据上一节保存的数据，将虚拟磁盘中的变化数据读取并保存下来，以供恢复使用。3. 恢复要点3.1 完全恢复如果在完全备份的时候采用文件下载的形式进行备份，则在恢复的时候就可以直接将文件上传至vCenter Server然后注册虚拟机就可以了。如果备份的时候只备份了虚拟磁盘，则在恢复的时候需要使用Web Service SDK创建虚拟机，再将磁盘数据写入到新建的虚拟机中。3.2 增量恢复增量恢复以完全恢复为前提，每个增量点依次恢复。3.3 其他办法如果业务十分紧急，则可以将备份的虚拟机文件以NFS的形式挂载到vCenter Server上，通过注册虚拟机的方式进行恢复。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"Java与PHP之间的Socket通信","slug":"Java与PHP之间的Socket通信","date":"2018-08-08T15:55:23.000Z","updated":"2019-07-16T15:13:03.436Z","comments":true,"path":"2018/08/08/Java与PHP之间的Socket通信/","link":"","permalink":"https://weeweetan.github.io/2018/08/08/Java与PHP之间的Socket通信/","excerpt":"","text":"Java作为服务端Java端作为服务端，PHP端作为客户端，在之前一篇文章中说了下PHP作为客户端如何与Java端进行通信。由于业务需要，socket必须等待服务端处理完成，并返回处理结果给PHP端。在这里主要说明一下Java端如何处理的，不足之处，望指正。12345678910111213141516171819202122232425262728ServerSocket serverSocket = new ServerSocket(port); //创建绑定到特定端口的服务器套接字Socket socket = serverSocket.accept(); //侦听并接受到此套接字的连接InputStream inputStream = socket.getInputStream();StringBuilder sb = new StringBuilder();byte[] packetLength = new byte[4];inputStream.read(packetLength, 0, 4); //首先从套接字中读取4字节的数据长度int target = byteToint(packetLength); //这里将字节数组转换成整数System.out.println(\"message size:\" + target);byte[] bytes = new byte[target];inputStream.read(bytes); //读取指定长度的数据sb.append(new String(bytes, 0, target, \"UTF-8\"));System.out.println(\"get message \" + sb);String result = \"has receive message\";OutputStream outputStream = socket.getOutputStream();int responseLength = result.getBytes().length; //这个地方的长度，一定要是字节数组的长度，否则如果字符串中包含中文，接收端接收数据会不完整 byte[] targets = intTobyte(responseLength);outputStream.write(targets); //首先发送4个字节的数据大小outputStream.write(result.getBytes()); //再发送真正的数据outputStream.flush();outputStream.close();inputStream.close();socket.close();上述代码需要处异常，而且代码中的byteToint和intTobyte这两个函数非原创，是其他博主的劳动成果，感谢这位作者，原文地址https://www.cnblogs.com/langren1992/p/4717241.html。PHP作为服务端相关函数: socket_create、socket_set_block、socket_bind、socket_listen、socket_accept、socket_read、socket_write，这些函数具体参数说明在PHP文档上写很详细，这里就不再赘述，这里只是介绍服务端如何处理请求。12345678910111213141516171819202122232425262728293031323334353637383940//确保在连接客户端时不会超时set_time_limit(0);//设置IP和端口号$address = \"127.0.0.1\";$port = 54321;$socketServer = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(\"socket_create() fail:\" . socket_strerror(socket_last_error()) . \"/n\");//设置为阻塞模式socket_set_block($socketServer) or die(\"socket_set_block() fail:\" . socket_strerror(socket_last_error()) . \"/n\");//绑定端口$result = socket_bind($socketServer, $address, $port) or die(\"socket_bind() fail:\" . socket_strerror(socket_last_error()) . \"/n\");//开始监听$result = socket_listen($socketServer, 4) or die(\"socket_listen() fail:\" . socket_strerror(socket_last_error()) . \"/n\");do &#123; //接收连接请求并返回一个子Socket来处理客户端和服务器间的信息 $sock = socket_accept($socketServer) or die(\"socket_accept() failed: reason: \" . socket_strerror(socket_last_error()) . \"/n\"); while($sock)&#123; //读取客户端数据 echo \"Read client data \\n\"; $length = socket_read($sock, 4); $length = unpack('i', $length); echo \"length:$length[1] \\n\"; $request = socket_read($sock, $length[1]); echo \"$request:$request \\n\"; //数据传送 向客户端写入返回结果 $msg = \"this is response message \\n\"; $msgLength = strlen($msg); $msgLength = pack('i', $msgLength); socket_write($sock, $msgLength); socket_write($sock, $msg, strlen($msg)) or die(\"socket_write() failed: reason: \" . socket_strerror(socket_last_error()) .\"/n\"); break; &#125;&#125; while (true);//根据需要关闭socketsocket_close($socketServer);在接收到客户端的请求后，可以结合PHP的多线程进行处理，这里只是简单的返回字符串。总结各大语言实现socket通信的方式都是大同小异，在服务端的流程都是差不多的。在有现成高性能socket通信框架的情况下，建议不要自己去实现，但是得理解框架底层是怎样实现的。","categories":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/categories/Socket/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/tags/Socket/"},{"name":"Java","slug":"Java","permalink":"https://weeweetan.github.io/tags/Java/"}]},{"title":"VMware vSphere WebService SDK使用心得","slug":"VMware-vSphere-WebService-SDK使用心得","date":"2018-07-25T12:13:58.000Z","updated":"2019-05-15T13:27:59.170Z","comments":true,"path":"2018/07/25/VMware-vSphere-WebService-SDK使用心得/","link":"","permalink":"https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK使用心得/","excerpt":"","text":"善用mob（Managed Object Browser）mob地址一般是https://vcenter的FQDN/mob，mob可以让你更好的理解SDK中的那些例子，以及根据自己的业务逻辑改写一些功能。下图为mob首页图，图中的content为整个Managed Object的顶层，从这里进去可以找到整个vcenter server中所有对象及其属性。善用GetMOREF类GetMOREF类具体位置在VMware-vSphere-SDK-6.0.0-2561048\\SDK\\vsphere-ws\\java\\JAXWS\\samples\\com\\vmware\\connection\\helpers，这是VMware官方提供的一个工具类，里面的每个函数对于开发都很有用。例如​List&lt;VirtualDevice&gt; listvd = ((ArrayOfVirtualDevice) getMOREFs .entityProps(vmMor, new String[] { &quot;config.hardware.device&quot; }) .get(&quot;config.hardware.device&quot;)).getVirtualDevice(); 这是VMReconfig.java中的一个片段，这段代码的作用就是去获取指定虚拟机对象的所有设备，vmMor可以通过GetMOREF类中的vmByVMname函数去获得。至于config.hardware.device，就需要用mob一层一层点进去看了，相信结合mob就能理解为什么要这么写。​​ ManagedObjectReference propCol = connection.getServiceContent().getPropertyCollector(); ManagedObjectReference vmRef = getMOREFs.vmByVMname(virtualMachineName,propCol); 上面这段代码的作用就是如何根据虚拟机名去获取其对应的ManagedObjectReference善用SDK里面的文档文档首页为VMware-vSphere-SDK-6.0.0-2561048/SDK/vsphere-ws/docs/ReferenceGuide/index.html根据需求，在左侧导航栏对应的去找。对SDK我整理了一下，使其能够在idea中编译运行，项目地址在VMwareProject ​","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"Socket粘包处理","slug":"Socket粘包处理","date":"2018-07-25T11:05:52.000Z","updated":"2019-07-16T15:11:06.374Z","comments":true,"path":"2018/07/25/Socket粘包处理/","link":"","permalink":"https://weeweetan.github.io/2018/07/25/Socket粘包处理/","excerpt":"","text":"背景这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据，并等待Java的响应结果，数据格式为JSON。遇到的问题PHP端发送数据后，Java端从socket里读取数据，但是一直读不到结束符。原因PHP需要调用socket_close函数才会向socket里面写入结束符。改进方法PHP端与Java端之间确定每次发送数据包的长度，用4个字节表示数据长度，PHP端先发送数据包长度，再发送数据包，Java端先接收4个字节长度的数据包长度，再根据数据包长度接收数据包。PHP端代码如下:1234567891011121314$socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP ) or die ( 'could not create socket' ); $connect = socket_connect ( $socket, 'xxx.xxx.xxx.xxx', xxxx); //服务端发送数据 $arr = array(\"data\" =&gt; \"dadadada\");$strlen = pack('i', strlen(json_encode($arr)));var_dump($strlen);socket_write ($socket, $strlen);socket_write ($socket, json_encode($arr), strlen(json_encode($arr)));$response = socket_read($socket, 4); $res = unpack('i', $response);var_dump($res);$response = socket_read($socket, $res[1]);var_dump($response);socket_close($socket);pack与unpack函数使用说明见PHP官方文档​","categories":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/categories/Socket/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/tags/Socket/"}]},{"title":"使用gcc编译驱动模块遇到的问题","slug":"使用gcc编译驱动模块遇到的问题","date":"2017-05-22T09:30:33.000Z","updated":"2019-05-17T15:43:16.624Z","comments":true,"path":"2017/05/22/使用gcc编译驱动模块遇到的问题/","link":"","permalink":"https://weeweetan.github.io/2017/05/22/使用gcc编译驱动模块遇到的问题/","excerpt":"","text":"背景由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客写一个块设备驱动学习，练习环境为centos6.5 gcc版本为6.3。遇到的问题跟着敲完那个简单的驱动程序后，发现编译出错，错误信息为include/linux/compiler-gcc.h:89:30: fatal error: linux/compiler-gcc6.h: No such file or directory 一通百度，说gcc版本太高，去下载一个compiler-gcc6.h文件，放到内核源码文件夹里面，按着做了，结果编译又出问题了，错误信息为include/linux/compiler.h:163:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void data_access_exceeds_word_size(void) include/linux/compiler.h:169:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void data_access_exceeds_word_size(void) include/linux/compiler.h:173:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void __read_once_size(volatile void *p, void *res, int size) include/linux/compiler.h:190:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void __write_once_size(volatile void *p, void *res, int size) 解决方法又是一通百度，发现跟我情况不符，看了下博客发表时间，08年，果断换了一个centos6.0的机器，gcc版本为4.6，编译完美通过,环境因素很重要啊。。。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/categories/Linux/"}],"tags":[{"name":"驱动模块","slug":"驱动模块","permalink":"https://weeweetan.github.io/tags/驱动模块/"},{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/tags/Linux/"}]},{"title":"PHP脚本中使用exec总结","slug":"PHP脚本中使用exec总结","date":"2017-02-20T01:03:11.000Z","updated":"2019-05-17T15:54:50.468Z","comments":true,"path":"2017/02/20/PHP脚本中使用exec总结/","link":"","permalink":"https://weeweetan.github.io/2017/02/20/PHP脚本中使用exec总结/","excerpt":"","text":"背景总结一下这两天加班遇到的坑，由于本次任务涉及到在PHP中使用exec函数运行shell命令，并解析返回值。屁颠屁颠的写好代码，上传到服务器，服务器环境配置centos6.5+Nginx，ssh到服务器，在控制台运行php xxx.php结果完美显示。蛋疼的是前端调用脚本的时候，没有数据，返回false，一脸懵逼，开始想问题所在，试着在浏览器地址栏直接访问xxx.php没有结果。然后把代码改成exec(&quot;ls 2&gt;&amp;1&quot;, $result); var_dump($result); 显示ls命令没找到，试着加上路径exec(&quot;/bin/ls 2&gt;&amp;1&quot;, $result); var_dump($result); 显示权限不够。解决方法lsof -i:80 查看你Nginx的用户是谁，我这里是nginx在脚本中添加file_put_contents(“/tmp/test.log”, “xxx”)查看test.log的用户是谁。我这里是nobody在vim /etc/sudoers添加权限nobody ALL=(ALL) NOPASSWD:ALLnginx ALL=(ALL) NOPASSWD:ALL重启nginx服务。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"}]},{"title":"Esxi5.1挂载NFS存储遇到的问题及解决办法","slug":"Esxi5-1挂载NFS存储遇到的问题及解决办法","date":"2017-01-13T01:18:44.000Z","updated":"2019-05-18T01:20:29.052Z","comments":true,"path":"2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/","link":"","permalink":"https://weeweetan.github.io/2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/","excerpt":"","text":"背景如何配置NFS以及怎样在Esxi中添加NFS，可以参考VMware ESXI 5.5使用NFS添加存储器, 我也是按照这个博客来配置的。遇到的问题遇到如下问题：解决方法必须要检查你的esxi主机是否配置了VMkernel，检查步骤如下：1、使用 VI/vSphere Client 连接到 Virtual Center/vCenter Server。2、选择 ESX/ESXi 主机。3、单击配置选项卡。4、单击网络。5、查看 VMKernel 的网络图，或单击属性 &gt; 端口 &gt; VMKernel。如果 VMKernel 未列出，必须添加它。手动挂载手动挂载命令：esxcli storage nfs add -H NFS_IP|NFS_HOSTNAME -s Share_mount_point_on_the_NFS -v DatastoreName 注意事项必须保证esxi主机与NFS服务器在同一网段或者能够相互通信","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"linux下编译vddk例程的错误总结","slug":"linux下编译vddk例程的错误总结","date":"2016-11-10T09:29:27.000Z","updated":"2019-05-18T02:28:46.640Z","comments":true,"path":"2016/11/10/linux下编译vddk例程的错误总结/","link":"","permalink":"https://weeweetan.github.io/2016/11/10/linux下编译vddk例程的错误总结/","excerpt":"","text":"背景vddk是visual disk development kit的缩写，是VMware vSphere提供的可用来操作虚拟磁盘的一套SDK，具体可看VDDK Document，在这里记录一下编译问题。遇到的问题按照官方文档编译vixDiskLibSample.cpp时报错Package vix-disklib was not found in the pkg-config search path. Perhaps you should add the directory containing `vix-disklib.pc&apos; to the PKG_CONFIG_PATH environment variable No package &apos;vix-disklib&apos; found 解决方法按照官方文档的说明编辑~/.bash_profile,添加如下内容：PKG_CONFIG_PATH=/usr/lib/pkgconfig export PKG_CONFIG_PATH LD_LIBRARY_PATH=/usr/lib/vmware-vix-disklib/lib64 export LD_LIBRARY_PATH 其中/usr/lib/vmware-vix-disklib/lib64是vddk安装后，默认的lib路径，添加完成后执行source bash_profile 再次编译就成功了","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"},{"name":"vddk","slug":"vddk","permalink":"https://weeweetan.github.io/tags/vddk/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2016-08-05T13:58:21.000Z","updated":"2019-06-30T14:41:35.713Z","comments":true,"path":"2016/08/05/Linux常用命令/","link":"","permalink":"https://weeweetan.github.io/2016/08/05/Linux常用命令/","excerpt":"","text":"vim1、使用u退回上一步2、使用U一次撤销对当前行的全部操作3、vim + filename 表示把光标定位到文件最后一行4、vim +数字 filemame 定位到数字行，如果超过文件行数，定位到最后一行5、vim +/word filename 定位到Word第一次出现的行，按n切换6、vim file1 file2 file3 一次性打开或者创建多个文件，底行模式下使用:n向后切换文件，:N和prev向前切换文件7、:w save:q quit:! 强制:ls 列出当前编辑器打开的所有文件:n 切换到下一个文件:N 切换到前一个文件:15 定位到15行:/xxx 表示从光标位置向后搜索xxx,定位到第一次出现的时候:?xxx搜索8、命令行模式常用命令h 光标左移j 光标下移k 光标上移l 光标右移Ctrl+f 向下翻页（front）Ctrl+b 向上翻页（back）Ctrl+d 向下翻半页（down）Ctrl+u 向上翻半页（up）df查看磁盘分区使用状况-l 仅显示本地磁盘（默认）-a 显示所有文件系统的磁盘使用情况-h 以1024进制计算最适合的单位显示磁盘容量-H 以1000进制计算最适合的单位显示磁盘容量-T 显示磁盘分区类型-t 显示指定类型文件系统的磁盘分区-x 不显示指定类型文件系统的磁盘分区du统计磁盘上的文件大小-b 以byte为单位统计文件-k 以KB为单位统计文件-m 以MB为单位统计文件-h 按照1024进制以最适合的单位统计文件-H 按照1000进制以最适合的单位统计文件-s 指定统计目标lsof可以列出被进程所打开的文件的信息。被打开的文件可以是1.普通的文件2.目录3.网络文件系统的文件4.字符设备文件5.(函数)共享库6.管道，命名管道7.符号链接8.底层的socket字流，网络socket，unix域名socket9.在linux里面，大部分的东西都是被当做文件的…..还有其他很多怎样使用lsof这里主要用案例的形式来介绍lsof 命令的使用列出所有打开的文件:lsof备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位查看谁正在使用某个文件lsof /filepath/file递归查看某个目录的文件信息lsof +D /filepath/filepath2/备注: 使用了+D，对应目录下的所有子目录和文件都会被列出比使用+D选项，遍历查看某个目录的所有文件信息 的方法lsof | grep ‘/filepath/filepath2/’列出某个用户打开的文件信息lsof -u username备注: -u 选项，u其实是user的缩写列出某个程序所打开的文件信息lsof -c mysql备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成lsof | grep mysql,但是第一种方法明显比第二种方法要少打几个字符了列出多个程序多打开的文件信息lsof -c mysql -c apache列出某个用户以及某个程序所打开的文件信息lsof -u test -c mysql列出除了某个用户外的被打开的文件信息lsof -u ^root备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示通过某个进程号显示该进行打开的文件lsof -p 1列出多个进程号对应的文件信息lsof -p 123,456,789列出除了某个进程号，其他进程号所打开的文件信息lsof -p ^113 . 列出所有的网络连接lsof -i列出所有tcp 网络连接信息lsof -i tcp列出所有udp网络连接信息lsof -i udp列出谁在使用某个端口lsof -i :3306列出谁在使用某个特定的udp端口lsof -i udp:55特定的tcp端口lsof -i tcp:80列出某个用户的所有活跃的网络端口lsof -a -u test -i列出所有网络文件系统lsof -N域名socket文件lsof -u某个用户组所打开的文件信息lsof -g 5555根据文件描述列出对应的文件信息lsof -d description(like 2)根据文件描述范围列出文件信息lsof -d 2-3top系列iotop – I/O 监控iotop 命令利用 Linux 内核监控 I/O 使用情况，它按进程或线程的顺序显示 I/O 使用情况。htop – 交互式的进程查看器htop 是一款免费并开源的基于 ncurses 的 Linux 进程查看器。它比 top 命令更简单易用。您无需使用 PID、无需离开 htop 界面，便可以杀掉进程或调整其调度优先级。atop – 高级版系统与进程监控工具atop 是一个非常强大的交互式 Linux 系统负载监控器，它从性能的角度显示最关键的硬件资源信息。您可以快速查看 CPU、内存、磁盘和网络性能。它还可以从进程的级别显示哪些进程造成了相关 CPU 和内存的负载。iftop – 显示主机上网络接口的带宽使用情况iftop 命令监听指定接口（如 eth0）上的网络通信情况。它显示了一对主机的带宽使用情况。vmstat虚拟内存统计显示 Slab 缓存的利用率vmstat -m 获取有关活动和非活动内存页面的信息vmstat -a grep高亮搜索关键字step1:修改~/.bashrc，在~/.bashrc中添加如下内容alias grep=’grep –color=auto’step2:重新加载.bashrc文件source ~/.bashrcnetstat-a ：all，表示列出所有的连接，服务监听，Socket资料-t ：tcp，列出tcp协议的服务-u ：udp，列出udp协议的服务-n ：port number， 用端口号来显示-l ：listening，列出当前监听服务-p ：program，列出服务程序的PIDps显示长输出格式# ps -Al 显示完整输出格式（它将显示传递给进程的命令行参数）# ps -AlF 显示线程（轻量级进程（LWP）和线程的数量（NLWP））# ps -AlFH 在进程后显示线程# ps -AlLm 显示系统上所有的进程# ps ax # ps aux 显示进程树# ps -ejH # ps axjf # pstree 显示进程的安全信息# ps -eo euser,ruser,suser,fuser,f,comm,label # ps axZ # ps -eM 显示指定用户（如 vivek）运行的进程# ps -U vivek -u vivek u 设置用户自定义的输出格式# ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm # ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm # ps -eopid,tt,user,fname,tmout,f,wchan 显示某进程（如 lighttpd）的 PID# ps -C lighttpd -o pid= 或# pgrep lighttpd 或# pgrep -u vivek php-cgi 显示指定 PID（如 55977）的进程名称# ps -p 55977 -o comm= 找出占用内存资源最多的前 10 个进程# ps -auxf | sort -nr -k 4 | head -10 找出占用 CPU 资源最多的前 10 个进程# ps -auxf | sort -nr -k 3 | head -10 ##ssss 命令用于获取套接字统计信息。它可以显示类似于 netstat 的信息。不过 netstat 几乎要过时了，ss 命令更具优势。要显示所有 TCP 或 UDP 套接字：# ss -t -a 或# ss -u -a 显示所有带有 SELinux 安全上下文Security Context的 TCP 套接字：# ss -t -a -Z pmappmap 命令用以显示进程的内存映射，使用此命令可以查找内存瓶颈。# pmap -d PID 显示 PID 为 47394 的进程的内存信息，请输入：# pmap -d 47394 sar?sar 命令用于收集、汇报和保存系统活动信息。要查看网络统计，请输入：# sar -n DEV | more 显示 24 日的网络统计：# sar -n DEV -f /var/log/sa/sa24 | more 显示实时使用情况：# sar 4 5 mpstatmpstat 命令显示每个可用处理器的使用情况，编号从 0 开始。命令 mpstat -P ALL 显示了每个处理器的平均使用率：# mpstat -P ALL w显示了当前登录在该系统上的用户及其进程。# w username tcpdumptcpdump 命令是简单的分析网络通信的命令。您需要充分了解 TCP/IP 协议才便于使用此工具。例如，要显示有关 DNS 的流量信息，请输入：# tcpdump -i eth1 &apos;udp port 53&apos; 查看所有去往和来自端口 80 的 IPv4 HTTP 数据包，仅打印真正包含数据的包，而不是像 SYN、FIN 和仅含 ACK 这类的数据包，请输入：# tcpdump &apos;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&apos; 显示所有目标地址为 202.54.1.5 的 FTP 会话，请输入：# tcpdump -i eth1 &apos;dst 202.54.1.5 and (port 21 or 20&apos; 打印所有目标地址为 192.168.1.5 的 HTTP 会话：# tcpdump -ni eth0 &apos;dst 192.168.1.5 and tcp and port http&apos; 使用 wireshark 查看文件的详细内容，请输入：# tcpdump -n -i eth1 -s 0 -w output.txt src or dst port 80 lsb_releaselsb_release是读取/etc/redhat-release文件中的第一行记录，这里面记载了系统版本!!在Linux命令行中有特色含义，即感叹号后面的内容会被截断，所以如果需要将感叹号当作普通字符处理，需要使用单引号，如下：echo &quot;hello world&apos;!&apos;&quot; fdiskfdisk只能给磁盘做MBR分区，MBR只能有四个主分区，每个分区最大2TBpartedparted既可以做MBR分区也可以做GPT分区，GPT几乎没有分区限制，也没有大小限制ntpdatentpdate命令是用来设置本地日期和时间。它从指定的每个服务器获得了一些样本，并应用标准 NTP 时钟过滤器和选择算法来选择最好的样本。可使用如下命令进行网络时间更新ntpdate -u ntp.api.bz -u参数可以越过防火墙与主机同步；ntp.api.bz：NTP服务器(上海)。iptablesiptables命令是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。pkillpkill命令可以按照进程名杀死进程。语法pkill(选项)(参数) 选项-o：仅向找到的最小（起始）进程号发送信号；-n：仅向找到的最大（结束）进程号发送信号；-P：指定父进程号发送信号；-g：指定进程组；-t：指定开启进程的终端。kill","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/tags/Linux/"}]},{"title":"centos6.5下lamp环境部署laravel","slug":"centos6-5下lamp环境部署laravel","date":"2016-07-31T13:54:35.000Z","updated":"2019-05-18T13:56:16.929Z","comments":true,"path":"2016/07/31/centos6-5下lamp环境部署laravel/","link":"","permalink":"https://weeweetan.github.io/2016/07/31/centos6-5下lamp环境部署laravel/","excerpt":"","text":"安装composer，命令如下curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer chmod +x /usr/local/bin/composer 切换到Apache默认目录下cd /var/www/ composer create-project laravel/laravel --prefer-dist &quot;5.1.11&quot; composer install 修改权限cd laravel chmod -R 777 storage/ 修改配置vim/etc/httpd/conf/httpd.conf 把DocumentRoot “/var/www/html”改为DocumentRoot “/var/www/laravel/public”重启Apache服务service httpd restart","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"https://weeweetan.github.io/tags/Laravel/"}]},{"title":"MySQL常见问题","slug":"MySQL常见问题","date":"2016-05-22T05:55:31.000Z","updated":"2019-05-25T15:38:28.194Z","comments":true,"path":"2016/05/22/MySQL常见问题/","link":"","permalink":"https://weeweetan.github.io/2016/05/22/MySQL常见问题/","excerpt":"","text":"修改目录后MySQL无法启动这种问题一般是selinux造成的1、终端输入sestatus，如出现SELinux status: enabled，则selinux为开启状态，2、编辑/etc/selinux/config 文件，将SELINUX=enforcing改为SELINUX=disabled，重启机器修改密码修改密码分为两种情况，一种情况是拥有原来密码，另外一种情况则是忘记密码拥有原来的myql的root的密码；方法一：在mysql系统外，使用mysqladmin# mysqladmin -u root -p password &quot;test123&quot; Enter password: 【输入原来的密码】 方法二：通过登录mysql系统，# mysql -uroot -p Enter password: 【输入原来的密码】 mysql&gt;use mysql; mysql&gt; update user set password=password(&quot;test&quot;) where user=&apos;root&apos;; mysql&gt; flush privileges; mysql&gt; exit; 忘记原来的myql的root的密码；首先，你必须要有操作系统的root权限了。要是连系统的root权限都没有的话，先考虑root系统再走下面的步骤。类似于安全模式登录系统，有人建议说是pkill mysql，但是我不建议哈。因为当你执行了这个命令后，会导致这样的状况：/etc/init.d/mysqld statusmysqld dead but subsys locked这样即使你是在安全模式下启动mysql都未必会有用的，所以一般是这样/etc/init.d/mysqld stop，如果你不幸先用了pkill，那么就start一下再stop咯。# mysqld_safe --skip-grant-tables &amp; &amp;，表示在后台运行，不再后台运行的话，就再打开一个终端咯。# mysql mysql&gt; use mysql; mysql&gt; UPDATE user SET password=password(&quot;test123&quot;) WHERE user=&apos;root&apos;; mysql&gt; flush privileges; mysql&gt; exit; 本来mysql是不分大小写的，但是这个是修改的mysql中的mysql数据库的具体的值，要注意到。插入10万条记录的SQLdrop table if exists foo; create table foo ( id int unsigned not null auto_increment primary key, val smallint unsigned not null default 0 ) engine=innodb; drop procedure if exists load_foo_test_data; delimiter # create procedure load_foo_test_data() begin declare v_max int unsigned default 100000; declare v_counter int unsigned default 0; truncate table foo; start transaction; while v_counter &lt; v_max do insert into foo (val) values ( floor(0 + (rand() * 65535)) ); set v_counter=v_counter+1; end while; commit; end # delimiter ; call load_foo_test_data(); MySQL开启远程访问选择mysql库，选user表 新增用户mysql&gt; insert into user(Host,User,Password) values(&apos;%&apos;,&apos;用户名（必须是英文数字）&apos;,&apos;密码&apos;); 刷新权限mysql&gt;flush privileges; 授权给新增的用户mysql&gt; Grant all privileges on *.* to &apos;用户名&apos;@&apos;%&apos; identified by &apos;密码&apos; with grant option; 注释：其中：“ . ”代表所有数据库和表（也就是root权限） 其格式为:数据库名称 . 表名刷新权限mysql&gt;flush privileges; 数据库优化十个原则尽量避免在列上进行计算，这样会导致索引失效select * from t where year(d)&gt;=2011 =&gt; select * from t where d&gt;=&apos;2011-01-01&apos;; 使用join时，应该用小结果集驱动大结果集。同时把复杂的join查询拆分成多个query。因为join多个表时，可能导致更多的锁定和堵塞。注意like模糊查询的使用，避免%%。仅列出需要查询的字段，这对速度不会又明显的影响，主要考虑节省内存。使用批量插入语句节省交互。limit的基数比较大时使用between。不要使用rand函数获取多条随机记录。避免使用null不要使用count(id),而应该是count(*)不要做所谓的排序操作，而应尽可能在索引中完成排序。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://weeweetan.github.io/tags/MySQL/"}]}]}