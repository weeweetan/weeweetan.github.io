{"meta":{"title":"weeweetan's blog","subtitle":null,"description":null,"author":"weeweetan","url":"https://weeweetan.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-05-15T04:37:44.497Z","updated":"2019-05-15T04:37:44.497Z","comments":false,"path":"categories/index.html","permalink":"https://weeweetan.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-04-30T06:58:00.000Z","updated":"2019-05-15T06:20:17.816Z","comments":true,"path":"about/index.html","permalink":"https://weeweetan.github.io/about/index.html","excerpt":"","text":"尝试过的技术 VMware虚拟机备份与恢复 数据库备份与恢复 基于卷的持续数据保护 Linux块设备驱动 Linux C编程 ThinkPHP框架 Laravel框架 Java SE 目前正在研究的技术 Nginx CDN"},{"title":"友情链接","date":"2019-05-15T04:37:44.497Z","updated":"2019-05-15T04:37:44.497Z","comments":true,"path":"links/index.html","permalink":"https://weeweetan.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-05-15T04:37:44.498Z","updated":"2019-05-15T04:37:44.498Z","comments":false,"path":"repository/index.html","permalink":"https://weeweetan.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-15T06:47:15.597Z","updated":"2019-05-15T04:37:44.499Z","comments":false,"path":"tags/index.html","permalink":"https://weeweetan.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-05-15T04:37:44.496Z","updated":"2019-05-15T04:37:44.496Z","comments":false,"path":"books/index.html","permalink":"https://weeweetan.github.io/books/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2019-05-15T01:36:14.000Z","updated":"2019-05-15T01:42:30.056Z","comments":true,"path":"resume/index.html","permalink":"https://weeweetan.github.io/resume/index.html","excerpt":"","text":""}],"posts":[{"title":"Dos常用命令","slug":"Dos常用命令","date":"2019-05-26T05:56:27.000Z","updated":"2019-05-26T06:04:11.118Z","comments":true,"path":"2019/05/26/Dos常用命令/","link":"","permalink":"https://weeweetan.github.io/2019/05/26/Dos常用命令/","excerpt":"","text":"sc sc命令可用于卸载windows服务，如下所示： sc delete serv 其中serv为服务名，可在服务中查看 xcopy xcopy命令用于Dos下复制文件夹及子文件夹，如下所示： xcopy d:\\abc\\aaa\\*.* c:\\windows\\system /s 其中第一个参数是源位置，第二个参数是目标位置/s：复制目录和子目录，除了空的。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"Dos","slug":"Dos","permalink":"https://weeweetan.github.io/tags/Dos/"}]},{"title":"中国菜翻译方法","slug":"中国菜翻译方法","date":"2019-05-18T02:27:42.000Z","updated":"2019-05-18T02:32:50.166Z","comments":true,"path":"2019/05/18/中国菜翻译方法/","link":"","permalink":"https://weeweetan.github.io/2019/05/18/中国菜翻译方法/","excerpt":"","text":"以主料为主 配料或配汁为辅的翻译原则菜肴的主料和配料 主料（名称/形状）+ with + 配料 如：松仁香菇 Chinese Mushrooms with Pine Nuts 菜肴的主料和配汁 主料 + with / in + 汤汁（Sauce） 如：冰梅凉瓜 Bitter Melon in Plum Sauc 以烹制方法为主 原料为辅的翻译原则菜肴的做法和主料 做法（动词过去分词）+ 主料（名称/形状） 如：拌双耳 Tossed Black and White Fungus 菜肴的做法、主料和汤汁 做法(动词过去分词) + 主料（名称/形状）+ with / in + 汤汁 如：京酱肉丝 Sautéed Shredded Pork in Sweet Bean Sauce 以形状、口感为主 原料为辅的翻译原则菜肴形状或口感以及主配料 形状/口感 + 主料 如：玉兔馒头 Rabbit-Shaped Mantou菜肴的做法、形状或口感、做法以及主配料 做法（动词过去分词）+ 形状/口感 + 主料 + 配料 如： 小炒黑山羊 Sautéed Sliced Lamb with Pepper and Parsley","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"https://weeweetan.github.io/tags/翻译/"}]},{"title":"C语言编程常见错误","slug":"C语言编程常见错误","date":"2019-05-17T15:21:03.000Z","updated":"2019-05-30T03:33:21.606Z","comments":true,"path":"2019/05/17/C语言编程常见错误/","link":"","permalink":"https://weeweetan.github.io/2019/05/17/C语言编程常见错误/","excerpt":"","text":"1. 使用close函数出现bad file descriptor错误 出现这种错误一般是两次close导致，仔细检查代码，调用close关闭文件描述符后，应该将文件描述符置为0，避免重复调用close，切记切记。 2. 守护程序闪退问题 出现这个问题一般是两次释放同一块内存，仔细检查释放内存与指针赋值相关代码，释放内存后，应将指针置为NULL，避免重复调用close，切记切记。 3. 四字节对齐4. 什么是四字节对齐 现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。 4.1 四字节对齐作用 定义结构体成员时应当注意四字节对齐，保证内存利用最大化。但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。 5. 柔性数组 定义结构体时，最后一个成员定义为 struct test { int a; char b[0]; } b[0]就称为柔性数组，使用 sizeof(struct test); 返回值为4，即b[0]不占用内存空间。 6. 数字转字符 C语言书籍上可能出现过如下代码将数字转为字符 int a = 0; char b = a + &apos;0&apos;; 这个操作有局限性，当a的值超过9的时候就会得到你意向不到的结果， int a = 10; char b = a + &apos;0&apos;; 这个时候字符b的值为’:’","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"C","slug":"C","permalink":"https://weeweetan.github.io/tags/C/"}]},{"title":"Nginx学习笔记","slug":"Nginx学习笔记","date":"2019-05-08T02:49:55.000Z","updated":"2019-05-31T14:01:17.028Z","comments":true,"path":"2019/05/08/Nginx学习笔记/","link":"","permalink":"https://weeweetan.github.io/2019/05/08/Nginx学习笔记/","excerpt":"","text":"1. 编译步骤1.1 configure原理 configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。 1.2 auto脚本 auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。 1.2.1 auto/options脚本 auto/options主是处理用户输入的configure选项，以及输出帮助信息等。auto/options的目的主要是处理用户选项，并由选项生成一些全局变量的值，这些值在其它文件中会用到。该文件也会输出configure的帮助信息。应当注意如下代码 for option do opt=&quot;$opt `echo $option | sed -e \\&quot;s/\\(--[^=]*=\\)\\(.* .*\\)/\\1&apos;\\2&apos;/\\&quot;`&quot; for后面可以省略要遍历的变量,这时,表示在遍历$@,即用户传入的所有变量组合 1.2.2 auto/init脚本 该文件的目录在于初始化一些临时文件的路径，检查echo的兼容性，并创建最原始的Makefile文件。 淘宝Nginx开发从入门到精通 注意：这里生成的Makefile文件与configure文件在同一目录，真正执行编译指令的Makefile在objs目录下 1.2.3 auto/sources脚本 该文件从文件名中就可以看出，它的主要功能是跟源文件相关的。它的主要作用是定义不同功能或系统所需要的文件的变量。根据功能，分为CORE/REGEX/EVENT/UNIX/FREEBSD/HTTP等。每一个功能将会由四个变量组成，”_MODULES”表示此功能相关的模块，最终会输出到ngx_modules.c文件中，即动态生成需要编译到nginx中的模块；”INCS”表示此功能依赖的源码目录，查找头文件的时候会用到，在编译选项中，会出现在”-I”中；”DEPS”显示指明在Makefile中需要依赖的文件名，即编译时，需要检查这些文件的更新时间；”SRCS”表示需要此功能编译需要的源文件。 淘宝Nginx开发从入门到精通 根据上面的描述，所以如果需要对nginx进行功能扩展，添加相应的C文件后，修改这个脚本就可以将自己的功能编译进nginx。 2. 源码解析2.1 模块相关 在ngx_module.h中引用了两个至关重要的外部变量 extern ngx_module_t *ngx_modules[]; extern char *ngx_module_names[]; ngx_modules跟ngx_module_names定义在ngx_modules.c中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用ngx_cycle_modules函数，原型如下： ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle) 此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下： main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules 2.2 数据结构2.2.1 ngx_str_t Nginx开发从入门到精通已经对ngx_str_t的定义以及相关api进行了非常详细的讲解，以下为定义： typedef struct { size_t len; u_char *data; } ngx_str_t; 注意事项： 不要试图复制char *到data所指向的内存，可能导致coredump 初始化相关api都是基于常量字符串，char *类型慎用 如果非要复制char *到data所指向的内存，一定先分配内存 2.2.2 ngx_array_t Nginx开发从入门到精通已经对ngx_array_t的定义以及相关api进行了非常详细的讲解，以下为定义： typedef struct ngx_array_s ngx_array_t; struct ngx_array_s { void *elts; ngx_uint_t nelts; size_t size; ngx_uint_t nalloc; ngx_pool_t *pool; }; 注意事项 如果使用ngx_array_t作为字符串容器，在调用ngx_array_create时，使用字符串长度最后一个参数 ngx_array_push返回第n个元素首地址，要注意指针运算 3. handler模块的编写步骤 编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量： static ngx_command_t ngx_http_module_name_commands[] = {}; static ngx_http_module_t ngx_http_module_name_module_ctx = {}; ngx_module_t ngx_http_module_name_module = {}; 实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数： static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)； 编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数： static ngx_int_t ngx_http_module_name_handler(ngx_http_request_t *r);","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"libxml2使用心得","slug":"libxml2使用心得","date":"2019-05-04T14:21:35.000Z","updated":"2019-05-15T07:04:26.805Z","comments":true,"path":"2019/05/04/libxml2使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/05/04/libxml2使用心得/","excerpt":"","text":"背景 由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考C++的XML编程经验――LIBXML2库使用指南，这篇博文讲得很详细，我在这里只是做出一点补充。 问题 xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。 举例说明 我使用GLib2的g_locale_from_utf8将内容转换为本地程序默认的编码格式，在写入xml内容时使用g_locale_to_utf8将内容转换为UTF-8. 总结 总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。","categories":[{"name":"libxml","slug":"libxml","permalink":"https://weeweetan.github.io/categories/libxml/"}],"tags":[{"name":"libxml","slug":"libxml","permalink":"https://weeweetan.github.io/tags/libxml/"}]},{"title":"GLib使用心得","slug":"GLib使用心得","date":"2019-04-28T05:51:59.000Z","updated":"2019-05-18T01:23:41.021Z","comments":true,"path":"2019/04/28/GLib使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/04/28/GLib使用心得/","excerpt":"","text":"前言 关于GLib的介绍这里就不赘述了，具体API介绍可以去GLib API Reference查阅，这里只是记录一下使用相关API所遇到的一些坑。 相关API字符串相关APIGString *g_string_new(const gchar *init); GString *g_string_append(GString *string, const gchar *val); GString *g_string_prepend(GString *string, const gchar *val); gchar *g_string_free(GString *string, gboolean free_segment); 如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。注意 g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。g_string_append跟g_string_prepend都是直接在原字符串上操作，这点要切记。 字符转换相关APIgchar *g_filename_display_basename(const gchar *filename); gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error); gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error); g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8下面看个例子, 比如我们有个含中文的文件名 /data/test/哈哈.txt如果想获得 哈哈.txt，则必须首先使用 g_locale_to_utf8函数转换一次, 然后再去获取basename GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;); gchar *str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); gchar *basename = g_filename_display_basename(str); 如果想使用GString *类型保存basename，则必须重新申请内存块 GString *basename_string = g_string_new(basename); 千万别像下面这样做 GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;); string-&gt;str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); 如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，g_locale_from_utf8 同理注意 g_locale_to_utf8返回的char *需要手动释放内存 解析key-value文件APIGKeyFile *g_key_file_new(void); gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error); gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error); gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error); void g_key_file_free(GKeyFile *key_file); 这几个API很好理解,用来解析具有键值对特征的文件,g_key_file_new跟g_key_file_free配套使用;g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;","categories":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/categories/GLib/"}],"tags":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/tags/GLib/"}]},{"title":"调用glib库出现0xc000007b解决办法","slug":"调用glib库出现0xc000007b解决办法","date":"2019-04-18T14:47:29.000Z","updated":"2019-05-18T01:22:38.363Z","comments":true,"path":"2019/04/18/调用glib库出现0xc000007b解决办法/","link":"","permalink":"https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/","excerpt":"","text":"背景 之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示： 网上的解决办法都试过，没能解决问题。 出现转机 出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。 开始分析 我使用depends分析libglib-2.0.dll，结果如下图所示从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。1、网上下载libintl-8.dll2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下 问题解决 上述步骤完成之后，再次使用depends检查，如下图所示：程序也正常运行 注意 我这里只是说明解决问题的方法，图中dll版本问题自行忽略","categories":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/categories/GLib/"}],"tags":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/tags/GLib/"}]},{"title":"安装vCenter Server出现1603错误的一种解决方法","slug":"安装vCenter-Server出现1603错误的一种解决方法","date":"2018-11-29T02:04:37.000Z","updated":"2019-05-15T14:12:39.771Z","comments":true,"path":"2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/","link":"","permalink":"https://weeweetan.github.io/2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/","excerpt":"","text":"背景 vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配置，导致vCenter Server相关服务无法启动，查找解决方法无果后，就打算重装vCenter Server。 遇到的问题 部署过程主要参考VMware Vsphere 6.0安装部署 （三） vCenter Server安装。在这里我主要说明一下我所遇到的问题以及解决方法。在安装过程中遇到Encountered an internal error，Install-parameter rhttpproxy.ext.port1 not set具体错误信息如下图所示： 出现这个错误后，会退出安装，在最后会报‘安装组件VCSServiceManager失败并显示错误代码1603’，如下图所示：出现这个错误，首先应当排查在安装vCenter Server 过程中配置的http端口是否被占用(使用命令netstat -nao)，如果端口没有被占用，则使用如下方法： 删除C:\\Program Files\\VMware\\vCenter Server目录； 重启虚拟机，重新安装 总结 这个方法不一定能解决所有这类问题，这只是其中一种解决方法。","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"VMware虚拟机备份与恢复","slug":"VMware虚拟机备份与恢复","date":"2018-10-31T08:05:03.000Z","updated":"2019-05-26T08:49:27.516Z","comments":true,"path":"2018/10/31/VMware虚拟机备份与恢复/","link":"","permalink":"https://weeweetan.github.io/2018/10/31/VMware虚拟机备份与恢复/","excerpt":"","text":"前言 本文主要是根据自己实际项目经验对云与备份之（1）：VMware虚机备份和恢复这篇文章进行补充说明。本文将以部分引用，部分说明的方式进行组织，加粗部分为我自己总结的内容。原文中提到两套SDK（vddk跟Web service SDK），整个虚拟机备份流程需要着两套SDK配合使用，我把这两套SDK整理了一下，使之能够在clion跟idea中运行，地址如下：VMwareProjectvix_disklib_sample 1. 与备份有关的VMWare基础知识1.1 VMware 虚机磁盘在 ESXi 宿主机上的文件简单来说，虚机的每个虚拟磁盘由ESXi 宿主机上的三个文件组成（这里的虚机名字是 sammy-target-win-small，下面是其第一个磁盘对应的三个文件）： sammy-target-win-small.vmdk （配置文件，大小 633 字节） sammy-target-win-small-flat.vmdk （二进制文件，大小 12884901888 字节） sammy-target-win-small-ctk.vmdk （二进制文件，大小 78694 字节）其中， 第一个文件保存的是该磁盘的元数据，其中包括另外两个文件的信息 # Extent description RW 25165824 VMFS &quot;sammy-target-win-small-flat.vmdk&quot; # Change Tracking File changeTrackPath=&quot;sammy-target-win-small-ctk.vmdk&quot; 第二个文件是 Extent description 文件，二进制数据保存在这个文件中。下面会介绍使用API获取该文件中数据的方法。第三个文件是 CTK 文件。下面讲到 CTK 的时候再说。 @刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html) 1.2 虚拟磁盘类型 上一节中的磁盘组织形式并不是唯一的，早期版本的Esxi不是以这种方式组织。vddk文档中定义了8种磁盘类型，在创建虚拟磁盘时，使用不同磁盘类型，则虚拟磁盘的组织方式不同。8中磁盘类型如下： VIXDISKLIB_DISK_MONOLITHIC_SPARSE – Growable virtual disk contained in a single virtual disk file. This is the default type for hosted disk, and the only setting in the Virtual Disk API Sample Code sample program. VIXDISKLIB_DISK_MONOLITHIC_FLAT – Preallocated virtual disk contained in a single virtual disk file. This takes time to create and occupies a lot of space, but might perform better than sparse. VIXDISKLIB_DISK_SPLIT_SPARSE – Growable virtual disk split into 2GB extents ( s sequence). These files can to 2GB, then continue growing in a new extent. This type works on older file systems. VIXDISKLIB_DISK_SPLIT_FLAT – Preallocated virtual disk split into 2GB extents ( f sequence). These files start at 2GB, so they take a while to create, but available space can grow in 2GB increments. VIXDISKLIB_DISK_VMFS_FLAT – Preallocated virtual disk compatible with ESX 3 and later. Also known as thick disk. This managed disk type is discussed in Managed Disk and Hosted Disk. VIXDISKLIB_DISK_VMFS_SPARSE – Employs a copy-on-write (COW) mechanism to save storage space. VIXDISKLIB_DISK_VMFS_THIN – Growable virtual disk that consumes only as much space as needed, compatible with ESX 3 or later, supported by VDDK 1.1 or later, and highly recommended. VIXDISKLIB_DISK_STREAM_OPTIMIZED – Monolithic sparse format compressed for streaming. Stream optimized format does not support random reads or writes.只有vddk使用VIXDISKLIB_DISK_VMFS_FLAT类型创建虚拟磁盘时才会生成1.1节中所示的虚拟磁盘文件，使用Web Service SDK创建虚拟磁盘则不受此限制。 1.3 虚拟磁盘模式 虚拟磁盘模式分为持久跟非持久，以下为vddk中对持久的定义 持久模式(persistent)：In persistent disk mode, changes are immediately and permanently written to the virtual disk, so that they survive even through to the next power on. 非持久模式(nonpersistent)：In nonpersistent mode, changes to the virtual disk are discarded when the virtual machine powers off. The VMDK files revert to their original state. 使用vSphere client创建虚拟磁盘跟vddk的选项可能会有区别 独立持久：持久模式磁盘的行为与物理机上常规磁盘的行为相似。写入持久模式磁盘的所有数据都会永久性地写入磁盘。 独立非持久：关闭虚拟机电源或重置虚拟机时，对非持久模式磁盘的更改将丢失。使用非持久模式，您可以每次使用相同的虚拟磁盘状态重新启动虚拟机。对磁盘的更改会写入重做日志文件并从中读取，重做日志文件会在关闭虚拟机电源或重置虚拟机时被删除。 1.4 vCenter Server vCenter Server相当于一套管理多台Esxi服务器的系统，如果需要对虚拟机进行备份，则需要部署这么一套系统，具体怎么部署可以参考VMware Vsphere 6.0安装部署 （三） vCenter Server安装。备份所使用的Web serviceSDK依赖这套系统，对于这套系统的使用可以参考我其他关于vSphere的文章。 2. 备份要点 原文中对备份流程进行了详细说明，我这里就不再赘述，我将从以下几个方面说明备份要点。其中具体代码实现可以去我的csdn查看相关文章 2.1 如何确定虚拟机对象？ 这个时候就需要使用Web service SDK去遍历vCenter Server中的虚拟机对象，并返回虚拟机的名称和在vCenter中的id，有了这两个变量，就可以确定虚拟机对象了。 2.2 如何获取虚拟机相关配置？ 这一步中最重要的是拿到虚拟机磁盘对象，对虚拟机的备份，实际上是对虚拟磁盘的备份，这里还是使用Web ServiceSDk进行获取 2.3 如何获取变化数据？ 原文中有提到一个API：QueryChangedDiskAreas获取 CBT 变化块的函数的定义为：QueryChangedDiskAreas(snapshot, deviceKey, startOffSet, changeID)。其中， snapshot 代表当前的快照，也就是“变化”时间段的后端点； deviceKey 是目标虚拟磁盘的 device ID； startOffSet 是开始获取变化块的offset； changeID 是指“变化”时间段的前端点，即老的快照的 changeID。其结果类似 “(117768192, 65536),(132120576, 65536),(145096704, 43122688),(265289728, 65536),(958398464, 65536)”，每项的格式为 （offset，length），表示一个发生变化的数据块。 @刘世民 [云与备份之（1）：VMware虚机备份和恢复](http://www.cnblogs.com/sammyliu/p/5661085.html)使用QueryChangedDiskAreas获取到变化数据后，需要将这些数据保存下来，以供后续使用。 2.4 如何下载变化数据？ 这个时候就需要vddk，vddk可以连接到远程的虚拟磁盘，并根据上一节保存的数据，将虚拟磁盘中的变化数据读取并保存下来，以供恢复使用。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"Java与PHP之间的Socket通信","slug":"Java与PHP之间的Socket通信","date":"2018-08-08T15:55:23.000Z","updated":"2019-05-15T14:02:48.463Z","comments":true,"path":"2018/08/08/Java与PHP之间的Socket通信/","link":"","permalink":"https://weeweetan.github.io/2018/08/08/Java与PHP之间的Socket通信/","excerpt":"","text":"Java作为服务端 Java端作为服务端，PHP端作为客户端，在之前一篇文章中说了下PHP作为客户端如何与Java端进行通信。由于业务需要，socket必须等待服务端处理完成，并返回处理结果给PHP端。在这里主要说明一下Java端如何处理的，不足之处，望指正。 ServerSocket serverSocket = new ServerSocket(port); //创建绑定到特定端口的服务器套接字 Socket socket = serverSocket.accept(); //侦听并接受到此套接字的连接 InputStream inputStream = socket.getInputStream(); StringBuilder sb = new StringBuilder(); byte[] packetLength = new byte[4]; inputStream.read(packetLength, 0, 4); //首先从套接字中读取4字节的数据长度 int target = byteToint(packetLength); //这里将字节数组转换成整数 System.out.println(&quot;message size:&quot; + target); byte[] bytes = new byte[target]; inputStream.read(bytes); //读取指定长度的数据 sb.append(new String(bytes, 0, target, &quot;UTF-8&quot;)); System.out.println(&quot;get message &quot; + sb); String result = &quot;has receive message&quot;; OutputStream outputStream = socket.getOutputStream(); int responseLength = result.getBytes().length; //这个地方的长度，一定要是字节数组的长度，否则如果字符串中包含中文，接收端接收数据会不完整 byte[] targets = intTobyte(responseLength); outputStream.write(targets); //首先发送4个字节的数据大小 outputStream.write(result.getBytes()); //再发送真正的数据 outputStream.flush(); outputStream.close(); inputStream.close(); socket.close(); 上述代码需要处异常，而且代码中的byteToint和intTobyte这两个函数非原创，是其他博主的劳动成果，感谢这位作者，原文地址https://www.cnblogs.com/langren1992/p/4717241.html。 PHP作为服务端 相关函数: socket_create、socket_set_block、socket_bind、socket_listen、socket_accept、socket_read、socket_write，这些函数具体参数说明在PHP文档上写很详细，这里就不再赘述，这里只是介绍服务端如何处理请求。 //确保在连接客户端时不会超时 set_time_limit(0); //设置IP和端口号 $address = &quot;127.0.0.1&quot;; $port = 54321; $socketServer = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(&quot;socket_create() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); //设置为阻塞模式 socket_set_block($socketServer) or die(&quot;socket_set_block() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); //绑定端口 $result = socket_bind($socketServer, $address, $port) or die(&quot;socket_bind() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); //开始监听 $result = socket_listen($socketServer, 4) or die(&quot;socket_listen() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); do { //接收连接请求并返回一个子Socket来处理客户端和服务器间的信息 $sock = socket_accept($socketServer) or die(&quot;socket_accept() failed: reason: &quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); while($sock){ //读取客户端数据 echo &quot;Read client data \\n&quot;; $length = socket_read($sock, 4); $length = unpack(&apos;i&apos;, $length); echo &quot;length:$length[1] \\n&quot;; $request = socket_read($sock, $length[1]); echo &quot;$request:$request \\n&quot;; //数据传送 向客户端写入返回结果 $msg = &quot;this is response message \\n&quot;; $msgLength = strlen($msg); $msgLength = pack(&apos;i&apos;, $msgLength); socket_write($sock, $msgLength); socket_write($sock, $msg, strlen($msg)) or die(&quot;socket_write() failed: reason: &quot; . socket_strerror(socket_last_error()) .&quot;/n&quot;); break; } } while (true); //根据需要关闭socket socket_close($socketServer); 在接收到客户端的请求后，可以结合PHP的多线程进行处理，这里只是简单的返回字符串。 总结 各大语言实现socket通信的方式都是大同小异，在服务端的流程都是差不多的。在有现成高性能socket通信框架的情况下，建议不要自己去实现，但是得理解框架底层是怎样实现的。","categories":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/categories/Socket/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/tags/Socket/"},{"name":"Java","slug":"Java","permalink":"https://weeweetan.github.io/tags/Java/"}]},{"title":"VMware vSphere WebService SDK使用心得","slug":"VMware-vSphere-WebService-SDK使用心得","date":"2018-07-25T12:13:58.000Z","updated":"2019-05-15T13:27:59.170Z","comments":true,"path":"2018/07/25/VMware-vSphere-WebService-SDK使用心得/","link":"","permalink":"https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK使用心得/","excerpt":"","text":"善用mob（Managed Object Browser） mob地址一般是https://vcenter的FQDN/mob，mob可以让你更好的理解SDK中的那些例子，以及根据自己的业务逻辑改写一些功能。下图为mob首页图，图中的content为整个Managed Object的顶层，从这里进去可以找到整个vcenter server中所有对象及其属性。 善用GetMOREF类 GetMOREF类具体位置在VMware-vSphere-SDK-6.0.0-2561048\\SDK\\vsphere-ws\\java\\JAXWS\\samples\\com\\vmware\\connection\\helpers，这是VMware官方提供的一个工具类，里面的每个函数对于开发都很有用。例如 ​List&lt;VirtualDevice&gt; listvd = ((ArrayOfVirtualDevice) getMOREFs .entityProps(vmMor, new String[] { &quot;config.hardware.device&quot; }) .get(&quot;config.hardware.device&quot;)).getVirtualDevice(); 这是VMReconfig.java中的一个片段，这段代码的作用就是去获取指定虚拟机对象的所有设备，vmMor可以通过GetMOREF类中的vmByVMname函数去获得。至于config.hardware.device，就需要用mob一层一层点进去看了，相信结合mob就能理解为什么要这么写。 ​​ ManagedObjectReference propCol = connection.getServiceContent().getPropertyCollector(); ManagedObjectReference vmRef = getMOREFs.vmByVMname(virtualMachineName,propCol); 上面这段代码的作用就是如何根据虚拟机名去获取其对应的ManagedObjectReference 善用SDK里面的文档 文档首页为VMware-vSphere-SDK-6.0.0-2561048/SDK/vsphere-ws/docs/ReferenceGuide/index.html根据需求，在左侧导航栏对应的去找。 对SDK我整理了一下，使其能够在idea中编译运行，项目地址在VMwareProject ​","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"Socket粘包处理","slug":"Socket粘包处理","date":"2018-07-25T11:05:52.000Z","updated":"2019-05-15T13:53:21.823Z","comments":true,"path":"2018/07/25/Socket粘包处理/","link":"","permalink":"https://weeweetan.github.io/2018/07/25/Socket粘包处理/","excerpt":"","text":"背景 这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据，并等待Java的响应结果，数据格式为JSON。 遇到的问题 PHP端发送数据后，Java端从socket里读取数据，但是一直读不到结束符。 原因 PHP需要调用socket_close函数才会向socket里面写入结束符。 改进方法 PHP端与Java端之间确定每次发送数据包的长度，用4个字节表示数据长度，PHP端先发送数据包长度，再发送数据包，Java端先接收4个字节长度的数据包长度，再根据数据包长度接收数据包。PHP端代码如下: ​ $socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP ) or die ( &apos;could not create socket&apos; ); $connect = socket_connect ( $socket, &apos;xxx.xxx.xxx.xxx&apos;, xxxx); //服务端发送数据 $arr = array(&quot;data&quot; =&gt; &quot;dadadada&quot;); $strlen = pack(&apos;i&apos;, strlen(json_encode($arr))); var_dump($strlen); socket_write ($socket, $strlen); socket_write ($socket, json_encode($arr), strlen(json_encode($arr))); $response = socket_read($socket, 4); $res = unpack(&apos;i&apos;, $response); var_dump($res); $response = socket_read($socket, $res[1]); var_dump($response); socket_close($socket); pack与unpack函数使用说明见PHP官方文档 ​","categories":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/categories/Socket/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/tags/Socket/"}]},{"title":"使用gcc编译驱动模块遇到的问题","slug":"使用gcc编译驱动模块遇到的问题","date":"2017-05-22T09:30:33.000Z","updated":"2019-05-17T15:43:16.624Z","comments":true,"path":"2017/05/22/使用gcc编译驱动模块遇到的问题/","link":"","permalink":"https://weeweetan.github.io/2017/05/22/使用gcc编译驱动模块遇到的问题/","excerpt":"","text":"背景 由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客写一个块设备驱动学习，练习环境为centos6.5 gcc版本为6.3。 遇到的问题 跟着敲完那个简单的驱动程序后，发现编译出错，错误信息为 include/linux/compiler-gcc.h:89:30: fatal error: linux/compiler-gcc6.h: No such file or directory 一通百度，说gcc版本太高，去下载一个compiler-gcc6.h文件，放到内核源码文件夹里面，按着做了，结果编译又出问题了，错误信息为 include/linux/compiler.h:163:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void data_access_exceeds_word_size(void) include/linux/compiler.h:169:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void data_access_exceeds_word_size(void) include/linux/compiler.h:173:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void __read_once_size(volatile void *p, void *res, int size) include/linux/compiler.h:190:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void __write_once_size(volatile void *p, void *res, int size) 解决方法 又是一通百度，发现跟我情况不符，看了下博客发表时间，08年，果断换了一个centos6.0的机器，gcc版本为4.6，编译完美通过,环境因素很重要啊。。。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/categories/Linux/"}],"tags":[{"name":"驱动模块","slug":"驱动模块","permalink":"https://weeweetan.github.io/tags/驱动模块/"},{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/tags/Linux/"}]},{"title":"PHP脚本中使用exec总结","slug":"PHP脚本中使用exec总结","date":"2017-02-20T01:03:11.000Z","updated":"2019-05-17T15:54:50.468Z","comments":true,"path":"2017/02/20/PHP脚本中使用exec总结/","link":"","permalink":"https://weeweetan.github.io/2017/02/20/PHP脚本中使用exec总结/","excerpt":"","text":"背景 总结一下这两天加班遇到的坑，由于本次任务涉及到在PHP中使用exec函数运行shell命令，并解析返回值。屁颠屁颠的写好代码，上传到服务器，服务器环境配置centos6.5+Nginx，ssh到服务器，在控制台运行php xxx.php结果完美显示。蛋疼的是前端调用脚本的时候，没有数据，返回false，一脸懵逼，开始想问题所在，试着在浏览器地址栏直接访问xxx.php没有结果。然后把代码改成 exec(&quot;ls 2&gt;&amp;1&quot;, $result); var_dump($result); 显示ls命令没找到，试着加上路径 exec(&quot;/bin/ls 2&gt;&amp;1&quot;, $result); var_dump($result); 显示权限不够。 解决方法 lsof -i:80 查看你Nginx的用户是谁，我这里是nginx 在脚本中添加file_put_contents(“/tmp/test.log”, “xxx”)查看test.log的用户是谁。我这里是nobody 在vim /etc/sudoers添加权限 nobody ALL=(ALL) NOPASSWD:ALL nginx ALL=(ALL) NOPASSWD:ALL 重启nginx服务。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"}]},{"title":"Esxi5.1挂载NFS存储遇到的问题及解决办法","slug":"Esxi5-1挂载NFS存储遇到的问题及解决办法","date":"2017-01-13T01:18:44.000Z","updated":"2019-05-18T01:20:29.052Z","comments":true,"path":"2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/","link":"","permalink":"https://weeweetan.github.io/2017/01/13/Esxi5-1挂载NFS存储遇到的问题及解决办法/","excerpt":"","text":"背景 如何配置NFS以及怎样在Esxi中添加NFS，可以参考VMware ESXI 5.5使用NFS添加存储器, 我也是按照这个博客来配置的。 遇到的问题 遇到如下问题： 解决方法 必须要检查你的esxi主机是否配置了VMkernel，检查步骤如下：1、使用 VI/vSphere Client 连接到 Virtual Center/vCenter Server。2、选择 ESX/ESXi 主机。3、单击配置选项卡。4、单击网络。5、查看 VMKernel 的网络图，或单击属性 &gt; 端口 &gt; VMKernel。如果 VMKernel 未列出，必须添加它。 手动挂载 手动挂载命令： esxcli storage nfs add -H NFS_IP|NFS_HOSTNAME -s Share_mount_point_on_the_NFS -v DatastoreName 注意事项 必须保证esxi主机与NFS服务器在同一网段或者能够相互通信","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"linux下编译vddk例程的错误总结","slug":"linux下编译vddk例程的错误总结","date":"2016-11-10T09:29:27.000Z","updated":"2019-05-18T02:28:46.640Z","comments":true,"path":"2016/11/10/linux下编译vddk例程的错误总结/","link":"","permalink":"https://weeweetan.github.io/2016/11/10/linux下编译vddk例程的错误总结/","excerpt":"","text":"背景 vddk是visual disk development kit的缩写，是VMware vSphere提供的可用来操作虚拟磁盘的一套SDK，具体可看VDDK Document，在这里记录一下编译问题。 遇到的问题 按照官方文档编译vixDiskLibSample.cpp时报错 Package vix-disklib was not found in the pkg-config search path. Perhaps you should add the directory containing `vix-disklib.pc&apos; to the PKG_CONFIG_PATH environment variable No package &apos;vix-disklib&apos; found 解决方法 按照官方文档的说明编辑~/.bash_profile,添加如下内容： PKG_CONFIG_PATH=/usr/lib/pkgconfig export PKG_CONFIG_PATH LD_LIBRARY_PATH=/usr/lib/vmware-vix-disklib/lib64 export LD_LIBRARY_PATH 其中/usr/lib/vmware-vix-disklib/lib64是vddk安装后，默认的lib路径，添加完成后执行 source bash_profile 再次编译就成功了","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"},{"name":"vddk","slug":"vddk","permalink":"https://weeweetan.github.io/tags/vddk/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2016-08-05T13:58:21.000Z","updated":"2019-05-25T14:46:47.500Z","comments":true,"path":"2016/08/05/Linux常用命令/","link":"","permalink":"https://weeweetan.github.io/2016/08/05/Linux常用命令/","excerpt":"","text":"vim 1、使用u退回上一步2、使用U一次撤销对当前行的全部操作3、vim + filename 表示把光标定位到文件最后一行4、vim +数字 filemame 定位到数字行，如果超过文件行数，定位到最后一行5、vim +/word filename 定位到Word第一次出现的行，按n切换6、vim file1 file2 file3 一次性打开或者创建多个文件，底行模式下使用:n向后切换文件，:N和prev向前切换文件7、:w save:q quit:! 强制:ls 列出当前编辑器打开的所有文件:n 切换到下一个文件:N 切换到前一个文件:15 定位到15行:/xxx 表示从光标位置向后搜索xxx,定位到第一次出现的时候:?xxx搜索8、命令行模式常用命令h 光标左移j 光标下移k 光标上移l 光标右移Ctrl+f 向下翻页（front）Ctrl+b 向上翻页（back）Ctrl+d 向下翻半页（down）Ctrl+u 向上翻半页（up） df 查看磁盘分区使用状况 -l 仅显示本地磁盘（默认） -a 显示所有文件系统的磁盘使用情况 -h 以1024进制计算最适合的单位显示磁盘容量 -H 以1000进制计算最适合的单位显示磁盘容量 -T 显示磁盘分区类型 -t 显示指定类型文件系统的磁盘分区 -x 不显示指定类型文件系统的磁盘分区 du 统计磁盘上的文件大小 -b 以byte为单位统计文件 -k 以KB为单位统计文件 -m 以MB为单位统计文件 -h 按照1024进制以最适合的单位统计文件 -H 按照1000进制以最适合的单位统计文件 -s 指定统计目标 lsof 可以列出被进程所打开的文件的信息。被打开的文件可以是1.普通的文件2.目录3.网络文件系统的文件4.字符设备文件5.(函数)共享库6.管道，命名管道7.符号链接8.底层的socket字流，网络socket，unix域名socket9.在linux里面，大部分的东西都是被当做文件的…..还有其他很多 怎样使用lsof 这里主要用案例的形式来介绍lsof 命令的使用 列出所有打开的文件:lsof备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位 查看谁正在使用某个文件lsof /filepath/file 递归查看某个目录的文件信息lsof +D /filepath/filepath2/备注: 使用了+D，对应目录下的所有子目录和文件都会被列出 比使用+D选项，遍历查看某个目录的所有文件信息 的方法lsof | grep ‘/filepath/filepath2/’ 列出某个用户打开的文件信息lsof -u username备注: -u 选项，u其实是user的缩写 列出某个程序所打开的文件信息lsof -c mysql备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成lsof | grep mysql,但是第一种方法明显比第二种方法要少打几个字符了 列出多个程序多打开的文件信息lsof -c mysql -c apache 列出某个用户以及某个程序所打开的文件信息lsof -u test -c mysql 列出除了某个用户外的被打开的文件信息lsof -u ^root备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示 通过某个进程号显示该进行打开的文件lsof -p 1 列出多个进程号对应的文件信息lsof -p 123,456,789 列出除了某个进程号，其他进程号所打开的文件信息lsof -p ^113 . 列出所有的网络连接lsof -i 列出所有tcp 网络连接信息lsof -i tcp 列出所有udp网络连接信息lsof -i udp 列出谁在使用某个端口lsof -i :3306 列出谁在使用某个特定的udp端口lsof -i udp:55特定的tcp端口lsof -i tcp:80 列出某个用户的所有活跃的网络端口lsof -a -u test -i 列出所有网络文件系统lsof -N 域名socket文件lsof -u 某个用户组所打开的文件信息lsof -g 5555 根据文件描述列出对应的文件信息lsof -d description(like 2) 根据文件描述范围列出文件信息lsof -d 2-3 top系列iotop – I/O 监控 iotop 命令利用 Linux 内核监控 I/O 使用情况，它按进程或线程的顺序显示 I/O 使用情况。 htop – 交互式的进程查看器 htop 是一款免费并开源的基于 ncurses 的 Linux 进程查看器。它比 top 命令更简单易用。您无需使用 PID、无需离开 htop 界面，便可以杀掉进程或调整其调度优先级。 atop – 高级版系统与进程监控工具 atop 是一个非常强大的交互式 Linux 系统负载监控器，它从性能的角度显示最关键的硬件资源信息。您可以快速查看 CPU、内存、磁盘和网络性能。它还可以从进程的级别显示哪些进程造成了相关 CPU 和内存的负载。 iftop – 显示主机上网络接口的带宽使用情况 iftop 命令监听指定接口（如 eth0）上的网络通信情况。它显示了一对主机的带宽使用情况。 vmstat 虚拟内存统计显示 Slab 缓存的利用率 vmstat -m 获取有关活动和非活动内存页面的信息 vmstat -a grep高亮搜索关键字 step1:修改~/.bashrc，在~/.bashrc中添加如下内容alias grep=’grep –color=auto’step2:重新加载.bashrc文件source ~/.bashrc netstat -a ：all，表示列出所有的连接，服务监听，Socket资料-t ：tcp，列出tcp协议的服务-u ：udp，列出udp协议的服务-n ：port number， 用端口号来显示-l ：listening，列出当前监听服务-p ：program，列出服务程序的PID ps 显示长输出格式 # ps -Al 显示完整输出格式（它将显示传递给进程的命令行参数） # ps -AlF 显示线程（轻量级进程（LWP）和线程的数量（NLWP）） # ps -AlFH 在进程后显示线程 # ps -AlLm 显示系统上所有的进程 # ps ax # ps aux 显示进程树 # ps -ejH # ps axjf # pstree 显示进程的安全信息 # ps -eo euser,ruser,suser,fuser,f,comm,label # ps axZ # ps -eM 显示指定用户（如 vivek）运行的进程 # ps -U vivek -u vivek u 设置用户自定义的输出格式 # ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm # ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm # ps -eopid,tt,user,fname,tmout,f,wchan 显示某进程（如 lighttpd）的 PID # ps -C lighttpd -o pid= 或 # pgrep lighttpd 或 # pgrep -u vivek php-cgi 显示指定 PID（如 55977）的进程名称 # ps -p 55977 -o comm= 找出占用内存资源最多的前 10 个进程 # ps -auxf | sort -nr -k 4 | head -10 找出占用 CPU 资源最多的前 10 个进程 # ps -auxf | sort -nr -k 3 | head -10 ##ss ss 命令用于获取套接字统计信息。它可以显示类似于 netstat 的信息。不过 netstat 几乎要过时了，ss 命令更具优势。要显示所有 TCP 或 UDP 套接字： # ss -t -a 或 # ss -u -a 显示所有带有 SELinux 安全上下文Security Context的 TCP 套接字： # ss -t -a -Z pmap pmap 命令用以显示进程的内存映射，使用此命令可以查找内存瓶颈。 # pmap -d PID 显示 PID 为 47394 的进程的内存信息，请输入： # pmap -d 47394 sar ?sar 命令用于收集、汇报和保存系统活动信息。要查看网络统计，请输入： # sar -n DEV | more 显示 24 日的网络统计： # sar -n DEV -f /var/log/sa/sa24 | more 显示实时使用情况： # sar 4 5 mpstat mpstat 命令显示每个可用处理器的使用情况，编号从 0 开始。命令 mpstat -P ALL 显示了每个处理器的平均使用率： # mpstat -P ALL w 显示了当前登录在该系统上的用户及其进程。 # w username tcpdump tcpdump 命令是简单的分析网络通信的命令。您需要充分了解 TCP/IP 协议才便于使用此工具。例如，要显示有关 DNS 的流量信息，请输入： # tcpdump -i eth1 &apos;udp port 53&apos; 查看所有去往和来自端口 80 的 IPv4 HTTP 数据包，仅打印真正包含数据的包，而不是像 SYN、FIN 和仅含 ACK 这类的数据包，请输入： # tcpdump &apos;tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&apos; 显示所有目标地址为 202.54.1.5 的 FTP 会话，请输入： # tcpdump -i eth1 &apos;dst 202.54.1.5 and (port 21 or 20&apos; 打印所有目标地址为 192.168.1.5 的 HTTP 会话： # tcpdump -ni eth0 &apos;dst 192.168.1.5 and tcp and port http&apos; 使用 wireshark 查看文件的详细内容，请输入： # tcpdump -n -i eth1 -s 0 -w output.txt src or dst port 80 lsb_release lsb_release是读取/etc/redhat-release文件中的第一行记录，这里面记载了系统版本 ! !在Linux命令行中有特色含义，即感叹号后面的内容会被截断，所以如果需要将感叹号当作普通字符处理，需要使用单引号，如下： echo &quot;hello world&apos;!&apos;&quot; fdisk fdisk只能给磁盘做MBR分区，MBR只能有四个主分区，每个分区最大2TB parted parted既可以做MBR分区也可以做GPT分区，GPT几乎没有分区限制，也没有大小限制","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/tags/Linux/"}]},{"title":"centos6.5下lamp环境部署laravel","slug":"centos6-5下lamp环境部署laravel","date":"2016-07-31T13:54:35.000Z","updated":"2019-05-18T13:56:16.929Z","comments":true,"path":"2016/07/31/centos6-5下lamp环境部署laravel/","link":"","permalink":"https://weeweetan.github.io/2016/07/31/centos6-5下lamp环境部署laravel/","excerpt":"","text":"安装composer，命令如下curl -sS https://getcomposer.org/installer | php mv composer.phar /usr/local/bin/composer chmod +x /usr/local/bin/composer 切换到Apache默认目录下cd /var/www/ composer create-project laravel/laravel --prefer-dist &quot;5.1.11&quot; composer install 修改权限cd laravel chmod -R 777 storage/ 修改配置vim/etc/httpd/conf/httpd.conf 把DocumentRoot “/var/www/html”改为DocumentRoot “/var/www/laravel/public” 重启Apache服务service httpd restart","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"https://weeweetan.github.io/tags/Laravel/"}]},{"title":"MySQL常见问题","slug":"MySQL常见问题","date":"2016-05-22T05:55:31.000Z","updated":"2019-05-25T15:38:28.194Z","comments":true,"path":"2016/05/22/MySQL常见问题/","link":"","permalink":"https://weeweetan.github.io/2016/05/22/MySQL常见问题/","excerpt":"","text":"修改目录后MySQL无法启动 这种问题一般是selinux造成的1、终端输入sestatus，如出现SELinux status: enabled，则selinux为开启状态，2、编辑/etc/selinux/config 文件，将SELINUX=enforcing改为SELINUX=disabled，重启机器 修改密码 修改密码分为两种情况，一种情况是拥有原来密码，另外一种情况则是忘记密码 拥有原来的myql的root的密码；方法一： 在mysql系统外，使用mysqladmin # mysqladmin -u root -p password &quot;test123&quot; Enter password: 【输入原来的密码】 方法二： 通过登录mysql系统， # mysql -uroot -p Enter password: 【输入原来的密码】 mysql&gt;use mysql; mysql&gt; update user set password=password(&quot;test&quot;) where user=&apos;root&apos;; mysql&gt; flush privileges; mysql&gt; exit; 忘记原来的myql的root的密码； 首先，你必须要有操作系统的root权限了。要是连系统的root权限都没有的话，先考虑root系统再走下面的步骤。类似于安全模式登录系统，有人建议说是pkill mysql，但是我不建议哈。因为当你执行了这个命令后，会导致这样的状况：/etc/init.d/mysqld statusmysqld dead but subsys locked这样即使你是在安全模式下启动mysql都未必会有用的，所以一般是这样/etc/init.d/mysqld stop，如果你不幸先用了pkill，那么就start一下再stop咯。 # mysqld_safe --skip-grant-tables &amp; &amp;，表示在后台运行，不再后台运行的话，就再打开一个终端咯。 # mysql mysql&gt; use mysql; mysql&gt; UPDATE user SET password=password(&quot;test123&quot;) WHERE user=&apos;root&apos;; mysql&gt; flush privileges; mysql&gt; exit; 本来mysql是不分大小写的，但是这个是修改的mysql中的mysql数据库的具体的值，要注意到。 插入10万条记录的SQLdrop table if exists foo; create table foo ( id int unsigned not null auto_increment primary key, val smallint unsigned not null default 0 ) engine=innodb; drop procedure if exists load_foo_test_data; delimiter # create procedure load_foo_test_data() begin declare v_max int unsigned default 100000; declare v_counter int unsigned default 0; truncate table foo; start transaction; while v_counter &lt; v_max do insert into foo (val) values ( floor(0 + (rand() * 65535)) ); set v_counter=v_counter+1; end while; commit; end # delimiter ; call load_foo_test_data(); MySQL开启远程访问 选择mysql库，选user表 新增用户 mysql&gt; insert into user(Host,User,Password) values(&apos;%&apos;,&apos;用户名（必须是英文数字）&apos;,&apos;密码&apos;); 刷新权限 mysql&gt;flush privileges; 授权给新增的用户 mysql&gt; Grant all privileges on *.* to &apos;用户名&apos;@&apos;%&apos; identified by &apos;密码&apos; with grant option; 注释：其中：“ . ”代表所有数据库和表（也就是root权限） 其格式为:数据库名称 . 表名刷新权限 mysql&gt;flush privileges; 数据库优化十个原则 尽量避免在列上进行计算，这样会导致索引失效 select * from t where year(d)&gt;=2011 =&gt; select * from t where d&gt;=&apos;2011-01-01&apos;; 使用join时，应该用小结果集驱动大结果集。同时把复杂的join查询拆分成多个query。因为join多个表时，可能导致更多的锁定和堵塞。 注意like模糊查询的使用，避免%%。 仅列出需要查询的字段，这对速度不会又明显的影响，主要考虑节省内存。 使用批量插入语句节省交互。 limit的基数比较大时使用between。 不要使用rand函数获取多条随机记录。 避免使用null 不要使用count(id),而应该是count(*) 不要做所谓的排序操作，而应尽可能在索引中完成排序。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://weeweetan.github.io/tags/MySQL/"}]}]}