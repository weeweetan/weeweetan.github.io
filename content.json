{"meta":{"title":"weeweetan's blog","subtitle":null,"description":null,"author":"weeweetan","url":"https://weeweetan.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-04-30T06:58:00.000Z","updated":"2019-05-15T06:20:17.816Z","comments":true,"path":"about/index.html","permalink":"https://weeweetan.github.io/about/index.html","excerpt":"","text":"尝试过的技术 VMware虚拟机备份与恢复 数据库备份与恢复 基于卷的持续数据保护 Linux块设备驱动 Linux C编程 ThinkPHP框架 Laravel框架 Java SE 目前正在研究的技术 Nginx CDN"},{"title":"书单","date":"2019-05-15T04:37:44.496Z","updated":"2019-05-15T04:37:44.496Z","comments":false,"path":"books/index.html","permalink":"https://weeweetan.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-05-15T04:37:44.497Z","updated":"2019-05-15T04:37:44.497Z","comments":false,"path":"categories/index.html","permalink":"https://weeweetan.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-05-15T04:37:44.497Z","updated":"2019-05-15T04:37:44.497Z","comments":true,"path":"links/index.html","permalink":"https://weeweetan.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-05-15T04:37:44.498Z","updated":"2019-05-15T04:37:44.498Z","comments":false,"path":"repository/index.html","permalink":"https://weeweetan.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-15T06:47:15.597Z","updated":"2019-05-15T04:37:44.499Z","comments":false,"path":"tags/index.html","permalink":"https://weeweetan.github.io/tags/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2019-05-15T01:36:14.000Z","updated":"2019-05-15T01:42:30.056Z","comments":true,"path":"resume/index.html","permalink":"https://weeweetan.github.io/resume/index.html","excerpt":"","text":""}],"posts":[{"title":"C语言编程常见错误","slug":"C语言编程常见错误","date":"2019-05-17T15:21:03.000Z","updated":"2019-05-17T15:29:49.734Z","comments":true,"path":"2019/05/17/C语言编程常见错误/","link":"","permalink":"https://weeweetan.github.io/2019/05/17/C语言编程常见错误/","excerpt":"","text":"使用close函数出现bad file descriptor错误 出现这种错误一般是两次close导致，仔细检查代码，调用close关闭文件描述符后，应该将文件描述符置为0，避免重复调用close，切记切记。 守护程序闪退问题 出现这个问题一般是两次释放同一块内存，仔细检查释放内存与指针赋值相关代码，释放内存后，应将指针置为NULL，避免重复调用close，切记切记。","categories":[{"name":"总结","slug":"总结","permalink":"https://weeweetan.github.io/categories/总结/"}],"tags":[{"name":"C","slug":"C","permalink":"https://weeweetan.github.io/tags/C/"}]},{"title":"Nginx学习笔记","slug":"Nginx学习笔记","date":"2019-05-08T02:49:55.000Z","updated":"2019-05-15T07:06:29.000Z","comments":true,"path":"2019/05/08/Nginx学习笔记/","link":"","permalink":"https://weeweetan.github.io/2019/05/08/Nginx学习笔记/","excerpt":"","text":"编译步骤configure原理 configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。 auto脚本 auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。 源码解析 在ngx_module.h中引用了两个至关重要的外部变量 extern ngx_module_t *ngx_modules[]; extern char *ngx_module_names[]; ngx_modules跟ngx_module_names定义在ngx_modules.c中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用ngx_cycle_modules函数，原型如下： ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle) 此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下： main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules handler模块的编写步骤 编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量： static ngx_command_t ngx_http_module_name_commands[] = {}; static ngx_http_module_t ngx_http_module_name_module_ctx = {}; ngx_module_t ngx_http_module_name_module = {}; 实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数： static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)； 编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数： static ngx_int_t ngx_http_module_name_handler(ngx_http_request_t *r);","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://weeweetan.github.io/tags/Nginx/"}]},{"title":"libxml2使用心得","slug":"libxml2使用心得","date":"2019-05-04T14:21:35.000Z","updated":"2019-05-15T07:04:26.805Z","comments":true,"path":"2019/05/04/libxml2使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/05/04/libxml2使用心得/","excerpt":"","text":"背景 由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考C++的XML编程经验――LIBXML2库使用指南，这篇博文讲得很详细，我在这里只是做出一点补充。 问题 xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。 举例说明 我使用GLib2的g_locale_from_utf8将内容转换为本地程序默认的编码格式，在写入xml内容时使用g_locale_to_utf8将内容转换为UTF-8. 总结 总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。","categories":[{"name":"libxml","slug":"libxml","permalink":"https://weeweetan.github.io/categories/libxml/"}],"tags":[{"name":"libxml","slug":"libxml","permalink":"https://weeweetan.github.io/tags/libxml/"}]},{"title":"GLib使用心得","slug":"GLib使用心得","date":"2019-04-28T05:51:59.000Z","updated":"2019-05-15T07:05:34.079Z","comments":true,"path":"2019/04/28/GLib使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/04/28/GLib使用心得/","excerpt":"","text":"前言关于GLib的介绍这里就不赘述了，具体API介绍可以去GLib API Reference查阅，这里只是记录一下使用相关API所遇到的一些坑。 相关API字符串相关APIGString *g_string_new(const gchar *init); GString *g_string_append(GString *string, const gchar *val); GString *g_string_prepend(GString *string, const gchar *val); gchar *g_string_free(GString *string, gboolean free_segment); 如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。注意 g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。g_string_append跟g_string_prepend都是直接在原字符串上操作，这点要切记。 字符转换相关APIgchar *g_filename_display_basename(const gchar *filename); gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error); gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error); g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8下面看个例子, 比如我们有个含中文的文件名 /data/test/哈哈.txt如果想获得 哈哈.txt，则必须首先使用 g_locale_to_utf8函数转换一次, 然后再去获取basename GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;); gchar *str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); gchar *basename = g_filename_display_basename(str); 如果想使用GString *类型保存basename，则必须重新申请内存块 GString *basename_string = g_string_new(basename); 千万别像下面这样做 GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;); string-&gt;str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); 如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，g_locale_from_utf8 同理注意 g_locale_to_utf8返回的char *需要手动释放内存 解析key-value文件APIGKeyFile *g_key_file_new(void); gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error); gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error); gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error); void g_key_file_free(GKeyFile *key_file); 这几个API很好理解,用来解析具有键值对特征的文件,g_key_file_new跟g_key_file_free配套使用;g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;","categories":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/categories/GLib/"}],"tags":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/tags/GLib/"}]},{"title":"调用glib库出现0xc000007b解决办法","slug":"调用glib库出现0xc000007b解决办法","date":"2019-04-18T14:47:29.000Z","updated":"2019-05-15T07:05:59.833Z","comments":true,"path":"2019/04/18/调用glib库出现0xc000007b解决办法/","link":"","permalink":"https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/","excerpt":"","text":"背景之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示： 网上的解决办法都试过，没能解决问题。 出现转机出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。 开始分析我使用depends分析libglib-2.0.dll，结果如下图所示从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。1、网上下载libintl-8.dll2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下 问题解决上述步骤完成之后，再次使用depends检查，如下图所示：程序也正常运行 注意我这里只是说明解决问题的方法，图中dll版本问题自行忽略","categories":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/categories/GLib/"}],"tags":[{"name":"GLib","slug":"GLib","permalink":"https://weeweetan.github.io/tags/GLib/"}]},{"title":"安装vCenter Server出现1603错误的一种解决方法","slug":"安装vCenter-Server出现1603错误的一种解决方法","date":"2018-11-29T02:04:37.000Z","updated":"2019-05-15T14:12:39.771Z","comments":true,"path":"2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/","link":"","permalink":"https://weeweetan.github.io/2018/11/29/安装vCenter-Server出现1603错误的一种解决方法/","excerpt":"","text":"背景 vCeter Server部署在一个Windows Server 2008 R2的虚拟机上，由于更改了虚拟机网卡配置，导致vCenter Server相关服务无法启动，查找解决方法无果后，就打算重装vCenter Server。 遇到的问题 部署过程主要参考VMware Vsphere 6.0安装部署 （三） vCenter Server安装。在这里我主要说明一下我所遇到的问题以及解决方法。在安装过程中遇到Encountered an internal error，Install-parameter rhttpproxy.ext.port1 not set具体错误信息如下图所示： 出现这个错误后，会退出安装，在最后会报‘安装组件VCSServiceManager失败并显示错误代码1603’，如下图所示：出现这个错误，首先应当排查在安装vCenter Server 过程中配置的http端口是否被占用(使用命令netstat -nao)，如果端口没有被占用，则使用如下方法： 删除C:\\Program Files\\VMware\\vCenter Server目录； 重启虚拟机，重新安装 总结 这个方法不一定能解决所有这类问题，这只是其中一种解决方法。","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"Java与PHP之间的Socket通信","slug":"Java与PHP之间的Socket通信","date":"2018-08-08T15:55:23.000Z","updated":"2019-05-15T14:02:48.463Z","comments":true,"path":"2018/08/08/Java与PHP之间的Socket通信/","link":"","permalink":"https://weeweetan.github.io/2018/08/08/Java与PHP之间的Socket通信/","excerpt":"","text":"Java作为服务端 Java端作为服务端，PHP端作为客户端，在之前一篇文章中说了下PHP作为客户端如何与Java端进行通信。由于业务需要，socket必须等待服务端处理完成，并返回处理结果给PHP端。在这里主要说明一下Java端如何处理的，不足之处，望指正。 ServerSocket serverSocket = new ServerSocket(port); //创建绑定到特定端口的服务器套接字 Socket socket = serverSocket.accept(); //侦听并接受到此套接字的连接 InputStream inputStream = socket.getInputStream(); StringBuilder sb = new StringBuilder(); byte[] packetLength = new byte[4]; inputStream.read(packetLength, 0, 4); //首先从套接字中读取4字节的数据长度 int target = byteToint(packetLength); //这里将字节数组转换成整数 System.out.println(&quot;message size:&quot; + target); byte[] bytes = new byte[target]; inputStream.read(bytes); //读取指定长度的数据 sb.append(new String(bytes, 0, target, &quot;UTF-8&quot;)); System.out.println(&quot;get message &quot; + sb); String result = &quot;has receive message&quot;; OutputStream outputStream = socket.getOutputStream(); int responseLength = result.getBytes().length; //这个地方的长度，一定要是字节数组的长度，否则如果字符串中包含中文，接收端接收数据会不完整 byte[] targets = intTobyte(responseLength); outputStream.write(targets); //首先发送4个字节的数据大小 outputStream.write(result.getBytes()); //再发送真正的数据 outputStream.flush(); outputStream.close(); inputStream.close(); socket.close(); 上述代码需要处异常，而且代码中的byteToint和intTobyte这两个函数非原创，是其他博主的劳动成果，感谢这位作者，原文地址https://www.cnblogs.com/langren1992/p/4717241.html。 PHP作为服务端 相关函数: socket_create、socket_set_block、socket_bind、socket_listen、socket_accept、socket_read、socket_write，这些函数具体参数说明在PHP文档上写很详细，这里就不再赘述，这里只是介绍服务端如何处理请求。 //确保在连接客户端时不会超时 set_time_limit(0); //设置IP和端口号 $address = &quot;127.0.0.1&quot;; $port = 54321; $socketServer = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die(&quot;socket_create() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); //设置为阻塞模式 socket_set_block($socketServer) or die(&quot;socket_set_block() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); //绑定端口 $result = socket_bind($socketServer, $address, $port) or die(&quot;socket_bind() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); //开始监听 $result = socket_listen($socketServer, 4) or die(&quot;socket_listen() fail:&quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); do { //接收连接请求并返回一个子Socket来处理客户端和服务器间的信息 $sock = socket_accept($socketServer) or die(&quot;socket_accept() failed: reason: &quot; . socket_strerror(socket_last_error()) . &quot;/n&quot;); while($sock){ //读取客户端数据 echo &quot;Read client data \\n&quot;; $length = socket_read($sock, 4); $length = unpack(&apos;i&apos;, $length); echo &quot;length:$length[1] \\n&quot;; $request = socket_read($sock, $length[1]); echo &quot;$request:$request \\n&quot;; //数据传送 向客户端写入返回结果 $msg = &quot;this is response message \\n&quot;; $msgLength = strlen($msg); $msgLength = pack(&apos;i&apos;, $msgLength); socket_write($sock, $msgLength); socket_write($sock, $msg, strlen($msg)) or die(&quot;socket_write() failed: reason: &quot; . socket_strerror(socket_last_error()) .&quot;/n&quot;); break; } } while (true); //根据需要关闭socket socket_close($socketServer); 在接收到客户端的请求后，可以结合PHP的多线程进行处理，这里只是简单的返回字符串。 总结 各大语言实现socket通信的方式都是大同小异，在服务端的流程都是差不多的。在有现成高性能socket通信框架的情况下，建议不要自己去实现，但是得理解框架底层是怎样实现的。","categories":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/categories/Socket/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/tags/Socket/"},{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"},{"name":"Java","slug":"Java","permalink":"https://weeweetan.github.io/tags/Java/"}]},{"title":"VMware vSphere WebService SDK使用心得","slug":"VMware-vSphere-WebService-SDK使用心得","date":"2018-07-25T12:13:58.000Z","updated":"2019-05-15T13:27:59.170Z","comments":true,"path":"2018/07/25/VMware-vSphere-WebService-SDK使用心得/","link":"","permalink":"https://weeweetan.github.io/2018/07/25/VMware-vSphere-WebService-SDK使用心得/","excerpt":"","text":"善用mob（Managed Object Browser） mob地址一般是https://vcenter的FQDN/mob，mob可以让你更好的理解SDK中的那些例子，以及根据自己的业务逻辑改写一些功能。下图为mob首页图，图中的content为整个Managed Object的顶层，从这里进去可以找到整个vcenter server中所有对象及其属性。 善用GetMOREF类 GetMOREF类具体位置在VMware-vSphere-SDK-6.0.0-2561048\\SDK\\vsphere-ws\\java\\JAXWS\\samples\\com\\vmware\\connection\\helpers，这是VMware官方提供的一个工具类，里面的每个函数对于开发都很有用。例如 ​List&lt;VirtualDevice&gt; listvd = ((ArrayOfVirtualDevice) getMOREFs .entityProps(vmMor, new String[] { &quot;config.hardware.device&quot; }) .get(&quot;config.hardware.device&quot;)).getVirtualDevice(); 这是VMReconfig.java中的一个片段，这段代码的作用就是去获取指定虚拟机对象的所有设备，vmMor可以通过GetMOREF类中的vmByVMname函数去获得。至于config.hardware.device，就需要用mob一层一层点进去看了，相信结合mob就能理解为什么要这么写。 ​​ ManagedObjectReference propCol = connection.getServiceContent().getPropertyCollector(); ManagedObjectReference vmRef = getMOREFs.vmByVMname(virtualMachineName,propCol); 上面这段代码的作用就是如何根据虚拟机名去获取其对应的ManagedObjectReference 善用SDK里面的文档 文档首页为VMware-vSphere-SDK-6.0.0-2561048/SDK/vsphere-ws/docs/ReferenceGuide/index.html根据需求，在左侧导航栏对应的去找。 对SDK我整理了一下，使其能够在idea中编译运行，项目地址在VMwareProject ​","categories":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/categories/VMware-vSphere/"}],"tags":[{"name":"VMware-vSphere","slug":"VMware-vSphere","permalink":"https://weeweetan.github.io/tags/VMware-vSphere/"}]},{"title":"Socket粘包处理","slug":"Socket粘包处理","date":"2018-07-25T11:05:52.000Z","updated":"2019-05-15T13:53:21.823Z","comments":true,"path":"2018/07/25/Socket粘包处理/","link":"","permalink":"https://weeweetan.github.io/2018/07/25/Socket粘包处理/","excerpt":"","text":"背景 这段时间刚忙完了一个项目，涉及到PHP与Java进行socket通信的问题，应用场景是PHP端向Java端发送数据，并等待Java的响应结果，数据格式为JSON。 遇到的问题 PHP端发送数据后，Java端从socket里读取数据，但是一直读不到结束符。 原因 PHP需要调用socket_close函数才会向socket里面写入结束符。 改进方法 PHP端与Java端之间确定每次发送数据包的长度，用4个字节表示数据长度，PHP端先发送数据包长度，再发送数据包，Java端先接收4个字节长度的数据包长度，再根据数据包长度接收数据包。PHP端代码如下: ​ $socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP ) or die ( &apos;could not create socket&apos; ); $connect = socket_connect ( $socket, &apos;xxx.xxx.xxx.xxx&apos;, xxxx); //服务端发送数据 $arr = array(&quot;data&quot; =&gt; &quot;dadadada&quot;); $strlen = pack(&apos;i&apos;, strlen(json_encode($arr))); var_dump($strlen); socket_write ($socket, $strlen); socket_write ($socket, json_encode($arr), strlen(json_encode($arr))); $response = socket_read($socket, 4); $res = unpack(&apos;i&apos;, $response); var_dump($res); $response = socket_read($socket, $res[1]); var_dump($response); socket_close($socket); pack与unpack函数使用说明见PHP官方文档 ​","categories":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/categories/Socket/"}],"tags":[{"name":"Socket","slug":"Socket","permalink":"https://weeweetan.github.io/tags/Socket/"},{"name":"PHP","slug":"PHP","permalink":"https://weeweetan.github.io/tags/PHP/"}]},{"title":"使用gcc编译驱动模块遇到的问题","slug":"使用gcc编译驱动模块遇到的问题","date":"2017-05-22T09:30:33.000Z","updated":"2019-05-17T15:43:16.624Z","comments":true,"path":"2017/05/22/使用gcc编译驱动模块遇到的问题/","link":"","permalink":"https://weeweetan.github.io/2017/05/22/使用gcc编译驱动模块遇到的问题/","excerpt":"","text":"背景 由于工作中需要了解Linux的驱动模块，所以就开始学习，初看Linux驱动编程，跟着博客写一个块设备驱动学习，练习环境为centos6.5 gcc版本为6.3。 遇到的问题 跟着敲完那个简单的驱动程序后，发现编译出错，错误信息为 include/linux/compiler-gcc.h:89:30: fatal error: linux/compiler-gcc6.h: No such file or directory 一通百度，说gcc版本太高，去下载一个compiler-gcc6.h文件，放到内核源码文件夹里面，按着做了，结果编译又出问题了，错误信息为 include/linux/compiler.h:163:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void data_access_exceeds_word_size(void) include/linux/compiler.h:169:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void data_access_exceeds_word_size(void) include/linux/compiler.h:173:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void __read_once_size(volatile void *p, void *res, int size) include/linux/compiler.h:190:24: error: expected &apos;=&apos;, &apos;,&apos;, &apos;;&apos;, &apos;asm&apos; or &apos;__attribute__&apos; before &apos;void&apos; static __always_inline void __write_once_size(volatile void *p, void *res, int size) 解决方法 又是一通百度，发现跟我情况不符，看了下博客发表时间，08年，果断换了一个centos6.0的机器，gcc版本为4.6，编译完美通过,环境因素很重要啊。。。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/categories/Linux/"}],"tags":[{"name":"驱动模块","slug":"驱动模块","permalink":"https://weeweetan.github.io/tags/驱动模块/"},{"name":"Linux","slug":"Linux","permalink":"https://weeweetan.github.io/tags/Linux/"}]}]}