{"meta":{"title":"weeweetan's blog","subtitle":null,"description":null,"author":"weeweetan","url":"https://weeweetan.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-04-30T06:58:00.000Z","updated":"2019-05-15T06:20:17.816Z","comments":true,"path":"about/index.html","permalink":"https://weeweetan.github.io/about/index.html","excerpt":"","text":"尝试过的技术 VMware虚拟机备份与恢复 数据库备份与恢复 基于卷的持续数据保护 Linux块设备驱动 Linux C编程 ThinkPHP框架 Laravel框架 Java SE 目前正在研究的技术 Nginx CDN"},{"title":"书单","date":"2019-05-15T04:37:44.496Z","updated":"2019-05-15T04:37:44.496Z","comments":false,"path":"books/index.html","permalink":"https://weeweetan.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-05-15T04:37:44.497Z","updated":"2019-05-15T04:37:44.497Z","comments":false,"path":"categories/index.html","permalink":"https://weeweetan.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-05-15T04:37:44.497Z","updated":"2019-05-15T04:37:44.497Z","comments":true,"path":"links/index.html","permalink":"https://weeweetan.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-05-15T04:37:44.498Z","updated":"2019-05-15T04:37:44.498Z","comments":false,"path":"repository/index.html","permalink":"https://weeweetan.github.io/repository/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2019-05-15T01:36:14.000Z","updated":"2019-05-15T01:42:30.056Z","comments":true,"path":"resume/index.html","permalink":"https://weeweetan.github.io/resume/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-15T04:37:44.499Z","updated":"2019-05-15T04:37:44.499Z","comments":false,"path":"tags/index.html","permalink":"https://weeweetan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Nginx学习笔记","slug":"Nginx学习笔记","date":"2019-05-08T02:49:55.000Z","updated":"2019-05-13T15:27:36.850Z","comments":true,"path":"2019/05/08/Nginx学习笔记/","link":"","permalink":"https://weeweetan.github.io/2019/05/08/Nginx学习笔记/","excerpt":"","text":"编译步骤configure原理 configure本质上是个shell脚本，所以如果要完全理解configure需要熟悉shell基本语法，除此之外，脚本中大量运用了test、sed、cat、echo、grep等命令以及重定向符，所以也需要了解这些命令的用法。 auto脚本 auto脚本由一系列脚本组成，他们有一些是实现一些通用功能由其它脚本来调用（如have），有一些则是完成一些特定的功能（如option）。脚本之间的主要执行顺序及调用关系如下图所示（由上到下，表示主流程的执行）：上图中的脚本都位于auto目录下，所以省略，而configure与auto同级目录，故完整执行脚本如.auto/options所示。 源码解析 在ngx_module.h中引用了两个至关重要的外部变量 extern ngx_module_t *ngx_modules[]; extern char *ngx_module_names[]; ngx_modules跟ngx_module_names定义在ngx_modules.c中，这个文件并不存在于nginx源码中，在编译时执行configure动态生成。ngx_modules数组包含所有的Nginx模块，Nginx启动时会调用ngx_cycle_modules函数，原型如下： ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle) 此函数的目的是将ngx_modules中的数据复制到cycle中，函数调用顺序如下： main-&gt;ngx_init_cycle-&gt;ngx_cycle_modules handler模块的编写步骤 编写模块基本结构。包括模块的定义，模块上下文结构，模块的配置结构等，即分别初始化如下变量： static ngx_command_t ngx_http_module_name_commands[] = {}; static ngx_http_module_t ngx_http_module_name_module_ctx = {}; ngx_module_t ngx_http_module_name_module = {}; 实现handler的挂载函数。根据模块的需求选择正确的挂载方式，即实现如下函数： static ngx_int_t ngx_http_module_name_init(ngx_conf_t *cf)； 编写handler处理函数。模块的功能主要通过这个函数来完成，即实现如下函数： static ngx_int_t ngx_http_module_name_handler(ngx_http_request_t *r);","categories":[],"tags":[]},{"title":"libxml2使用心得","slug":"libxml2使用心得","date":"2019-05-04T14:21:35.000Z","updated":"2019-05-04T14:57:25.452Z","comments":true,"path":"2019/05/04/libxml2使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/05/04/libxml2使用心得/","excerpt":"","text":"背景 由于当前项目以xml文件作为通信媒介，故需要对xml文档进行解析与生成。但是libxml2文档写得不是很好，也没有例程，我在实际工作中主要参考C++的XML编程经验――LIBXML2库使用指南，这篇博文讲得很详细，我在这里只是做出一点补充。 问题 xml文档使用UTF-8编码，所以如果xml文档中包含中文，使用libxml2读取内容相关API时，在调试界面中看到读取出来的中文内容为乱码，这个时候就需要将内容转换为程序当前运行的编码格式。我使用visual studio2017，里面默认GBK编码，所以我在使用xml内容时就需要将UTF-8编码的内容转换为GBK，其他同理。 举例说明 我使用GLib2的g_locale_from_utf8将内容转换为本地程序默认的编码格式，在写入xml内容时使用g_locale_to_utf8将内容转换为UTF-8. 总结 总而言之，在读取xml相关内容时，首先将内容转换为程序默认的编码格式，写入xml内容时，将程序默认的编码格式转换为UTF-8。","categories":[],"tags":[]},{"title":"GLib使用心得","slug":"GLib使用心得","date":"2019-04-28T05:51:59.000Z","updated":"2019-05-04T14:18:26.133Z","comments":true,"path":"2019/04/28/GLib使用心得/","link":"","permalink":"https://weeweetan.github.io/2019/04/28/GLib使用心得/","excerpt":"","text":"前言关于GLib的介绍这里就不赘述了，具体API介绍可以去GLib API Reference查阅，这里只是记录一下使用相关API所遇到的一些坑。 相关API字符串相关APIGString *g_string_new(const gchar *init); GString *g_string_append(GString *string, const gchar *val); GString *g_string_prepend(GString *string, const gchar *val); gchar *g_string_free(GString *string, gboolean free_segment); 如果需要对字符串进行拼接操作，使用GString相关API是非常方便的。注意 g_string_new跟g_string_free一定要配套使用，否则会内存泄漏。g_string_append跟g_string_prepend都是直接在原字符串上操作，这点要切记。 字符转换相关APIgchar *g_filename_display_basename(const gchar *filename); gchar *g_locale_from_utf8(const gchar *utf8string, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error); gchar *g_locale_to_utf8(const gchar *opsysstring, gssize len, gsize *bytes_read, gsize *bytes_written, GError **error); g_filename_display_basename 此函数的参数字符编码必须是UTF-8，否则返回的字符串为乱码g_locale_from_utf8 此函数将参数字符串从UTF-8编码转换为程序当前的编码，一般是GB2312，一般用于读取UTF-8编码的文件g_locale_to_utf8 此函数将参数字符串从程序当前编码转换为UTF-8下面看个例子, 比如我们有个含中文的文件名 /data/test/哈哈.txt如果想获得 哈哈.txt，则必须首先使用 g_locale_to_utf8函数转换一次, 然后再去获取basename GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;); gchar *str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); gchar *basename = g_filename_display_basename(str); 如果想使用GString *类型保存basename，则必须重新申请内存块 GString *basename_string = g_string_new(basename); 千万别像下面这样做 GString *string = g_string_new(&quot;/data/test/哈哈.txt&quot;); string-&gt;str = g_locale_to_utf8(string-&gt;str, string-&gt;len, NULL, NULL, NULL); 如果像上面那样做，因为转换后的字符串长度跟转换前不一样，后续使用会出问题，g_locale_from_utf8 同理注意 g_locale_to_utf8返回的char *需要手动释放内存 解析key-value文件APIGKeyFile *g_key_file_new(void); gboolean g_key_file_load_from_file(GKeyFile *key_file, const gchar *file, GKeyFileFlags flags, GError **error); gint g_key_file_get_integer(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error); gchar *g_key_file_get_string(GKeyFile *key_file, const gchar *group_name, const gchar *key, GError **error); void g_key_file_free(GKeyFile *key_file); 这几个API很好理解,用来解析具有键值对特征的文件,g_key_file_new跟g_key_file_free配套使用;g_key_file_load_from_file的第二个参数的字符编码格式为UTF-8,在使用时一定要先转换一次;","categories":[],"tags":[]},{"title":"调用glib库出现0xc000007b解决办法","slug":"调用glib库出现0xc000007b解决办法","date":"2019-04-18T14:47:29.000Z","updated":"2019-04-19T01:13:20.420Z","comments":true,"path":"2019/04/18/调用glib库出现0xc000007b解决办法/","link":"","permalink":"https://weeweetan.github.io/2019/04/18/调用glib库出现0xc000007b解决办法/","excerpt":"","text":"背景之前一直在Linux环境下使用glib库，也一直没有遇到过这样的问题，这次在visual studio上配置使用glib，出现问题，如下图所示： 网上的解决办法都试过，没能解决问题。 出现转机出现转机是在朋友推荐了一款名为depends的软件，可以分析执行程序所需要的库，关于depends的使用方法这里就不仔细介绍了。 开始分析我使用depends分析libglib-2.0.dll，结果如下图所示从图中左上方区域可以看出libglib-2.0.dll需要libintl-8.dll，而这个dll又缺失，解决办法就显而易见。1、网上下载libintl-8.dll2、将libintl-8.dll与libglib-2.0.dll存放在同一目录下 问题解决上述步骤完成之后，再次使用depends检查，如下图所示：程序也正常运行 注意我这里只是说明解决问题的方法，图中dll版本问题自行忽略","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-16T13:44:16.987Z","updated":"2019-04-16T13:44:16.987Z","comments":true,"path":"2019/04/16/hello-world/","link":"","permalink":"https://weeweetan.github.io/2019/04/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}